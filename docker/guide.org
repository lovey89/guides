[[https://hub.docker.com]]

[[https://jonnylangefeld.github.io/learning/Docker/How%252Bto%252BDocker.html]]

[[https://docs.docker.com/engine/reference/builder/]]

* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#docker][Docker]]
  - [[#check-info-about-your-docker-installation][Check info about your docker installation]]
  - [[#run-a-container][Run a container]]
  - [[#list-containers][List containers]]
  - [[#stop-a-docker-container][Stop a docker container]]
  - [[#delete-a-container][Delete a container]]
  - [[#read-the-output-of-a-container-running-in-detached-mode][Read the output of a container running in detached mode]]
  - [[#images][Images]]
  - [[#run-a-ubuntu-container][Run a ubuntu container]]
  - [[#volumes][Volumes]]
- [[#dockerfile][Dockerfile]]
  - [[#copy-file-in-docker-container][Copy file in docker container]]
  - [[#run-a-jar-file-in-a-docker-image][Run a jar file in a docker image]]
  - [[#the-run-cmd-and-entrypoint-commands][The ~RUN~, ~CMD~ and ~ENTRYPOINT~ commands]]
  - [[#the-expose-command][The ~EXPOSE~ command]]
  - [[#the-volume-command][The ~VOLUME~ command]]
  - [[#the-user-command][The ~USER~ command]]
  - [[#the-healthcheck-command][The ~HEALTHCHECK~ command]]
  - [[#the-env-and-arg-commands][The ~ENV~ and ~ARG~ commands]]
  - [[#other-commands][Other commands]]
  - [[#more-advanced-example-with-python-installed][More advanced example with python installed]]
  - [[#tags][Tags]]
- [[#docker-compose][Docker compose]]
  - [[#hello-world][Hello world]]
  - [[#running-two-containers-with-python-and-postgresql][Running two containers with python and postgresql]]
  - [[#multiple-projects-and-overriding-the-docker-composeyml-file][Multiple projects and overriding the ~docker-compose.yml~ file]]
- [[#monitor][Monitor]]
- [[#other-commands-1][Other commands]]
  - [[#remove-all-images][Remove all images]]
  - [[#remove-all-containers][Remove all containers]]
- [[#to-investigate][To investigate]]
#+END_QUOTE

* Docker
** Check info about your docker installation

Show version

#+BEGIN_SRC
docker --version
#+END_SRC

Show more info about docker on the current maching

#+BEGIN_SRC
docker info
#+END_SRC

Show more information about the docker version

#+BEGIN_SRC
docker version
#+END_SRC

Show help about docker commands

#+BEGIN_SRC
docker --help
#+END_SRC

Some of the commands are not to be used anylonger. E.g. ~docker rmi~ is now
~docker image rm~. If you want to hide all legacy commands you can run

#+BEGIN_SRC
DOCKER_HIDE_LEGACY_COMMANDS=true docker --help
#+END_SRC

** Run a container
*** Run hello world

#+BEGIN_SRC bash
docker container run hello-world
#+END_SRC

Will return

#+BEGIN_SRC
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
#+END_SRC

After this the container is terminated

*** A more advanced example

In this example we will run the ~jboss/wildfly~. For now it's interesting
because it will expose port ~8080~ and we can navigate to a webpage.

#+BEGIN_SRC bash
docker container run -p 8080:8080 -it --name web jboss/wildfly
#+END_SRC

Then go to [[http://localhost:8080/]]

| Option                        | Description                                                                                                          |
|-------------------------------+----------------------------------------------------------------------------------------------------------------------|
| ~-it~                         | Run in interactive mode                                                                                              |
| ~-d~                          | Run in detached mode                                                                                                 |
| ~--name name~                 | Give the container a the name ~name~ instead of a random one                                                         |
| ~-P~                          | Expose the container port on random ports on the host system. Use ~docker container ls~ to see which port was chosen |
| ~-p host_port:container_port~ | Instead of chosing a random port you can chose one yourself                                                          |

#+BEGIN_SRC bash
docker container run -P -d --name web2 jboss/wildfly
#+END_SRC

This time the container runs in a detached mode (the command returns
immediately). To see which port the container is exposing

#+BEGIN_SRC bash
docker container ls
#+END_SRC

My output is

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES
21093c981261        jboss/wildfly       "/opt/jboss/wildfly/…"   10 seconds ago      Up 8 seconds        0.0.0.0:32768->8080/tcp   web2
#+END_SRC

so if I connect to port ~32768~ on localhost it will be routed to my container's port ~8080~.

*** Overriding the container default command

You can also override the command starting in the container (in this case
starting wildfly) by providing your own command after the image name. E.g.

#+BEGIN_SRC bash
docker container run -it --name web3 jboss/wildfly bash # Run in interactive mode since we now only start bash
#+END_SRC

Now we can freely navigate inside the containers file system. If you would
expose port ~8080~ of the container you would still not see anything on
[[http://localhost:8080/]] since wildfly hasn't started

*** Attach a volume

Start with creating a ~war~ file. Go to the ~build_wildfly_war~ directory (all
code is fetched from [[https://thepracticaldeveloper.com/2018/08/06/how-to-deploy-a-spring-boot-war-in-wildfly-jboss/][this webpage]]) and run

#+BEGIN_SRC bash
mvn clean install
#+END_SRC

Then we can run the following

#+BEGIN_SRC bash
docker container run -it --name web4 -p 8080:8080 -v $(pwd)/target/jboss-wildfly-demo-1.0.0-SNAPSHOT.war:/opt/jboss/wildfly/standalone/deployments/webapp.war jboss/wildfly
#+END_SRC

In this case we have made a file available for the container

| Option                                | Description                                                                                                                      |
|---------------------------------------+----------------------------------------------------------------------------------------------------------------------------------|
| ~-v host_location:container_location~ | Will make the file/dir at ~host_location~ on the host available at ~container_location~ in the container. Must be absolute paths |

In this case wildfly will find our ~.war~ file and deploy it. To verify that the
~.war~ file is deployed you can run

#+BEGIN_SRC bash
curl http://localhost:8080/webapp/hola
#+END_SRC

Remove all containers. For now we can run

#+BEGIN_SRC bash
docker container rm -f $(docker container ls -a -q)
#+END_SRC

** List containers

#+BEGIN_SRC bash
docker container ls
#+END_SRC

returns all running containers. If you run the [[*Run hello world][hello world]] example again you
will only see

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
#+END_SRC

The container is not running anylonger so nothing is printed. To also see exited
containers you will have to run

#+BEGIN_SRC bash
docker container ls -a
#+END_SRC

Will now return

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
3b383b36c992        hello-world         "/hello"            3 seconds ago       Exited (0) 1 second ago                       bold_feynman
#+END_SRC

** Stop a docker container

#+BEGIN_SRC bash
docker container stop <container>/<container_id>
#+END_SRC

*** Example

Run

#+BEGIN_SRC bash
docker container run -p 8080:8080 -d --name web jboss/wildfly
#+END_SRC

We already know that the name will be ~web~ but we can still find the id by
running

#+BEGIN_SRC bash
docker container ls
#+END_SRC

which returns

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
e39fc3ea0675        jboss/wildfly       "/opt/jboss/wildfly/…"   52 seconds ago      Up 50 seconds       0.0.0.0:8080->8080/tcp   web
#+END_SRC

We can now stop the container with

#+BEGIN_SRC bash
docker container stop web
# or
docker container stop e39fc3ea0675
#+END_SRC

You can now verify that the container has stopped with

#+BEGIN_SRC bash
docker container ls -a
#+END_SRC

** Delete a container

Just because a container is stopped doesn't mean that it has been removed. To
remove it you can run

#+BEGIN_SRC bash
docker container rm <container>/<container_id>
# or
docker container rm -f <container>/<container_id> # If you also want to be able to remove running containers
#+END_SRC

*** Example

#+BEGIN_SRC
$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES
e39fc3ea0675        jboss/wildfly       "/opt/jboss/wildfly/…"   2 minutes ago       Exited (0) 2 seconds ago                        web

$ docker container rm web
web

$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
#+END_SRC

*** Automatically remove a container after it stops

You can run a container with the ~--rm~ flag to remove it after it terminates.

#+BEGIN_SRC
$ docker container run -d --rm hello-world # Run the container in detached mode
6af1260e00c48224dc3c90601fbc1ac01bc62698c805c0faa6e290ee91e50c28

$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
#+END_SRC

*** Remove all exited containers

#+BEGIN_SRC bash
docker container rm $(docker container ls -a -f status=exited -q)
#+END_SRC

Other things to remove is described by [[https://www.digitalocean.com/community/tutorials/how-to-remove-docker-images-containers-and-volumes][this]] article.

** Read the output of a container running in detached mode

#+BEGIN_SRC bash
docker container logs <container>/<container_id>
#+END_SRC

Some useful options

| Option     | Description                                          |
|------------+------------------------------------------------------|
| ~-f~       | Follow log output                                    |
| ~--tail n~ | Show the ~n~ last lines in the log. Default is 'all' |
| ~-t~       | Show timestamps                                      |

*** Example

#+BEGIN_SRC
$ docker container run -d --name web jboss/wildfly
6dbd79e2d894abc81afba0777fa2ffae0744540a575515962818fdeb7819e77c

$ docker container logs web --tail 3
2020-04-01T20:58:16.009495544Z 20:58:16,009 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0060: Http management interface listening on http://127.0.0.1:9990/management
2020-04-01T20:58:16.009598742Z 20:58:16,009 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0051: Admin console listening on http://127.0.0.1:9990
2020-04-01T20:58:16.009762919Z 20:58:16,009 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly Full 18.0.1.Final (WildFly Core 10.0.3.Final) started in 3099ms - Started 315 of 577 services (369 services are lazy, passive or on-demand)
#+END_SRC

** Images
*** View images available for offline use

#+BEGIN_SRC bash
docker image ls
#+END_SRC

will now return

#+BEGIN_SRC
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
jboss/wildfly       latest              e6f71554a543        4 months ago        757MB
ubuntu              latest              775349758637        5 months ago        64.2MB
hello-world         latest              fce289e99eb9        15 months ago       1.84kB
#+END_SRC

*** Remove images

In order to free up some disk space you can remove an image with the command

#+BEGIN_SRC bash
docker image rm <image_name>
#+END_SRC

e.g.

#+BEGIN_SRC bash
docker image rm hello-world
#+END_SRC

** Run a ubuntu container

#+BEGIN_SRC bash
docker run -it --name my-linux-container ubuntu bash
#+END_SRC

Note that the command above is overriding the default command as described [[*Overriding the container default command][here]].

The first time docker will pull the ubuntu image from the official docker hub.
Any command run in the container will only live there for this session. If you
create a file (~touch myfile~) it will only exist until the container exits (the
~exit~ command).

Try running ~docker ps -a~ from another terminal and you will see that you have
a container running.

If you exit the container and then start it again you will see that it starts up
very fast. This time we don't have to download the image

** Volumes

You can also create a container that refers to some local files with the ~-v~
flag. The syntax is

#+BEGIN_SRC
-v [absolute path to local]:[absulute path inside container]
#+END_SRC

I don't know what happens when referring to a local relative path but I couldn't
see any data and no data was persisted. Maybe the path is relative to something
else but the current directory?

A full example would be

#+BEGIN_SRC bash
docker run -it --rm -v $PWD/my-shared-dir:/my-data ubuntu bash
#+END_SRC

If ~my-shared-dir~ doesn't exist in your home directory it will automatically be
created. Open the container and create a file in the ~my-data~ directory and you
will see that it is created in the ~my-shared-dir~ directory.

* Dockerfile

We can also create our own images. Until now we have only used images created by
others. If the image is not found locally it will search at the [[https://hub.docker.com/][official docker hub]].
We create our own images by writing a file called ~Dockerfile~. I have prepared
a file at [[file:01_my-ubuntu-image/Dockerfile][01_my-ubuntu-image/Dockerfile]].

#+INCLUDE: 01_my-ubuntu-image/Dockerfile src Dockerfile

Almost always you will base your image on another image. That is what the ~FROM~
keyword means. In our file we based it on the ~ubuntu~ image. After that you can
execute any linux command you want with the ~CMD~ keyword.

Navigate to the folder where the ~Dockerfile~ is created and run

#+BEGIN_SRC bash
docker image build -t my-ubuntu-image .
#+END_SRC

This command will create a new image with the name ~my-ubuntu-image~. The dot at
the end tells the command to use the current directory as the context (and look
for the ~Dockerfile~ here). It's advisable to only have what you need in the
context so the docker client doesn't send uneccessary data to the docker host.
If that is not possible you can have a ~.dockerignore~ file. So create a new
directory for each ~Dockerfile~ you create. You will now see your newly created
image when you run the ~docker image ls~ command.

Try running your container with

#+BEGIN_SRC bash
docker container run --rm my-ubuntu-image
#+END_SRC

The string ~Hello world~ is printed. That is because we used the ~CMD~ command.
When we are using the ~CMD~ command we will overwrite the command from the
parent image (which in this case was ~/bin/bash~).

You can see how the image was build using

#+BEGIN_SRC bash
docker image history my-ubuntu-image
#+END_SRC

** Copy file in docker container
*** The ~COPY~ command. TODO: Update with own war file

Copy new files or directories to the container filesystem

#+BEGIN_SRC
COPY host_file container_destination
#+END_SRC

It seems like as if ~host_file~ must be in the context (same directory or sub
directories of the ~Dockerfile~) when building the image.

I have created an example ~Dockerfile~ using ~COPY~ at [[file:03_copy_example/Dockerfile][03_copy_example/Dockerfile]].
Notice how this file doesn't have a ~CMD~ command. If none is given the ~CMD~
used in the parent will be used. If you have multiple ~CMD~ commands only the
last one will be used.

Build the image by navigating to ~03_copy_example~ and run

#+BEGIN_SRC bash
docker image build -t helloweb .
#+END_SRC

Then run the container and send a request to see that it works

#+BEGIN_SRC bash
docker container run -d -p 8080:8080 helloweb

curl http://localhost:8080/webapp/resources/persons
#+END_SRC

*** The ~ADD~ command

Allows tar file auto-extraction in the image. E.g:
~Add app.tar.gz /opt/var/myapp~. Can download files from a remote URL but
recommended to use ~curl~ or ~wget~ instead.

Investigate when this should be used. Seems like ~COPY~ is almost always the
correct command to use.

Apparently one of the reasons you should use ~RUN curl~ instead of ~ADD~ is that
you can chain the commands together instead of adding multiple layer. E.g.
download the file, extract it and remove all file you don't need with a single
~RUN~ command. In this way you can keep the file size down.

** Run a jar file in a docker image

I prepared a directory called ~04_java_jar~ with a [[file:04_java_jar/Dockerfile][Dockerfile]] and a simple java
project that will produce a jar. Build the java project with

#+BEGIN_SRC bash
mvn package
#+END_SRC

and then build the docker image and run it.

#+BEGIN_SRC bash
docker image build -t java-jar-container .

docker container run --rm java-jar-container
#+END_SRC

To include docker with maven you can look at [[https://github.com/fabric8io/docker-maven-plugin]].

** The ~RUN~, ~CMD~ and ~ENTRYPOINT~ commands
*** The ~RUN~ command

Runs a command in the container file system when building an image

#+BEGIN_SRC Dockerfile
RUN apt-get update && apt-get install -y git # Update your system
# or
RUN /opt/jboss/wildfly/bin/add-user.sh admin Admin#007 -silent # Other command
#+END_SRC

*** The ~CMD~ command

Defaults for executing container; can be [[*Overriding the container default command][overridden from CLI]]. A container can
have multiple ~CMD~ commands but only the last will run. If no ~CMD~ command is
provided the ~CMD~ from the parent container will be used.

#+BEGIN_SRC Dockerfile
CMD ["/opt/jboss/wildfly/bin/standalone.sh", "-b", "0.0.0.0", "-bmanagement", "0.0.0.0"]
# or
CMD java -jar /deployments/myapp-1.0-SNAPSHOT.jar
#+END_SRC

*** The ~ENTRYPOINT~ command

configures the container executable; can be overridden using ~--entrypoint~ from
CLI. The default value is ~/bin/sh -c~

#+BEGIN_SRC Dockerfile
ENTRYPOINT ["/entrypoint.sh"]
#+END_SRC

Investigate more what this is good for..

** The ~EXPOSE~ command

Expose network ports on which the container is listening

#+BEGIN_SRC Dockerfile
EXPOSE 9990
#+END_SRC

Need to explicitly publish the host port when starting the container (using ~-p~
or ~-P~, see [[*A more advanced example][this previous]] section).

** The ~VOLUME~ command

Creates a mount point with the specified name

#+BEGIN_SRC Dockerfile
VOLUME /opt/couchbase/var
#+END_SRC

Then you can mount a file or directory on the host system to that mount point

#+BEGIN_SRC bash
docker container run ... -v data:/opt/couchbase/var
#+END_SRC

TODO: What happens if we mount a volume without creating a mount point?

** The ~USER~ command

Set the user name or UID to use when running the image. Investigate more why
this is needed

** The ~HEALTHCHECK~ command

Performs a healthcheck on the application inside the container (and not only the
container itself).

#+BEGIN_SRC Dockerfile
HEALTHCHECK --interval=5s --timeout=3s CMD curl --fail http://localhost:8091/pools || exit 1
#+END_SRC

This will run the command ~curl --fail http://localhost:8091/pools || exit 1~
(administrative interface of couchbase) every 5 seconds and if it fails or
doesn't respond within 3 seconds the container will be marked as unhealthy.

** The ~ENV~ and ~ARG~ commands

~ARG~ are also known as build-time variables. They are available from when they
are declared until the image is built. So they will not be available for the
running container (including ~CMD~ and ~ENDPOINT~).

#+BEGIN_SRC Dockerfile
ARG var_name # This form expects the value to be provided when building
             # E.g. docker build --build-arg var_name=value
             # Otherwise it will fail
# or
ARG var_name=default_value
#+END_SRC

~ENV~ variable are also available during build time. They will also be available
to the container during run time as well.

#+BEGIN_SRC Dockerfile
ENV var_name
# or
ENV var_name=default_value
#+END_SRC

~ENV~ variable can be overridden when starting the container like

#+BEGIN_SRC bash
docker run -e "var_name=new_value" container_name
#+END_SRC

If you omit the value to set it will take the value from the host environment
and send to the host

#+BEGIN_SRC bash
export var_name=new_value
docker run -e var_name container_name
#+END_SRC

** Other commands

LABEL. WORKDIR, ONBUILD, STOPSIGNAL, SHELL

** More advanced example with python installed

Now we want to create a ubuntu container with python already installed. I have
created a ~Dockerfile~ for this at [[file:02_my-python-image/Dockerfile][02_my-python-image/Dockerfile]].

#+INCLUDE: 02_my-python-image/Dockerfile src Dockerfile

We dont use the ~CMD~ command in this ~Dockerfile~ which means that we inherit
the ~CMD~ command from the ~ubuntu~ image (~/bin/bash~). But we are using the
~RUN~ keyword which executes any linux command during the build of the
container. So:

- The ~CMD~ keyword is for what will run as soon as you start up the container
(could be any ~.sh~ script of course to make it more elaborated)
- The ~RUN~ keyword is if you want to install anything inside your container

Each row in the ~Dockerfile~ will create a cached container. This is helpful
if we need to rebuild our container. To not create unneccessary caches we should
put as many commands as possible on one row. That's why we run 3 commands on the
same line in the ~Dockerfile~ instead of just using 3 ~RUN~ commands (which is
also acceptable).

Navigate to the folder where the ~Dockerfile~ is created and run

#+BEGIN_SRC bash
docker build -t my-python-image .
#+END_SRC

Then run the container with the following command

#+BEGIN_SRC bash
docker run -it my-python-image
#+END_SRC

When you are inside the container you can verify that python is installed with

#+BEGIN_SRC bash
python3 --version
#+END_SRC

** Tags

I have prepared a ~Dockerfile~ at [[file:tags_examples/ver_1/Dockerfile][tags_examples/ver_1/Dockerfile]]. Navigate to
the directory and build it.

#+BEGIN_SRC bash
docker image build -t helloworld .
#+END_SRC

You will see the output

#+BEGIN_SRC 
Successfully tagged helloworld:latest
#+END_SRC

and ~latest~ is the default tag both when building and running. So if you don't
state a tag when starting a container it will automatically use ~latest~. Both
the following commands will work the same

#+BEGIN_SRC bash
docker container run helloworld
# or
docker container run helloworld:latest # Will produce the same thing since latest is default value
#+END_SRC

Remove the image we just created

#+BEGIN_SRC bash
docker container rm helloworld:latest
#+END_SRC

Now create a new image with an explicit tag instead

#+BEGIN_SRC bash
docker image build -t helloworld:1 .
#+END_SRC

Now the output will say

#+BEGIN_SRC
Successfully tagged helloworld:1
#+END_SRC

None of the previous commands to start a container will work now since there is
no ~helloworld~ container with a ~latest~ tag. Note that we don't have any other
tags on the container but still it doesn't work. We will have to explicitly
state which image and tag we want to use

#+BEGIN_SRC bash
docker container run helloworld:1
#+END_SRC

You can add more tags to an existing container with the ~tag~ command

#+BEGIN_SRC bash
docker image tag helloworld:1 helloworld:latest
#+END_SRC

If you now run ~docker image ls~ you will see both ~helloworld:1~ and
~helloworld:latest~ and both of them will have the same image id. Note that when
you try to remove one of these images it will only untag it and if we remove the
last tag from an image, the image itself will be removed.

Now if you enter the directory ~ver_2~ and build [[file:tags_examples/ver_2/Dockerfile][tags_examples/ver_2/Dockerfile]]
with:

#+BEGIN_SRC bash
docker image build -t helloworld:2 .
#+END_SRC

you will end up with a new image with a new image id. We can update the ~latest~
tag to point at version ~2~ (you don't have to untag first)

#+BEGIN_SRC bash
docker image tag helloworld:2 helloworld:latest
#+END_SRC

We can now easily choose which version to run by stating the tag (omitting the
tag will run ~latest~ which now points to version 2)

#+BEGIN_SRC bash
docker container run helloworld:1
docker container run helloworld:2
docker container run helloworld:latest # version 2
ocker container run helloworld # latest which is version 2
#+END_SRC

* Docker compose

You can easily run multicontainer applications with Docker Compose. The
configuration is by default defined in ~docker-compose.yml~ and settings can be
overridden by ~docker-compose.override.yml~. We can also provide multiple files
with the ~-f~ option.

#+BEGIN_SRC bash
docker-compose -v
docker-compose --help
docker-compose up --help
#+END_SRC

** Hello world

I have create a file [[file:05_docker-compose-hello-world/docker-compose.yml][05_docker-compose-hello-world/docker-compose.yml]] (the
compose file reference is found [[https://docs.docker.com/compose/compose-file/][here]]). Navigate to that directory and run:

#+BEGIN_SRC bash
docker-compose up -d
#+END_SRC

This will bring up all services (in the example above there's only one service)
in detached mode. If the ~deployments~ directory didn't already exist in your
home directory, it will now exist. I did have some problems with the permissions
when letting ~docker-compose~ create the ~deployments~ directory for me. There
was an error in the wildfly log but if I created the ~deployments~ directory
first the rest of this example will work.

Run:

#+BEGIN_SRC bash
docker-compose ps
#+END_SRC

to check the status. Run:

#+BEGIN_SRC bash
docker-compose logs -f
#+END_SRC

to see the logs. The ~deployments~ is still empty so if you run

#+BEGIN_SRC bash
curl http://localhost:8080/webapp/hola
#+END_SRC

nothing interesting will happen (apart from a 404 - Not Found). Copy our created
~war~ file to the ~deployment~ directory.

#+BEGIN_SRC bash
cp build_wildfly_war/target/jboss-wildfly-demo-1.0.0-SNAPSHOT.war ~/deployments/webapp.war
#+END_SRC

You will see in the wildfly log that it will be automatically deployed (unless
the ~deployment~ directory has the wrong permissions you get when it is created
automatically for you). Run the ~curl~ command above again and see that you get
a proper response.

Now bring down this service with

#+BEGIN_SRC bash
docker-compose down
#+END_SRC

This will stop and remove the service and also remove the network.

** Running two containers with python and postgresql

The file [[file:06_docker-compose-python-postgresql/docker-compose.yml][06_docker-compose-python-postgresql/docker-compose.yml]] will start up
two containers that will be able to communicate with each other. See the
comments inside that file for details.

It depends on [[file:06_docker-compose-python-postgresql/Dockerfile][06_docker-compose-python-postgresql/Dockerfile]] which in turn
depends on [[file:06_docker-compose-python-postgresql/postgresprog.py][06_docker-compose-python-postgresql/postgresprog.py]]. You can ignore
[[file:06_docker-compose-python-postgresql/docker-compose.exampleoverride.yml][06_docker-compose-python-postgresql/docker-compose.exampleoverride.yml]] fow now.

When running

#+BEGIN_SRC bash
docker-compose up -d
docker-compose logs -f
#+END_SRC

A container with a postgresql server will be started. When the container is
running (not necessarily the application itself) another container containing
our python program will be started (note the ~depends-on~ directive in the
~docker-compose.yml~ file). The python program will try to reconnect to the
database until it succeeds. It will probably fail the first time since the
database is not running yet. Then it will create a table, add one entry and
print all entries in the database every second. Try adding another line to the
table and see that the result changes.

The ~Dockerfile~ was automatically build when starting the containers. If you
do any changes in the ~Dockerfile~ or the python script you will have to run

#+BEGIN_SRC bash
docker-compose build
#+END_SRC

to rebuild it. Then you can start it again.

Note how the ~my-python~ service can refer to the ~postgres~ service by using
the service name (as given to the environment variable ~POSTGRES_LOCATION~).
To see what happens, connect to the ~my-python~ service:

#+BEGIN_SRC bash
docker exec -it python-postgres /bin/bash
#+END_SRC

and run

#+BEGIN_SRC bash
ping $POSTGRES_LOCATION
#+END_SRC

When you're done run

#+BEGIN_SRC bash
docker-compose down
#+END_SRC

This will stop and remove the services and also remove the network. If you start
the containers again you will see that all the data in the database has been
lost.

** Multiple projects and overriding the ~docker-compose.yml~ file

[[https://docs.docker.com/compose/reference/overview/][Overview of docker-compose CLI]]

When running the ~docker-compose~ command the containers will be run under a
specific project name (by default the directory name). This can be overridden
with the ~-p~ option. In the previous section you wont see 4 containers running
just because you run ~docker-compose up -d~ two times.

If you navigate to the ~06_docker-compose-python-postgresql~ directory and run

#+BEGIN_SRC bash
docker-compose up -d
#+END_SRC

followed by

#+BEGIN_SRC bash
docker-compose -p new-project-name up -d
#+END_SRC

you will see that it tries to start the containers but will soon complain that
the container names are already taken (they are defined in the
~docker-compose.yml~ file). We need to override them. I have already created the
file [[file:06_docker-compose-python-postgresql/docker-compose.exampleoverride.yml][06_docker-compose-python-postgresql/docker-compose.exampleoverride.yml]] (the
name ~docker-compose.override.yml~ is found by default and that would have
broken the example in the previous section).

An overriding file will replace or extend values. Single values (like
~container_name~) will replace the old value. Multi value options like ports are
concatenated (unless the mapping is replaced). With the ~-f~ option you can
choose compose file (instead of the default ~docker-compose.yml~). You can use
the option multiple times. The first file will be the primary file and the rest
will override (or extend) the previous files.

Now run

#+BEGIN_SRC bash
docker-compose -p new-project-name -f docker-compose.yml -f docker-compose.exampleoverride.yml up -d
#+END_SRC

At this point I learned the hard way that the old port mapping is not removed
for the postgres container. The resulting mapping for ~new-project-name~ looks
like this:

#+BEGIN_SRC Dockerfile
ports:
  - "5432:5432"
  - "15432:5432"
#+END_SRC

You can check what the result of the overriding would be by running

#+BEGIN_SRC bash
docker-compose -f docker-compose.yml -f docker-compose.exampleoverride.yml config
#+END_SRC

So the original mapping was never removed.

*** New try

According to [[https://github.com/docker/compose/issues/3729][this]] discussion it's best practive to not include anythine in your
~docker-compose.yml~ file that you might now want to have in another
environment. We will instead add the port mapping in the default override file.
The files [[file:07_docker-compose-python-postgresql-new-try/docker-compose.yml][docker-compose.yml]] and [[file:07_docker-compose-python-postgresql-new-try/docker-compose.override.yml][docker-compose.override.yml]] are created under
the ~07_docker-compose-python-postgresql-new-try~ directory. Run

#+BEGIN_SRC bash
docker-compose config
#+END_SRC

to see the resulting file. Then run

#+BEGIN_SRC bash
docker-compose up -d
#+END_SRC

to start the containers. I have also created another override file called
[[file:07_docker-compose-python-postgresql-new-try/docker-compose.overrride.new.yml][docker-compose.overrride.new.yml]] where I have overrided the container names
and defined another port mapping. To see the resulting file, run:

#+BEGIN_SRC bash
docker-compose -f docker-compose.yml -f docker-compose.override.new.yml config
#+END_SRC

and start it using

#+BEGIN_SRC bash
docker-compose -p new-project-name -f docker-compose.yml -f docker-compose.override.new.yml up -d
#+END_SRC

Note that in order to run any ~docker-compose~ commands for the new project you
will always have to refer to it using the ~-p~ flag. E.g.

#+BEGIN_SRC bash
docker-compose -p new-project-name ps
docker-compose -p new-project-name logs -f
docker-compose -p new-project-name down
#+END_SRC

Connect to each of the databases (one running on port ~5432~ and the other on
~15432~) and add different entries to each of them and verify the logs to see
that the python script have different outputs.

* Monitor

Start a container and give it a name ~container_name~. Run

#+BEGIN_SRC bash
docker container stats container_name
#+END_SRC

To format the output try these commands

#+BEGIN_SRC bash
docker container stats --format "{{.Container}}: {{.CPUPerc}}" container_name
docker container stats --format "table {{.Name}}\t {{.CPUPerc}}\t{{.MemUsage}}" container_name
#+END_SRC

Usually docker will update the data for you. If you only want a snapshot of the
information you can run

#+BEGIN_SRC bash
docker container stats container_name --no-stream
#+END_SRC

* Other commands

[[https://linuxize.com/post/how-to-remove-docker-images-containers-volumes-and-networks/]]

** Remove all images

#+BEGIN_SRC bash
docker image rm -f $(docker image ls -aq)
#+END_SRC

** Remove all containers

#+BEGIN_SRC bash
docker container rm -f $(docker container ls -aq)
#+END_SRC

* To investigate

vad gör ~docker run --restart always~?

docker service inspect container-name

docker service ps container-name # Kanske bara intressant för swarms med
replicas?

ssh -NL localhost:2374:/var/run/docker.sock user@host
docker -H localhost:2374 info
