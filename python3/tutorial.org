https://docs.python.org/3/
https://docs.python.org/3/library/index.html
https://docs.python.org/3/reference/index.html#reference-index
https://docs.python.org/3/library/functions.html#sorted


* Test code to check python versions

The ~python~ argument in the code block header accepts a path to your python
executable. I have both =python2= and =python3= in my path so that's why I can
write only the name of the executable. Evaluate the code by placing the cursor
inside the code block and press ~C-c C-c~

The following code block evaluates python2 code:

#+BEGIN_SRC python :python python2 :results output
import sys
print(sys.version)
#+END_SRC

And this code block evaluates python3 code:

#+BEGIN_SRC python :python python3 :results output
import sys
print(sys.version)
#+END_SRC

* Basics
** Types

#+BEGIN_SRC python :python python3 :results output
print("Integer:", 3)
print("Float:", 3.0)
print("Float:", 3.1)
#+END_SRC

** Basic math

Mathematical operators

#+BEGIN_SRC python :python python3 :results output
print(1 + 2)
print(10 - 4)
print(4 * 5)
print(7 / 3)
print(10 / 2, "(The result of division is always a float)")
#+END_SRC

Integer division

#+BEGIN_SRC python :python python3 :results output
print(7 // 3)
print(7.0 // 2.9 , "(Also works on floats)")
print(10.0 // 3.3)
print(10.0 // 3.4)
print(-7 // 3, "(The result is always rounded down)")
print(-7.0 // 3.0)
#+END_SRC

Modulo

#+BEGIN_SRC python :python python3 :results output
print(7 % 3, "(Smallest positive integer)")
print(-7 % 3)
#+END_SRC

Exponentiation

#+BEGIN_SRC python :python python3 :results output
print(2 ** 4)
print(2.0 ** 4)
print(2 ** 4.0)
print(2.0 ** 4.0)
#+END_SRC

Change precedence

#+BEGIN_SRC python :python python3 :results output
print(1 + 2 * 3)
print((1 + 2) * 3)
#+END_SRC

** Comparisons

Boolean values (note capitalization)

#+BEGIN_SRC python :python python3 :results output
print(True)
print(False)
#+END_SRC

Negation

#+BEGIN_SRC python :python python3 :results output
print(not True)
print(not False)
#+END_SRC

Boolean operators (~and~ and ~or~)

#+BEGIN_SRC python :python python3 :results output
print(True and False)
print(True or False)
#+END_SRC

Boolean operators with integers

#+BEGIN_SRC python :python python3 :results output
print(0 and 2)    # 0
print(-5 or 0)    # -5
print(0 == False) # True
print(2 == True)  # False
print(1 == True)  # True
#+END_SRC

Equality symbol (~==~)

#+BEGIN_SRC python :python python3 :results output
print(1 == 1)
print(2 == 1)
#+END_SRC

Inequality operator (~!=~)

#+BEGIN_SRC python :python python3 :results output
print(1 != 1)
print(2 != 1)
#+END_SRC

Size comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 10)
print(1 > 10)
print(2 <= 2)
print(2 >= 2)
#+END_SRC

Chained comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 2 < 3)
print(2 < 3 < 2)
#+END_SRC

Lazy evaluation

#+BEGIN_SRC python :python python3 :results output
print(False and (5 / 0))
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
print(5 / 0) # Run as a comparison. This one fails
#+END_SRC

What different types evaluate to

#+BEGIN_SRC python :python python3 :results output
print(bool(0))
print(bool(0.0))
print(bool(""))
print(bool([])) # Empty list
print(bool({})) # Empty dictionairy
print(bool(())) # Empty tuple
print("Other values evaluate to True (this doesn't mean that they are equal to True as seen earlier)")
#+END_SRC

Equality (~==~) vs ~is~ operator
~is~ checks if two variables refer to the same object, but ~==~ checks if the
objects pointed to have the same values

#+BEGIN_SRC python :python python3 :results output
a = [1, 2, 3, 4]         # Point a at a new list, [1, 2, 3, 4]
b = a                    # Point b at what a is pointing to
print("b is a:", b is a) # => True, a and b refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
b = [1, 2, 3, 4]         # Point b at a new list, [1, 2, 3, 4]
print("b is a:", b is a) # => False, a and b do not refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
#+END_SRC

** Strings

Strings are surrounded with ~"~ or ~'~

#+BEGIN_SRC python :python python3 :results output
print("This is a string.")
print('This is also a string.')
#+END_SRC

Concatenation

#+BEGIN_SRC python :python python3 :results output
print("Hello " + "world!")
print("Hello " "world!") # Prefered way

# Put strings inside brackets to concatenate and put in variable (doesn't work with variables)
myString = ("Hello "
            "world!")
print(myString)
#+END_SRC

Treat it as a list of characters

#+BEGIN_SRC python :python python3 :results output
print("This is a string"[0])
#+END_SRC

Find the length of the string

#+BEGIN_SRC python :python python3 :results output
print(len("This is a string"))
#+END_SRC

Formatting string

#+BEGIN_SRC python :python python3 :results output
print("{} can be {}".format("Strings", "interpolated"))
print("{0} be nimble, {0} be quick, {0} jump over the {1}".format("Jack", "candle stick"))
print("{name} wants to eat {food}".format(name="Bob", food="lasagna"))
#+END_SRC

Raw strings

#+BEGIN_SRC python :python python3 :results output
print('\'Hello\nWorld\'')
print(r'\'Hello\nWorld\'') # print it exactly as it is written
#+END_SRC

Multi line string

#+BEGIN_SRC python :python python3 :results output
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
print("---")
# Add a '\' at the end and no trailing newline will be added
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to\
""")
print("---")
#+END_SRC

Repeating strings

#+BEGIN_SRC python :python python3 :results output
print("na " * 8 + "BATMAN")
#+END_SRC

** The ~None~ object

#+BEGIN_SRC python :python python3 :results output
print(None)
#+END_SRC

Compare with ~is~ operator instead of ~==~

#+BEGIN_SRC python :python python3 :results output
print('"etc" is None:', "etc" is None)
print('None is None:', None is None)
print('None == None', None == None)
#+END_SRC

** Variables

No need to declare variables before assigning to them. Convention is to use
lower_case_with_underscores

#+BEGIN_SRC python :python python3 :results output
some_var = 5
print("some_var:", some_var)
#+END_SRC

Accessing a previously unassigned variable raises an exception

#+BEGIN_SRC python :python python3 :results output
# The following error is intentional
some_unknown_var  # Raises a NameError
#+END_SRC

* Lists

Lists are mutable (tuples are not)

** Creating lists

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty list
li = []
print("li:", li)
# Or a prefilled list
prefilled_li = [4, 5, 6]
print("prefilled_li:", prefilled_li)
print("type([]):    ", type([]))
print("type([1,2]): ", type([1,2]))
#+END_SRC

** Add stuff to the end of the list

#+BEGIN_SRC python :python python3 :results output
li = []
print("li:", li)
li.append(1) # We have to do it in a separate step since this function only returns None (run help(list.append))
print("li:", li)
li.append(2)
print("li:", li)
li.append(4)
print("li:", li)
li.append(3)
print("li:", li)
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("li:       ", li)
print("li[0]:    ", li[0])
print("li[1]:    ", li[1])
# Negative index access elements counted from the end
print("li[-1]:   ", li[-1])
print("li[-2]:   ", li[-2])
print("li[2] = 5:")
li[2] = 5
print("li:       ", li)
#+END_SRC

** Remove (and return) from end with ~pop~

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
popped_value = li.pop()
print("popped_value:", popped_value)
print("li:", li)
# put it back with li.append
li.append(popped_value)
print("li:", li)
#+END_SRC

** Slicing with ~li[start:end(:step)]~

We will use a string as an example here. After all, a string is nothing other
than a tuple of characters. In the table below the dots are not included in the
string "Python" but will just point out the different "stops" of a index.

|  . | P |  . | y |  . | t |  . | h |  . | o |  . | n | . |
|----+---+----+---+----+---+----+---+----+---+----+---+---|
|  0 |   |  1 |   |  2 |   |  3 |   |  4 |   |  5 |   | 6 |
| -6 |   | -5 |   | -4 |   | -3 |   | -2 |   | -1 |   |   |

#+BEGIN_SRC python :python python3 :results output
pString = "Python"
print("pString[:] ", pString[:])
print("pString[3:]", pString[3:])
print("pString[:3]", pString[:3])
print("pString[1:5]", pString[1:5])
print("pString[::2]", pString[::2])
print("pString[1::2]", pString[1::2])
print("pString[:4:2]", pString[:4:2])
print("pString[1:5:3]", pString[1:5:3])
# And negative values
print("pString[-6:-1]", pString[-6:-1])
print("pString[::-1]", pString[::-1])
print("pString[-1:-6:-1]", pString[-1:-6:-1]) # Note that the start value now is
                                              # larger than end value
#+END_SRC

You can also update a list using slices

#+BEGIN_SRC python :python python3 :results output
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
print("letters:", letters)
letters[2:5] = ['C', 'D', 'E']
print("letters:", letters)
letters[2:5] = [] # The length can be changed
print("letters:", letters)
#+END_SRC

** Make a one layer deep copy using slices

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = li[:]
print("li: ", li)
print("li2:", li2)
print("li == li2:", li == li2) # Check for equality
print("li is li2:", li is li2) # Check if they are the same object
#+END_SRC

** Removing an element (~del~)

Removes an element given an index or slice

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 4, 5, 6, 7, 8]
print("li:", li)
print("li[2]:", li[2])
del li[2]
print("li:", li)
print("li[2]:", li[2])
del li[2::2]
print("li:", li)
# Remove the whole list
del li
# The following line will result in an error
#print("li:", li)
#+END_SRC

** Remove first occurence of a value (~remove~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.remove(2) # Calling this twice would result in a ValueError exception since 2 is not in the list
print("li:", li)
#+END_SRC

** Inserting an element in list (~insert~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.insert(1, 5) # At index 1 insert 5
print("li:", li)
#+END_SRC

** Get index of first occurence of a value (~index~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 2]
print("li.index(2):", li.index(2)) # A non existing value would raise an ValueError exception
#+END_SRC

** Concatenating lists (~+~ and ~extend~)

The following code will create a new list:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
print("li + li2:", li + li2) # The lists are not affected
print("li:      ", li)
print("li2:     ", li2)
#+END_SRC

This code will update list ~li~:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
li.extend(li2) # Now li has changed
print("li: ", li)
print("li2:", li2)
#+END_SRC

** Check for existence (~in~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("1 in li:", 1 in li)
print("7 in li:", 7 in li)
#+END_SRC

** Length of list (~len~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("len(li): ", len(li))
#+END_SRC

** Multidimensional lists

#+BEGIN_SRC python :python python3 :results output
matrix = [[1, 2, 3],['a', 'b', 'c']]
print(matrix[0][1]) # 2
#+END_SRC

** Some commands in actions

#+BEGIN_SRC python :python python3 :results output
fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
print("fruits:                   ", fruits)
print("fruits.count('apple'):    ", fruits.count('apple'))
print("fruits.count('tangerine'):", fruits.count('tangerine'))
print("fruits.index('banana'):   ", fruits.index('banana'))
# Find next banana starting a position 4
print("fruits.index('banana', 4):", fruits.index('banana', 4))
print("fruits.reverse()")
fruits.reverse()
print("fruits:                   ", fruits)
print("fruits.append('grape')")
fruits.append('grape')
print("fruits:                   ", fruits)
print("fruits.sort()")
fruits.sort()
print("fruits:                   ", fruits)
print("fruits.pop():             ", fruits.pop())
print("fruits:                   ", fruits)
#+END_SRC

* Tuples

Tuples are immutable. The mutable equivalent would be list

** Creating tuples

#+BEGIN_SRC python :python python3 :results output
print("tup = (1, 2, 3)")
tup = (1, 2, 3)
print("tup:       ", tup)
print("A one element long tuple needs comma after the last element:")
print("type((1)): ", type((1)))
print("type((1,)):", type((1,)))
print("type(()):  ", type(()))
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("tup[0]:", tup[0])
# tup[0] = 3 is not allowed (tuples are immutable) and would raise a TypeError exception
#+END_SRC

** List elements that also works on tuples

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("len(tup):       ", len(tup))
print("tup + (4, 5, 6):", tup + (4, 5, 6))
print("tup[:2]:        ", tup[:2])
print("2 in tup:       ", 2 in tup)
#+END_SRC

** Unpacking tuples (also lists)

The number of variables and values must match

#+BEGIN_SRC python :python python3 :results output
a, b, c = (1, 2, 3)
print("a:", a)
print("b:", b)
print("c:", c)
#+END_SRC

You can also use the asterisk to capture several variables

#+BEGIN_SRC python :python python3 :results output
a, *b, c = (1, 2, 3, 4) # Only one variable may use the asterisk
print("a:", a)
print("b:", b) # This will be a list
print("c:", c)
#+END_SRC

The paranthesis are not needed. Tuples are created by default

#+BEGIN_SRC python :python python3 :results output
d, e, f = 4, 5, 6
print("d:", d)
print("e:", e)
print("f:", f)
#+END_SRC

This makes it very easy to swap two values

#+BEGIN_SRC python :python python3 :results output
d = 4
e = 5
e, d = d, e
print("d:", d)
print("e:", e)
#+END_SRC

* Dictionairies
** Creating dictionairies

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty dictionairy
empty_dict = {}
print("empty_dict:       ", empty_dict)

# Or a prefilled dictionairy
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:      ", filled_dict)
print("type(filled_dict):", type(filled_dict))
#+END_SRC

The keys of the dictionairy needs to be of an immutable type (such as int,
float, string or tuple). This is because python needs to calculate hash values
for lookups. Values can be of any type.

#+BEGIN_SRC python :python python3 :results output
valid_dict = {(1,2,3):[1,2,3]}
print("valid_dict:", valid_dict)
# You are not limited to one type of key/value
other_valid_dict = {1: 2, "three": "four"}
print("other_valid_dict:", other_valid_dict)
#+END_SRC

** Look for existence of keys

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('"one" in filled_dict:', "one" in filled_dict)
print("1 in filled_dict:    ", 1 in filled_dict)
#+END_SRC

** Look for values (using keys)

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict["one"]:        ', filled_dict["one"])
# Looking up a non-existing key raises and KeyError. Use get instead
print('filled_dict.get("one"):    ', filled_dict.get("one"))
print('filled_dict.get("four"):   ', filled_dict.get("four")) # Not found so returns <None>
print('filled_dict.get("one", 4): ', filled_dict.get("one", 4))
print('filled_dict.get("four", 4):', filled_dict.get("four", 4)) # Not found so returns default value 4
#+END_SRC

** Get all keys and values

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict.keys():        ", filled_dict.keys())       # The order is non predictable
print("list(filled_dict.keys()):  ", list(filled_dict.keys())) # To get the result as a list
print("filled_dict.values():      ", filled_dict.values())     # The indexes seems to match for keys and values
print("list(filled_dict.values()):", list(filled_dict.values()))
#+END_SRC

** Adding value to dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
filled_dict["four"] = 5
print("filled_dict:", filled_dict)
# I don't see why I should use this method as the indexing version can both add and update
returnValue = filled_dict.update({"four":4}) # Always return None (not the previous value)
print("returnValue:", returnValue)
print("filled_dict:", filled_dict)
#+END_SRC

** Add value if it is not present

The method ~setdefault()~ is similar to ~get()~, but will set
~dict[key]=default~ if key is not already in dict.

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict.setdefault("five", 5):', filled_dict.setdefault("five", 5))
print("filled_dict:", filled_dict)
print('filled_dict.setdefault("five", 6):', filled_dict.setdefault("five", 6)) # Will still be 5
print("filled_dict:", filled_dict) # This list hasn't changed
#+END_SRC

** Remove key/value pair using key

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
del filled_dict["one"]
print("filled_dict:", filled_dict)
#+END_SRC

* Sets

A ~set~ is an unordered collection with no duplicate elements. Supports typical
set operations like union, intersection, difference, and symmetric difference.

Uses curly braces, just like dictionairies but with single values instead. To
create an empty set you will have to use ~set()~ as ~{}~ creates an empty
directory

#+BEGIN_SRC python :python python3 :results output
empty = set()
print(empty)
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)
print('orange' in basket)
print('crabgrass' in basket)
#+END_SRC

Set operations. String is an iterable so when giving a string to the ~set~
constructor it will build a set of the characters

#+BEGIN_SRC python :python python3 :results output
a = set('abracadabra')
b = set('alacazam')

print("a:    ", a)
print("b:    ", b)
print()
# Difference
print("a - b:", a - b)
# Union
print("a | b:", a | b)
# Intersection
print("a & b:", a & b)
# Symmetric difference
print("a ^ b:", a ^ b)
#+END_SRC

* Control flows
** ~if~ statement

#+BEGIN_SRC python :python python3 :results output :preamble def input(x): return 2
# In the header of this block we have redefined input as we can't run this interactively
x = int(input("Please enter an integer: "))

if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
#+END_SRC

** ~for~ statement

Iterates over any sequence and not only an arithmetic progression

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
#+END_SRC

Note that the variable w will still be set after the loop finishes

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))

print("After loop:", w)
#+END_SRC

Also supports ~else~ when it is exiting the ~for~ loop

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
else:
    print("exit")
#+END_SRC

~continue~ and ~break~ works as expected. If break is called the ~else~ clause
won't be called if it exists

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        continue
    print(w, len(w))
else:
    print("exit")
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        break
    print(w, len(w))
else:
    print("exit")
#+END_SRC

*** An example

#+BEGIN_SRC python :python python3 :results output
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
#+END_SRC

** ~while~ statement

Works as expected

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
#+END_SRC

Also supports ~else~

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
else:
    print("done")
#+END_SRC

~continue~ and ~break~ works the same as with ~for~ loops

** The ~range()~ function

Can be used when you need to iterate over an arethmetic progression. The endpoint is never generated

#+BEGIN_SRC python :python python3 :results output
for i in range(5):
    print(i) # Will print 0 to 4
#+END_SRC

You can define start and end point

#+BEGIN_SRC python :python python3 :results output
for i in range(5, 10):
    print(i)
#+END_SRC

And define a step size

#+BEGIN_SRC python :python python3 :results output
for i in range(0, 10, 3):
    print(i)
#+END_SRC

And also ranges with negative step

#+BEGIN_SRC python :python python3 :results output
for i in range(-10, -100, -30):
    print(i)
#+END_SRC

To iterate over the indices of a sequence, you can combine range() and len() as follows

#+BEGIN_SRC python :python python3 :results output
a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])
#+END_SRC

Printing a range

#+BEGIN_SRC python :python python3 :results output
myRange = range(5)
print(myRange)
print(list(myRange))
print(tuple(myRange))
#+END_SRC

** ~pass~ statement

Does nothing but can be used when a statement is needed syntactically

#+BEGIN_SRC python :python python3 :results output
def f(arg):
    pass    # a function that does nothing
#+END_SRC

* Functions

The first line in the following function is the documenation string (and is
optional). Some tools can extract this string

#+BEGIN_SRC python :python python3 :results output
def fib(n):    # write Fibonacci series up to n
    """Print a Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
#+END_SRC

Call by value

#+BEGIN_SRC python :python python3 :results output
def f(n):
    print("In function:   ", n)
    n = 3
    print("In function:   ", n)

myVar = 5
f(myVar)
print("After function:", myVar)
#+END_SRC

But passes references

#+BEGIN_SRC python :python python3 :results output
def f(aList):
    print("In function:   ", aList)
    aList[1] = 5
    print("In function:   ", aList)

myList = [1, 2, 3]
f(myList)
print("After function:", myList)
#+END_SRC

A function that doesn't return any value will return the value ~None~.

You can create a function which returns a value with the ~return~ keyword

#+BEGIN_SRC python :python python3 :results output
def fib2(n):  # return Fibonacci series up to n
    """Return a list containing the Fibonacci series up to n."""
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)    # see below
        a, b = b, a+b
    return result

f100 = fib2(100)
print(f100)
#+END_SRC

~return~ without arguments will return ~None~. If execution reaches the end of
the method it will also return ~None~

** Variable number of arguments
*** Default argument values

#+BEGIN_SRC python :python python3 :results output
def ask_ok(prompt, retries=100, reminder='Please try again!'):
    print("prompt:  ", prompt)
    print("retries: ", retries)
    print("reminder:", reminder)
    print()

ask_ok("Test", 5, "Last")
ask_ok("Test", 5)
ask_ok("Test")
ask_ok("Test", reminder="Last")
#+END_SRC

Note that the default value will only be evaluated once. Mutable objects may be
updated

#+BEGIN_SRC python :python python3 :results output
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
#+END_SRC

*** Keyword arguments

All keyword arguments must be placed after all positional arguments

#+BEGIN_SRC python :python python3 :results output
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")
    print()

# This method can be called in several different ways
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
#+END_SRC

*** Arbitrary Argument Lists

Can be preceded by zero or more normal arguments. Can also be followed by
keyword arguments. A variadic variable will be a tuple

#+BEGIN_SRC python :python python3 :results output
def report(header, *entries, sep='\n'):
    print(header)
    print('-' * len(header))
    print(sep.join(entries))
    print()

report("Food", "Bread", "Butter")
report("Food", "Bread", "Butter", sep=" ")
#+END_SRC

A special variadic element can also be defined with ~**~ which will be treated
as a dictionairy. The dictionairy will _always_ be in the same order as the
arguments passed

#+BEGIN_SRC python :python python3 :results output
def report(header, *entries, **dictentries):
    print(header)
    print('-' * len(header))
    print('\n'.join(entries))
    print('-' * len(header))
    for kw in dictentries:
        print(kw, ":", dictentries[kw])
    print()

report("Food", "Bread", "Butter", test1=1, test2=2)
report("Food", "Bread", "Butter", sep=" ")
#+END_SRC

*** Unpacking variables

Sometimes you have the arguments in a list and you need to provide them to a
function separately. Then you'll have to unpack them

#+BEGIN_SRC python :python python3 :results output
print(list(range(3, 6)))
args = [3, 6]
print(list(range(*args)))
#print(list(range(args))) # This will fail
#+END_SRC

Same thing when unpacking dictionairies. But you'll unpack it with the ~**~
operator

#+BEGIN_SRC python :python python3 :results output
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")

d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)
#+END_SRC

** Lambda Expressions

In the following example we uses a lambda to create a new function (currying?)

#+BEGIN_SRC python :python python3 :results output
def make_incrementor(n):
    return lambda x: x + n

f = make_incrementor(42)
print(f(0))
print(f(1))
#+END_SRC

You can also use lambdas when you need to provide a function to another
function. In this example we want to sort the list on the string (the second
entry in each tuple)

#+BEGIN_SRC python :python python3 :results output
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
print(pairs)
#+END_SRC

** Documentation string

The first line in the documentation string should be short, concise summary of
the object’s purpose. If more documentation is needed the second line should be
blank. You can reach the doc string with the ~.__doc__~ call.

#+BEGIN_SRC python :python python3 :results output
def my_function():
    """Do nothing, but document it.

    No, really, it doesn't do anything.
    """
    pass

print(my_function.__doc__)
#+END_SRC

** Function annotations

Function annotations are optional and they can be used for whatever you feel.
Parameter annotations are defined by a colon after the parameter name, followed
by an expression evaluating to the value of the annotation. Return annotations
are defined by a literal ~->~, followed by an expression, between the parameter
list and the colon denoting the end of the def statement.

#+BEGIN_SRC python :python python3 :results output
def f(ham: str, eggs: str = 'eggs') -> str:
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham + ' and ' + eggs

print(f('spam'))
#+END_SRC

A more advanced example

#+BEGIN_SRC python :python python3 :results output
def validate(func, locals):
    for var, test in func.__annotations__.items():
        value = locals[var]
        msg = 'Var: {0}\tValue: {1}\tTest: {2.__name__}'.format(var, value, test)
        assert test(value), msg


def is_int(x):
    return isinstance(x, int)

def between(lo, hi):
    def _between(x):
            return lo <= x <= hi
    return _between

def f(x: between(3, 10), y: is_int = 1):
    validate(f, locals()) # locals return a dictionairy for the arguments
    print(x, y)


f(5)
f(5, 1)
#+END_SRC

You can also use them for documentation if you want. E.g. what kind of data you
expect or the types of the arguments.

* Data structures
** List comprehensions

Can be used to create new lists where each element is the result of some
operations applied to each member of another sequence or iterable, or to create
a subsequence of those elements that satisfy a certain condition.

#+BEGIN_SRC python :python python3 :results output
squares = []
for x in range(10):
    squares.append(x**2)

print(squares)
# A side effect of doing it this way
print(x)
#+END_SRC

This can be replaced with

#+BEGIN_SRC python :python python3 :results output
squares = list(map(lambda x: x**2, range(10)))
print(squares)
#+END_SRC

or (note that there are no side effects on this call)

#+BEGIN_SRC python :python python3 :results output
x = 3
squares = [x**2 for x in range(10)]
print(squares)
print(x)
#+END_SRC

You can add more ~for~ clauses and optional ~if~ clasuses to the comprehension.

#+BEGIN_SRC python :python python3 :results output
myVar = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
print(myVar)
#+END_SRC

You can use the variable multiple times

#+BEGIN_SRC python :python python3 :results output
myVar = [(x, x**2) for x in range(6)]
print(myVar)
#+END_SRC

Or flatten a matrix

#+BEGIN_SRC python :python python3 :results output
vec = [[1,2,3], [4,5,6], [7,8,9]]
myVar = [num for elem in vec for num in elem]
print(myVar)
#+END_SRC

You can also create a dictionairy with dict comprehension

#+BEGIN_SRC python :python python3 :results output
myDict = {x: x**2 for x in (2, 4, 6)}
print(myDict)
#+END_SRC

** Nested list comprehensions

The expression in a list comprehension can be another comprehension. The
following code will transpose the matrix

#+BEGIN_SRC python :python python3 :results output
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
transposed = [[row[i] for row in matrix] for i in range(4)]
print(transposed)
#+END_SRC

* Example programs
** Read command line arguments

#+BEGIN_SRC python :python python3 :results output :preamble import sys; sys.argv = ["1","2","a"]
# In the header of this block we have redefined sys.argv
import sys

print(len(sys.argv))
for arg in sys.argv:
    print(arg)
#+END_SRC

