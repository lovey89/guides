* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#journalctl][journalctl]]
- [[#tar][tar]]
  - [[#main-operation-modes][Main operation modes]]
  - [[#examples][Examples]]
- [[#find][find]]
  - [[#options][Options]]
  - [[#use-find-together-with-the-xargs-command][Use ~find~ together with the ~xargs~ command]]
  - [[#example][Example]]
- [[#tcpdump][tcpdump]]
  - [[#example-1][Example]]
- [[#docker][Docker]]
  - [[#view-stdout-from-container][View stdout from container]]
- [[#ssh][ssh]]
  - [[#attach-to-tmux-on-connect][Attach to ~tmux~ on connect]]
  - [[#port-forwarding][Port forwarding]]
  - [[#reverse-port-forwarding][Reverse port forwarding]]
  - [[#setting-up-a-socks-proxy][Setting up a socks proxy]]
  - [[#handling-keys][Handling keys]]
- [[#dnf][dnf]]
  - [[#adding-a-repo][Adding a repo]]
- [[#disk-and-partition-info][Disk and partition info]]
  - [[#mounted-file-systems][Mounted file systems]]
  - [[#display-disk-information][Display disk information]]
- [[#rmlint][rmlint]]
- [[#exiftool][Exiftool]]
  - [[#renaming-images][Renaming images]]
#+END_QUOTE

* journalctl

See errors in the log from the last boot

#+BEGIN_SRC bash
journalctl -b -p err
#+END_SRC

* tar
** Main operation modes

| Flag | Description               |
|------+---------------------------|
| ~c~  | Create an archive         |
| ~x~  | Extract an archive        |
| ~t~  | Table of contents         |
| ~r~  | Append to exising archive |

** Examples
*** Create a tar (~.tar~)

#+BEGIN_SRC bash
tar -cf file.tar file1 file2 file3
#+END_SRC

It's important that the ~f~ flag is the last parameter as it accepts multiple
arguements. If you want to see what is put in the tar ball also use the verbose
flag, ~v~.

#+BEGIN_SRC bash
tar -cvf file.tar file1 file2 file3
#+END_SRC

Creating a tar is recursive (it accepts directories and it's content). Files
are by default not removed when a tar i created.

**** Extract

Use the ~x~ flag (extract) with ~f~ flag. ~v~ can optionally be used to see what
is extracted.

#+BEGIN_SRC bash
tar -xvf file.tar
#+END_SRC

*** Create a zipped tar (~.tar.gz~)

As above but also include the ~z~ flag for zipped files or ~j~ for ~.bz2~.

#+BEGIN_SRC bash
tar -cvzf files.tar.gz file1 file2 file3
#+END_SRC

**** Extract

As above but also include the ~z~ or ~j~ flag

#+BEGIN_SRC bash
tar -xzvf files.tar.gz
#+END_SRC

*** Add files to an already existing tar file

You should be able to use the command below with the ~v~ flag and ~z~ or ~j~
flags as well

#+BEGIN_SRC bash
tar -rf file.tar file1
#+END_SRC

*** List the files in a tar

I guess you can run this command with the ~z~ or ~j~ flags as well

#+BEGIN_SRC bash
tar -tf file.tar
#+END_SRC

* find

#+BEGIN_SRC bash
find <paths>.. options
#+END_SRC

** Options

| Option            | Description                                                                                                         |
|-------------------+---------------------------------------------------------------------------------------------------------------------|
| ~-print~          | The name of the found file is printed                                                                               |
| ~-name~ /pattern/ | Files that matches /pattern/ which is a glob so don't forget to escape it. Only matches name and not the whole path |
| ~-type~ /type/    | Match file of certain type. Examples of type are: ~d~ (directory), ~f~ (file) or ~l~ (symbolic link)                |
| ~-size~           | Size of the file. See man page                                                                                      |
| ~-mtime~          | When the file was modifiled. See man page                                                                           |
| ~-atime~          | When the file was accessed. See man page                                                                            |
| ~-user~           | Owned of file. The number is found in e.g. ~/etc/passwd~. See man page                                              |
| ~-group~          | Owning group of the file. The number is found in e.g. ~/etc/group~. See man page                                    |
| ~-perm~           | Files that have a set of permissions set. See man page                                                              |
| ~-ls~             | Almost as if you would run ~ls -l~ on the found file                                                                |
| ~-a~              | Logical /AND/ operator. Prio over ~-o~. Lazy evaluation. This is default if multiple options are provided           |
| ~-o~              | Logical /OR/ operator                                                                                               |
| ~!~               | Logical /NOT/. Put in front of the argument. E.g. ~find . \( -name a.out -a ! -type l \) -print~                    |

*** ~-exec~

Executes the command that follows. ~{}~ will be replaced with what the ~find~
command has found (you're only allowed to use it once). Maybe bash forces you to
escape those characters. The command needs to be terminated with a ~;~ (also
needs to be escaped). If you want to remove the group read permission for files
that have it set you can run the following command:

#+BEGIN_SRC bash
find . -perm -020 -exec chmod g-w {} ';'
#+END_SRC

The ~-exec~ option handles files with spaces in the name. If you want to confirm
that the command is to be executed first you can run find with the ~-ok~ option
instead of ~-exec~.

*** ~-prune~

Always returns true. If the currently investigated file is a directory the ~find~
command will not traverse it. The following command will print all files in a
directory but will not look at any files in any found directories:

#+BEGIN_SRC bash
find * -type f -print -o -type d -prune
#+END_SRC

** Use ~find~ together with the ~xargs~ command

~xargs~ executes it's commands as commands and also accepts arguments from stdin.

#+BEGIN_SRC bash
find / -print | xargs ls -ld
#+END_SRC

This would run ~ls -ld~ on all files in the file system.

To handle files with spaces you can make ~find~ output null terminated strings
and make ~xargs~ handle null terminated strings instead:

#+BEGIN_SRC bash
find / -print0 | xargs -0 ls -ld
#+END_SRC

** Example

#+BEGIN_SRC bash
alias efind='find -L . \( ! -name .git -a ! -name <dir_name> -o -prune \) -type f -print0 | xargs -0 grep --color=auto -in'
#+END_SRC

Here we see why it's important that ~-prune~ returns true. We won't search in
directories called ~.git~ and other directories which we can decide ourselves.
If such a directory is found we will end up in the ~prune~ and the content of
that directory will be ignored.

* tcpdump
** Example

#+BEGIN_SRC bash
tcpdump -c 2000 -s 0 -i eth0 -A -w dump.pcap
#+END_SRC

Catch only ~POST~ requests

#+BEGIN_SRC bash
tcpdump -c 2000 -s 0 -i eth0 -A -w dump.pcap '(tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354)'
#+END_SRC

Catch only from and to tcp port 80

#+BEGIN_SRC bash
tcpdump -c 2000 -s 0 -i eth0 -A -w dump.pcap 'tcp port 80'
#+END_SRC

More information about tcpdum and the filter can be found on the man pages for
[[https://www.tcpdump.org/manpages/tcpdump.1.html][tcpdump]] and [[https://www.tcpdump.org/manpages/pcap-filter.7.html][pcap-filter]].

* Docker
** View stdout from container

#+BEGIN_SRC bash
docker logs <containter_name> -f --tail 10
#e.g.
docker logs wiremock -f --tail 10
#+END_SRC

* ssh
** Attach to ~tmux~ on connect

The following command will when connecting to ~host~ attach to an existing tmux
session. If it doesn't exist it will create a new session and if that doesn't
work it will run bash

#+BEGIN_SRC
ssh user@host -t 'tmux a || tmux || /bin/bash'
#+END_SRC

** Port forwarding

** Reverse port forwarding

** Setting up a socks proxy

** Handling keys
* dnf

[[https://www.rootusers.com/25-useful-dnf-command-examples-for-package-management-in-linux/]]

| Command                                   | Description                                                                                           |
|-------------------------------------------+-------------------------------------------------------------------------------------------------------|
| ~dnf check-update~                        | Check for available updates for packages in enabled repositories                                      |
| ~dnf update package_name~                 | Update a specific package                                                                             |
| ~dnf update~                              | Update all packages                                                                                   |
| ~dnf update -x package_name~              | Update all packages except ~package_name~                                                             |
| ~dnf updateinfo list sec~                 | Install security updates only                                                                         |
| ~dnf install rpm-file.rpm~                | Install a ~.rpm~ file. Will also install dependencies (the ~rpm~ command won't do that)               |
| ~dnf remove package_name~                 | Uninstall package. Packages that depend on ~package_name~ will also be removed (you will be prompted) |
| ~dnf reinstall package_name~              | Reinstall a package. Similar to removing and then installing again                                    |
| ~dnf repolist~                            | View enabled repositories                                                                             |
| ~dnf repolist all~                        | View enabled and disabled repositories                                                                |
| ~dnf list installed~                      | List installed packages                                                                               |
| ~dnf clean all~                           | Clear cached information (the cached information is only used to speed up dnf)                        |
| ~dnf info package_name~                   | Shows detailed information about ~package_name~                                                       |
| ~dnf provides */iscsiadm~                 | Shows which package that provides the command ~iscsiadm~                                              |
| ~dnf provides /etc/httpd/conf/httpd.conf~ | Shows which package that provides a file                                                              |

** Adding a repo

We can specify a new repository by manually editing or creating a new ~.repo~
file in the ~/etc/yum.repos.d~ directory, however we can much more easily create
a persistent repository with the ~dnf config-manager~ command.

#+BEGIN_SRC bash
dnf config-manager --add-repo="https://mirror.aarnet.edu.au/pub/centos/7"
#+END_SRC

Which will create the file ~/etc/yum.repos.d/mirror.aarnet.edu.au_pub_centos_7.repo~

* Disk and partition info
** Mounted file systems

#+BEGIN_SRC bash
df -Th
#+END_SRC

** Display disk information

#+BEGIN_SRC bash
fdisk -l /dev/sda
#+END_SRC

* rmlint

To find duplicate file. The most common usages can be found [[https://rmlint.readthedocs.io/en/latest/tutorial.html][here]].

Note that nothing will be removed. ~rmlint~ will produce a ~rmlint.sh~ and
~rmlint.json~ files. When you execute ~rmlint.sh~ you will be shown some options
before the removal starts.

Find duplicates in the current directory

#+BEGIN_SRC bash
rmlint
#+END_SRC

Find duplicates in the current directory and determine that the first
alphabetical file in a group of conflicts is original.

#+BEGIN_SRC bash
rmlint -S a
#+END_SRC

To use last alpabetical as original you can user

#+BEGIN_SRC bash
rmlint -S A
#+END_SRC

Give multiple dirs to look inside instead of the current dir

#+BEGIN_SRC bash
rmline dir1 dir2
#+END_SRC

By default if there are conflicts found in ~dir1~ and ~dir2~ the file in ~dir1~
is considered to be original

* Exiftool

Read and write meta information in files

** Renaming images

[[https://exiftool.org/exiftool_pod.html#renaming_examples]]

See [[https://superuser.com/a/695050][this]] answer

#+BEGIN_SRC bash
exiftool -r '-FileName<CreateDate' -d '%Y-%m-%d/%H_%M_%S%%-c.%%le' <yourFolder>
#+END_SRC

- ~-r~ is for recursion
- ~'-FileName<CreateDate'~ tells exiftool to rename the file accordingly to its EXIF tag ~CreateDate~
- ~-d '%Y-%m-%d/%H_%M_%S%%-c.%%le'~ tells how to build the filename string from the date source ~CreateDate~

The command will sort all files in the current directory and all sub directories
and place them in directories with the date of the day the file was created and
name the files the time when they were created. They will add numbers after the
time stamp if needed (because of collisions). If an EXIF file is not found (or
not complete?) the file will be left as it were.
