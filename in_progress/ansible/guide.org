* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#links][Links]]
- [[#install][Install]]
- [[#create-docker-target-environment][Create docker target environment]]
  - [[#ubuntu-environment][Ubuntu environment]]
  - [[#fedora-environment][Fedora environment]]
- [[#ad-hoc-commands][Ad-hoc commands]]
- [[#module-documentation][Module documentation]]
- [[#playbooks][Playbooks]]
  - [[#example-1][Example 1]]
  - [[#example-2][Example 2]]
  - [[#example-3][Example 3]]
  - [[#example-4][Example 4]]
- [[#ansible-vault][Ansible vault]]
- [[#config][Config]]
  - [[#ansiblecfg][~ansible.cfg~]]
  - [[#inventory-format][Inventory format]]
#+END_QUOTE

* Links

- https://www.jeffgeerling.com/blog/2020/ansible-101-jeff-geerling-youtube-streaming-series (ansible 2.9)?

* Install

#+BEGIN_SRC bash :noeval
# For fedora
sudo dnf install ansible

# For osx
brew install ansible

# Verify install
ansible --version
#+END_SRC

* Create docker target environment

** Ubuntu environment

#+BEGIN_SRC bash :noeval
cd dockerenv/ubuntu
ssh-keygen -b 4096 -t rsa -f ./id_rsa -N ""
docker build -t ubuntuansibletarget:latest .

# Start env. I use --init because it seems to respect ctrl-c when I want to exit
docker run --rm -p 1022:22 --init ubuntuansibletarget:latest

# Test connection
ssh -o "IdentitiesOnly=yes" -i id_rsa -p 1022 ansibleuser@localhost
#+END_SRC

** Fedora environment

#+BEGIN_SRC bash :noeval
cd dockerenv/fedora
ssh-keygen -b 4096 -t rsa -f ./id_rsa -N ""
docker build -t fedoraansibletarget:latest .

# Start env. I use --init because it seems to respect ctrl-c when I want to exit
docker run --rm -p 2022:22 --init fedoraansibletarget:latest

# Test connection
ssh -o "IdentitiesOnly=yes" -i id_rsa -p 2022 ansibleuser@localhost
#+END_SRC

* Ad-hoc commands

#+BEGIN_SRC bash :noeval
ansible -i inventory example -m ping -u centos
ansible -i inventory example -m ping -u ansibleuser --key-file ../../dockerenv/id_rsa

# If we add the key in the inventory file we can omit the key
ansible -i inventory example -m ping -u ansibleuser

# We can even add the user to the inventory file
ansible -i inventory example -m ping

# With an ansible.cfg file we can point to our inventory file and then
# we can omit the -i option as well
ansible ubuntu-server -m ping

# -m is for module
ansible ubuntu-server -m ping

# default for -m is "command" and -a feeds the module arguments
ansible ubuntu-server -a "ls -la"
ansible ubuntu-server -a "date"

ansible multi -a "hostname"

# Control parallellism with -f (default set to 5)
ansible multi -a "hostname" -f 1

# Return everything that ansible can find about a server. Something called "gather facts"
ansible multi -m setup

# Become a different user with -b/--become (default "sudo")
ansible multi -b -a "whoami"

# Install a package
ansible multi -b -m yum -a "name=ntp state=present"

# Check that the service is runnnig / enable the service
ansible multi -b -m service -a "name=ntpd state=started enabled=yes"

# The --limit command can focus on a single server instead of the whole group
#TODO

# Background tasks -B -P
ansible multi -b -B 3600 -P 0 -a "yum -y update"
# Look at ansible_job_id and results_file field
ansible multi -b -m async_status -a <ansible_job_id>

# This won't work as the command module doesn't handle pipes and redirections etc.
ansible multi -b -a "tail /var/log/messages | grep ansible-command | wc -l"

# Use shell module instead (but should be avoided)
ansible multi -b -m shell -a "tail /var/log/messages | grep ansible-command | wc -l"
#+END_SRC

Ansible is idempotent. If we run it more than one time it will still yield the
same result. The ~command~ module will always run anyway and report a ~CHANGED~
status as ansible don't know what has been done. When using other ansible
modules, ansible can know if something was updated or not.

#+BEGIN_SRC yaml
---
- name: Set up NTP on all servers.
  hosts: all
  become: yes # Run as sudo
  tasks:
    - name: Ensure NTP is installed.
      yum: name=ntp state=present
    - name: Ensure NTP is running.
      services: name= ntpd state=started enabled=yes
#+END_SRC

* Module documentation

#+BEGIN_SRC bash :noeval
ansible-doc <module_name>
#e.g.
ansible-doc service
#+END_SRC

Modules to investigate:

- cron
- git

* Playbooks

Convention to call the main playbook ~main.yml~

** Example 1

#+BEGIN_SRC yaml
---
- name: Install Apache.
  hosts: all

  tasks:
    - name: Install Apache.
      command: yum install --quiet -y httpd httpd-devel
    - name: Copy configuration files.
      command: >
        cp src_file /path/to/target
      command: >
        cp src_file2 /path/to/target2
    - name: Start Apache and configure it to run at boot.
      command: service httpd start
    - command: chkconfig httpd on
#+END_SRC

#+BEGIN_SRC yaml
---
- name: Install Apache.
  hosts: all
  become: true # Can also be put in each task if we don't need to be root during
               # all steps. You can also provide the -b option to the
               # ansible-playbook command

  tasks:
    - name: Install Apache.
      yum:
        name:
          - httpd
          - httpd-devel
        state: present

    - name: Copy configuration files.
      copy:
        src: "{{ item.src }}" # jinja templates
        #src: "{{ item['src'] }}" # Also acceptable
        dst: "{{ item.dest }}"
        owner: root
        group: root
        mode: 0644
      with_items:
        - src: httpd.conf
          dest: /etc/httpd/conf/httpd.conf
        - src: httpd-vhosts.conf
          dest: /etc/httpd/conf/httpd-vhosts.conf

    - name: Make sure Apache is started now and at boot.
      service:
        name: httpd
        state: started
        enabled: true
#+END_SRC

This playbook is idempotent but if any of the copied file is changed later on
the web server won't restart automatically!

#+BEGIN_SRC bash :noeval
ansible-playbook -i inventory main.yml

ansbile-playbook -i inventory multi --limit=192.168.60.5
ansbile-playbook -i inventory multi --limit=!:db

ansible-inventory --list -i inventory
#+END_SRC

** Example 2

#+BEGIN_SRC yaml
---
- hosts: solr
  become: true

  vars_files:
    - vars.yaml

  pre_tasks:
    - name: Update apt cache if needed
      apt: update_cache=true cache_valid_time=3600

  handler:
    # A task can trigger this if it has been updated by using "notify: restart solr"
    # It's not used in the example below though
    - name: restart solr
      services: name=solr state=restarted

  tasks:
    - name: Install Java
      apt: name=openjdk-8.jdk state=present

    - name: Download solr.
      get_url:
        url: "http://fake.url/path/{{ solr_version }}/download/solr-{{ solr_version }}.tgz"
        dest: "{{ download_dir }}/solr-{{ solr_version }}.tgz" # It's a good idea to state the whole path
                                                               # so ansible can check it it already exists
        checksum: "{{ solr_checksum }}"

    - name: Expand solr.
      unarchive:
        src: "{{ download_dir }}/solr-{{ solr_version }}.tgz"
        dest: "{{ download_dir }}"
        remote_src: true # Be default it takes the file on my local machine and copies it to the remove.
                         # This tells ansible that the file is on the remote already
        # Controls idempotece by specifying which files will be created by this action
        creates: "{{ download_dir }}/solr-{{ solr_version }}/README.txt"

    - name: Run Solr insallation script.
      command: >
        {{ download_dir }}/solr-{{ solr_version }}/bin/install_solr.sh
        {{ download_dir }}/solr-{{ solr_version }}.tgz
        -i /opt
        -d /var/solr
        -u solr
        -s solr
        -p 8983
        creates={{ solr_dir }}/bin/solr

    - name: Ensure solr is started and enabled at boot.
      service: name=solr state=started enabled=yes
#+END_SRC

#+BEGIN_SRC yaml
---
download_dir: /tmp
solr_dir: /opt/solr
solr_version: 8.5.0
solr_checksum: sha512:abc123
#+END_SRC

Check if it's valid:

#+BEGIN_SRC bash :noeval
ansible-playbook -i inventory main.yml --syntax-check
#+END_SRC

** Example 3

#+BEGIN_SRC yaml
---
- name: Install Apache.
  hosts: all
  become: true

  vars:
    proxy_vars:
      http_proxy: http://example-proxy:80/
      https_proxy: https://example-proxy:80/

  environment:
    # Set's environment for all tasks
    var0: value0
    var1: value1

  handler:
    # A handler works like a normal task and can also use notify to trigger other handlers
    - name: restart apache
      service:
        name: httpd
        state: restarted
      #notify: restart memcached

  tasks:
    - name: Download a file.
      get_url:
        url: http://ipv4.download.thinkbroadband.com/20MB.zip
        dest: /tmp
      environment:
        http_proxy: http://example-proxy:80/
        https_proxy: https://example-proxy:80/
      # or
      #environment: proxy_vars


    - name: Add an environment variable to the remote user's shell.
      lineinefile:
        dest: "~/.bash_profile"
        regexp: '^ENV_VAR='
        line: 'ENV_VAR=value'
      become: false

    - name: Get the value of an environment variable.
      shell: 'source ~/.bash_profile && echo $ENV_VAR'
      register: foo

    - debug: msg="The variable is {{ foo.stdout }}"

    - name: Install Apache.
      yum:
        name: httpd
        state: present

    - name: Copy test config file.
      copy:
        src: files/test.conf
        dst: /etc/httpd/conf.d/test.conf
      # Run the "restart apache" handler if this task has been run. The handler will be run
      # after all tasks are done
      notify:
        # List of handlers
        - restart apache

    # With this meta task we will run all handler to be run directly instead of in the end
    - name: Make sure handlers are flushed immediately.
      meta: flush_handlers

    - name: Make sure Apache is started now and at boot.
      service:
        name: httpd
        state: started
        enabled: true
#+END_SRC

#+BEGIN_SRC xml
<LocationMatch "^/+$">
  Options -Indexes
  ErrorDocument 403 /.noindex.html
</LocationMatch>

<Directory /var/www/html>
  AllowOverride None
  Require all granted
</Directory>
#+END_SRC

If a task fails before a handler has been run it will not execute. So if you
notify in one step but a later task fails, the handler will not be run in the
end of the playbook. Try it out with the ~fail~ module:

#+BEGIN_SRC yaml
tasks:
  ...
  - fail:
  ...
#+END_SRC

You can overcome this behaviour by running ~ansible-playbook~ with
~--force-handlers~.

** Example 4

#+BEGIN_SRC yaml
---
- name: Install Apache.
  hosts: all
  gather_facts: false # Will not make ansible_os_family available
  become: true

  vars:
    apache_package: httpd
    apache_service: httpd
    apache_config_dir: /etc/apache2/sites-enabled

  handler:
    # A handler works like a normal task and can also use notify to trigger other handlers
    - name: restart apache
      service:
        name: "{{ apache_service }}"
        state: restarted
      #notify: restart memcached

  pre_tasks:
    - debug: var=ansible_os_family

    - name: Load variables files.
      include_vars: "{{ item }}"
      with_first_found:
        - "vars/apache_{{ ansible_os_family }}.yml"
        - "vars/apache_default.yml"

  tasks:
    - name: Install Apache.
      package:
        name: "{{ apache_package }}"
        state: present
      register: foo

    - debug: var=foo
    - debug: var=foo.rc
    - debug: var=foo['rc']

    - name: Copy test config file.
      copy:
        src: files/test.conf
        dst: "{{ apache_config_dir }}/test.conf"
      # Run the "restart apache" handler if this task has been run. The handler will be run
      # after all tasks are done
      notify:
        # List of handlers
        - restart apache

    # With this meta task we will run all handler to be run directly instead of in the end
    - name: Make sure handlers are flushed immediately.
      meta: flush_handlers

    - name: Make sure Apache is started now and at boot.
      service:
        name: "{{ apache_service }}"
        state: started
        enabled: true
#+END_SRC

#+BEGIN_SRC yaml
# vars/apache_default.yml
apache_package: apache2
apache_service: apache2
apache_config_dir: /etc/apache2/sites-enabled
#+END_SRC

#+BEGIN_SRC yaml
# vars/apache_RedHat.yml
apache_package: httpd
apache_service: httpd
apache_config_dir: /etc/httpd/conf.d
#+END_SRC

The ~ansible_os_family~ is set during the ~gather_facts~ step. You can see
everything ansible knows about the system by using the ~setup~ module:

#+BEGIN_SRC bash :noeval
ansible -i inventory centos -m setup
#+END_SRC

* Ansible vault
Encrypt a var file

#+BEGIN_SRC bash :noeval
ansible-vault encrypt vars/api_key.yml
# Provide password
#+END_SRC

Use it:

#+BEGIN_SRC bash :noeval
ansible-playbook main.yml --ask-vault-pass
#+END_SRC

* Config
** ~ansible.cfg~

#+BEGIN_SRC
[ssh_connection]
pipelining = True
#+END_SRC

** Inventory format

#+BEGIN_SRC ini
# Application servers
[app]
192.168.60.4
192.168.60.5

# Database servers
[db]
192.168.60.6

# Group has all the servers
[multi:children]
app
db

[multi:vars]
ansible_ssh_user=ansibleuser
ansible_host=localhost
#ansible_ssh_common_args="-o StrictHostKeyChecking=no"
#+END_SRC
