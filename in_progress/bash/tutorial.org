* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#temp][Temp]]
- [[#special-constructs][Special constructs]]
- [[#parameter-expansion][Parameter expansion]]
- [[#the-if-statement][The ~if~ statement]]
  - [[#different-tests][Different tests]]
- [[#the-for-loop][The ~for~ loop]]
  - [[#examples][Examples]]
- [[#the-while-loop][The ~while~ loop]]
- [[#the-case-expression][The ~case~ expression]]
- [[#the-select-expression][The ~select~ expression]]
- [[#examples-1][Examples]]
  - [[#script-with-curl-having-a-json-body][Script with curl having a json body]]
  - [[#run-script-with-arguments-from-a-file][Run script with arguments from a file]]
  - [[#assigning-multiple-variables-at-once][Assigning multiple variables at once]]
#+END_QUOTE

* Temp

https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/

#+BEGIN_SRC bash :results output :shebang "#!/bin/bash\nset bon jour"
#!/bin/bash

# An example where the input variables are provided in the source block header

echo $1
echo $2
echo $1$2
echo $#
#+END_SRC

* Special constructs

| Construct                   | Description                                                                                                                                                                                                                                                                      |
|-----------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~$VAR~ or ~${VAR}~          | Substitutes the variable ~VAR~ with its value                                                                                                                                                                                                                                    |
| ~'text'~                    | All characters surrounded with the ~'~ will remain as they are. No variable substitution or escaping of characters                                                                                                                                                               |
| ~$'text'~                   | Like the one above but it is allowed to escape characters                                                                                                                                                                                                                        |
| ~”text”~                    | Everything surrouned in ~"~ will not be targeted for word splitting (will be kept as one argument). Variable substitution, arithmetic expansion and command substitutions is allowed. Globs are not allowed                                                                      |
| ~$(command)~ or ~`command`~ | Command substitution. Execute the command. Quotes within the parantheses are independent on parantheses which surrounds the commadn execution expression. So nesting is possible                                                                                                 |
| ~#comment~                  | A comment                                                                                                                                                                                                                                                                        |
| ~;~                         | Command separator if you want multiple commands on same line                                                                                                                                                                                                                     |
| ~\~                         | Escape character                                                                                                                                                                                                                                                                 |
| ~~~                         | Used for you home directory. Can also be used as ~~user~ for the home directory of the user ~user~                                                                                                                                                                               |
| ~{ commands; }~             | Group commands. Usefull if bash expects a command and you don't want to define a function. The last ~;~ seems important (unless you split up all commands on separate lines). Will be run in the same shell. A file redirect will affect all commands in the group. ~{..} >file~ |
| ~(command)~                 | Subshell execution. Run the command in new bash shell. If the command has any side effects (changed directory, changed variables), they won't affect the current shell. Commands can be separated with ~;~                                                                       |
| ~(( expression ))~          | Arithmetic command. Operators such as ~+~, ~-~, ~*~ and ~/~ are allowed. E.g. ~(( a=b+7 ))~ or ~if (( a < b ))~                                                                                                                                                                  |
| ~$(( expression ))~         | Arithmetic substitution. Like the previous but the whole expression will be replaced with the result. E.g. ~echo ”The average is $(( (a+b)/2 ))”~                                                                                                                                |
| ~command &~                 | The command will be executed in the background                                                                                                                                                                                                                                   |

* Parameter expansion

| Syntax                   | Description                                                                                                                                                                                           |
|--------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~${var:-word}~           | If ~var~ is unset or null this will expand to ~word~. Else to the value of ~var~                                                                                                                      |
| ~${var-word}~            | If ~var~ is unset this will expand to ~word~. Else to the value of ~var~                                                                                                                              |
| ~${var:=word}~           | If ~var~ is unset or null ~var~ will get the value ~word~. Then expand to the value of ~var~                                                                                                          |
| ~${var=word}~            | If ~var~ is unset ~var~ will get the value ~word~. Then expand to the value of ~var~                                                                                                                  |
| ~${var:+word}~           | If ~var~ is unset or null this will expand to null, else ~word~                                                                                                                                       |
| ~${var+word}~            | If ~var~ is unset this will expand to null, else ~word~                                                                                                                                               |
| ~${var:?word}~           | If ~var~ is unset or null, the expansion of ~word~ will be printer on stderr (or another message if ~word~ is absent) and the shell with exit with non zero exit code. Otherwise the value of ~var~   |
| ~${var?word}~            | If ~var~ is unset, the expansion of ~word~ will be printer on stderr (or another message if ~word~ is absent) and the shell with exit with non zero exit code. Otherwise the value of ~var~           |
| ~${var:offset:length}~   | Expand up to ~length~ characters of the value starting with ~offset~ (0 indexed). If ~length~ is absent, take everything until the end. If ~offset~ is negative (use parentheses), count from the end |
| ~${#var}~                | Expands to the number of characters of the value of ~var~                                                                                                                                             |
| ~${var#pattern}~         | ~pattern~ (glob) will match from the beginning of ~var~. Will expand to the value of ~var~ with the shortest match removed                                                                            |
| ~${var##pattern}~        | ~pattern~ (glob) will match from the beginning of ~var~. Will expand to the value of ~var~ with the longest match removed                                                                             |
| ~${var%pattern}~         | ~pattern~ (glob) will match from the end of ~var~. Will expand to the value of ~var~ with the shortest match removed                                                                                  |
| ~${var%%pattern}~        | ~pattern~ (glob) will match from the end of ~var~. Will expand to the value of ~var~ with the longest match removed                                                                                   |
| ~${var/pattern/string}~  | The first occurence of ~pattern~ (glob) in the value of ~var~ will be replaced with string                                                                                                            |
| ~${var//pattern/string}~ | All occurences of ~pattern~ (glob) in the value of ~var~ will be replaced with string                                                                                                                 |

#+BEGIN_SRC bash :results output
#!/bin/bash

var="a/b/c/d"
echo "${#var}"
echo "${var#*/}"
echo "${var##*/}"
echo "${var%/*}"
echo "${var%%/*}"
echo "${var/\//|}"
echo "${var//\//|}"

echo "${var2:-${var#*/}}" # Looks like we can nest
#+END_SRC

* The ~if~ statement

The basic form

#+BEGIN_SRC bash :results output
if test # Or a command
then
  # Code here
fi
#+END_SRC

or with ~else~ statements. E.g.

#+BEGIN_SRC bash :results output
if test # Or a command
then
  # Code here
elif test2
then
  # Code here
else
  # Code here
fi
#+END_SRC

** Different tests

See ~man test~ for more information. The spaces between the brackets and the
command is important since ~[~ is the ~test~ command

*** Files tests

| Expression            | Description                                |
|-----------------------+--------------------------------------------|
| ~[ -e file ]~         | True if ~file~ exists                      |
| ~[ -f file ]~         | True if ~file~ is a file (not a directory) |
| ~[ -d file ]~         | True if ~file~ is a directory              |
| ~[ -h file ]~         | True if ~file~ is a symbolic link          |
| ~[ -s file ]~         | True if ~file~ exists and is not empty     |
| ~[ -r file ]~         | True if ~file~ is readable                 |
| ~[ -w file ]~         | True if ~file~ is writable                 |
| ~[ -x file ]~         | True if ~file~ is executable               |
| ~[ -O file ]~         | True if ~file~ is owned by you             |
| ~[ -G file ]~         | True if ~file~ is owned by your group      |
| ~[ file1 -nt file2 ]~ | True if ~file1~ is newer than ~file2~      |
| ~[ file1 -ot file2 ]~ | True if ~file1~ is older than ~file2~      |

*** Numerical tests

| Expression      | Description                                |
|-----------------+--------------------------------------------|
| ~[ n1 -eq n2 ]~ | True if ~n1~ is equal to ~n2~              |
| ~[ n1 -ne n2 ]~ | True if ~n1~ is not equal to ~n2~          |
| ~[ n1 -lt n2 ]~ | True if ~n1~ less than ~n2~                |
| ~[ n1 -gt n2 ]~ | True if ~n1~ greater than ~n2~             |
| ~[ n1 -le n2 ]~ | True if ~n1~ less than or equal to ~n2~    |
| ~[ n1 -ge n2 ]~ | True if ~n1~ greater than or equal to ~n2~ |

*** String test

| Expression         | Description                               |
|--------------------+-------------------------------------------|
| ~[ str ]~          | True if ~str~ is not empty                |
| ~[ str1 = str2 ]~  | True if ~str1~ is equal to ~str2~         |
| ~[ str1 != str2 ]~ | True if ~str1~ is not equal to ~str2~     |
| ~[ -n str ]~       | True if ~str~ is longer than 0 characters |
| ~[ -z str ]~       | True if ~str~ is 0 characters long        |
| ~str1 < str2~      | String comparision                        |
| ~str1 > str2~      | String comparision                        |

When using ~[[~ instead of ~[~ you can use ~=~ or ~==~ to compare word with a
glob expression (the glob expression need to be on the right hand side).
Remember that if you surround the glob expression with quotes it can't be
treated like a glob. You can also compare a string with a regex with the ~=~~
operator like

#+BEGIN_SRC bash :results output
STRING =~ REGEX
#+END_SRC

#+BEGIN_SRC bash :results output
#!/bin/bash

filename="somefile.jpg"
if [[ $filename = *.jpg ]]; then
  echo "$filename is a jpeg"
else
  echo "$filename is not a jpeg"
fi
#+END_SRC

*** Boolean tests

| Expression                   | Description                                                                                                               |
|------------------------------+---------------------------------------------------------------------------------------------------------------------------|
| ~! EXPRESSION~               | True if ~EXPRESSION~ is false                                                                                             |
| ~EXPRESSION1 -o EXPRESSION2~ | Logical /or/. Both ~EXPRESSION1~ and ~EXPRESSION2~ will always be evaluated (no lazy evaluation)                          |
| ~EXPRESSION1 -a EXPRESSION2~ | Logical /and/. Both ~EXPRESSION1~ and ~EXPRESSION2~ will always be evaluated (no lazy evaluation). Has priority over ~-o~ |

The following will only work when we surround a test expression with ~[[~
instead of ~[~

| Expression                   | Description                                                                                                   |
|------------------------------+---------------------------------------------------------------------------------------------------------------|
| ~EXPRESSION1 ¦¦ EXPRESSION2~ | Like ~-o~ but ~EXPRESSION2~ will not be evaluated if ~EXPRESSION1~ evaluates to true                          |
| ~EXPRESSION1 && EXPRESSION2~ | Like ~-a~ but ~EXPRESSION2~ will not be evaluated if ~EXPRESSION1~ evaluates to false. Has priority over ~¦¦~ |
| ~( EXPRESSION )~             | To change priority. The spaces around the parantheses are important                                          |

*** Examples

#+BEGIN_SRC bash :results output
#!/bin/bash

test -e /etc/X11/xorg.conf && echo 'Your Xorg is configured!'
test -n "$HOME" && echo 'Your homedir is set!'
[[ boar != bear ]] && echo "Boars aren't bears."
[[ boar != b?ar ]] && echo "Boars don't look like bears."
[[ $DISPLAY ]] && echo "Your DISPLAY variable is not empty, you probably have Xorg running."
# The line below is commented out since the final result of that one is failing which gives problems for org mode
#[[ ! $DISPLAY ]] && echo "Your DISPLAY variable is not not empty, you probably don't have Xorg running."
#+END_SRC

* The ~for~ loop

Comes in two forms. Like a for each loop:

#+BEGIN_SRC bash :results output
for variable in argument_list
do
  commands
done
#+END_SRC

And a more ~c~ like for loop with a start expression, test expression and next
step expression

#+BEGIN_SRC bash :results output
for ((expression1, expression2, expression3)) #Som i c
do
  commands
done
#+END_SRC

** Examples

#+BEGIN_SRC bash :results output
#!/bin/bash

echo "Linux distributions:"
for distro in mandrake redhat suse debian caldera
do
  echo "$distro"
done
echo "**** Finished *****"
#+END_SRC

#+BEGIN_SRC bash :results output
#!/bin/bash
for filename in `ls` # A glob or brace expression would fit better here
do
  if [ -d "$filename" ]
  then
    echo "Directory: $filename"
  fi
done
#+END_SRC

#+BEGIN_SRC bash :results output
for (( i=10; i > 0; i-- ))
do
  echo "$i empty cans of beer."
done
#+END_SRC

Which could be written as

#+BEGIN_SRC bash :results output
for i in {10..1}
do
  echo "$i empty cans of beer."
done
#+END_SRC

We can also read from a file

#+BEGIN_SRC bash :results output
for var in {a..c}; do
  read -r "$var"
done < <(echo -n 'cat
mouse
dog')
echo "$b"
echo "$c"
#+END_SRC

* The ~while~ loop

The basic form

#+BEGIN_SRC bash :results output
while test # Or a command
do
  # code here
done
#+END_SRC

The keywords ~continue~ and ~break~ both exist for both the ~for~ loop and the
~while~ loop. There is also an ~until~ loop which works exactly like the ~while~
loop but which negates the test result

* The ~case~ expression

An example

#+BEGIN_SRC bash :results output
#!/bin/bash

echo $LANG

case $LANG in
  en*) echo 'Hello!' ;;
  fr*) echo 'Salut!' ;;
  de*) echo 'Guten Tag!' ;;
  nl*) echo 'Hallo!' ;;
  it*) echo 'Ciao!' ;;
  es*) echo 'Hola!' ;;
  C|POSIX) echo 'hello world' ;;
  *)   echo 'I do not speak your language.' ;;
esac
#+END_SRC

Each choice consists of a pattern (or a ~|~ separated list of patterns), a
closing parenthesis, the code that is to be executed and two semicolons that
denotes the ~break~. The code and ~;;~ can be written on multiple lines. It
looks like the ~;;~ needs to be there for each line and that bash doesn't
support fall through.

The example above on multiple lines (removed some options to shorten the code):

#+BEGIN_SRC bash :results output
#!/bin/bash

echo $LANG

case $LANG in
  en*)
    echo 'Hello!'
    ;;
  fr*)
    echo 'Salut!'
    ;;
  C|POSIX)
    echo 'hello world'
    ;;
  *)
    echo 'I do not speak your language.'
    ;;
esac
#+END_SRC

* The ~select~ expression

An example (needs to be run as a script as it depends on input from the user)

#+BEGIN_SRC bash
#/bin/bash

echo "Which of these does not belong in the group?"
select choice in Apples Pears Crisps Lemons Kiwis
do
  if [[ $choice = Crisps ]]
  then
    echo "Correct!  Crisps are not fruit."
    break
  fi
  echo "Errr... no.  Try again."
done
#+END_SRC

The program above wil present the user with a list of all the alternatives
associated with a number. The variable (in this case ~choice~) will be set to
the value the user picked (or empty if the answer was not valid). The menu will
be deplayed until ~break~ is called

* Examples
** Script with curl having a json body

#+BEGIN_SRC bash :results output :shebang "#!/bin/bash\nset input1 input2"
#!/bin/bash

ARG1="$1"
ARG2="$2"

PAYLOAD=$(cat << END_HEREDOC
{
   "field1": "Fixed value",
   "field2": "$ARG1",
   "field3": "$ARG2",
}
END_HEREDOC
)

# The echo should be removed of course
echo curl -X POST --header 'Content-Type: content-type' -d "$PAYLOAD" 'http://host:port/path/to/call'
#+END_SRC

** Run script with arguments from a file

#+BEGIN_SRC bash :results output
while read p; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n "First
second
third")
#+END_SRC

The example above will not process the last row as there is no ~\n~ on that row.
To overcome this problem you can use the following code

#+BEGIN_SRC bash :results output
while read p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading and trailing spaces  
third')
#+END_SRC

Now we have a problem that leading and trailing whitespaces are removed. This is
fixed by setting ~IFS~ to an empty string.

#+BEGIN_SRC bash :results output
while IFS="" read p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

Now the ~\~ on the third line is escaped. Add the ~-r~ option to ~read~ so
backslashes doesn't act as escape charactes

#+BEGIN_SRC bash :results output
while IFS="" read -r p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

Below is an example where we read 3 lines at a time and put each row in the
array variable ~ary~. I also added a helper function just so we can see what
each argument looks like. The newline character is not part of the variable
and all leading and trailing whitespaces are where they are supposed to be.
Also no characters are escaped. It will also read as many lines as possible
even if there is not enough to fill the wanted numbers of lines

#+BEGIN_SRC bash :results output
myfunc () {
  echo $#
  for var in "$@"
  do
    echo -n "\"$var\","
  done
  echo
}

while mapfile -t -n 3 ary && ((${#ary[@]})); do
  myfunc "${ary[@]}"
  printf '%s\n' "${ary[@]}"
  printf -- '--- SNIP ---\n'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

** Assigning multiple variables at once

Can be useful when using ~sed~ but here is a minimal example

#+BEGIN_SRC bash :results output
read VAR1 VAR2 <<< "  One   Two    Three  "

echo "$VAR1"
echo "$VAR2"
#+END_SRC

As you will notice from the example above all the text that doesn't get placed
in its own variable will be placed in the last variable

If you want to change the separator you can update the ~IFS~ variable.

#+BEGIN_SRC bash :results output
IFS=':' read VAR1 VAR2 <<< "  One    Two:   Three   Four"

echo "$VAR1"
echo "$VAR2"
#+END_SRC

