* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#test-code-to-check-python-versions][Test code to check python versions]]
- [[#basics][Basics]]
  - [[#types][Types]]
  - [[#basic-math][Basic math]]
  - [[#comparisons][Comparisons]]
  - [[#strings][Strings]]
  - [[#the-none-object][The ~None~ object]]
  - [[#variables][Variables]]
- [[#lists][Lists]]
  - [[#creating-lists][Creating lists]]
  - [[#add-stuff-to-the-end-of-the-list][Add stuff to the end of the list]]
  - [[#accessing-elements][Accessing elements]]
  - [[#remove-and-return-from-end-with-pop-method][Remove (and return) from end with ~pop~ method]]
  - [[#slicing][Slicing]]
  - [[#make-a-one-layer-deep-copy-using-slices][Make a one layer deep copy using slices]]
  - [[#make-deep-copies-using-deepcopy-function][Make deep copies using ~deepcopy~ function]]
  - [[#removing-an-element-del][Removing an element (~del~)]]
  - [[#remove-first-occurence-of-a-value-remove][Remove first occurence of a value (~remove~)]]
  - [[#inserting-an-element-in-list-insert][Inserting an element in list (~insert~)]]
  - [[#get-index-of-first-occurence-of-a-value-index][Get index of first occurence of a value (~index~)]]
  - [[#concatenating-lists--and-extend][Concatenating lists (~+~ and ~extend~)]]
  - [[#check-for-existence-in][Check for existence (~in~)]]
  - [[#length-of-list-len][Length of list (~len~)]]
  - [[#multidimensional-lists][Multidimensional lists]]
  - [[#comparing-sequences][Comparing sequences]]
  - [[#some-commands-in-actions][Some commands in actions]]
  - [[#repetition-in-lists][Repetition in lists]]
- [[#tuples][Tuples]]
  - [[#creating-tuples][Creating tuples]]
  - [[#accessing-elements-1][Accessing elements]]
  - [[#list-elements-that-also-works-on-tuples][List elements that also works on tuples]]
  - [[#unpacking-tuples-also-lists][Unpacking tuples (also lists)]]
- [[#dictionairies][Dictionairies]]
  - [[#creating-dictionairies][Creating dictionairies]]
  - [[#look-for-existence-of-keys][Look for existence of keys]]
  - [[#look-for-values-using-keys][Look for values (using keys)]]
  - [[#get-all-keys-and-values][Get all keys and values]]
  - [[#addingupdating-value-in-dictionairy][Adding/updating value in dictionairy]]
  - [[#merging-directories-with-the-update-method][Merging directories with the ~update~ method]]
  - [[#add-value-if-it-is-not-present][Add value if it is not present]]
  - [[#remove-keyvalue-pair-using-key][Remove key/value pair using key]]
  - [[#the-pop-method][The ~pop()~ method]]
  - [[#the-popitem-method][The ~popitem()~ method]]
  - [[#create-a-shallow-copy-using-the-copy-method][Create a shallow copy using the ~copy~ method]]
  - [[#clearing-directories][Clearing directories]]
  - [[#creating-a-dictionairy-from-a-list][Creating a dictionairy from a list]]
- [[#sets][Sets]]
  - [[#set-operations][Set operations]]
  - [[#add-objects-to-set][Add objects to set]]
  - [[#remove-elements][Remove elements]]
  - [[#clear-a-set][Clear a set]]
  - [[#the-pop-method-1][The ~pop~ method]]
  - [[#make-a-shallow-copy][Make a shallow copy]]
  - [[#frozen-sets][Frozen sets]]
- [[#control-flows][Control flows]]
  - [[#the-if-statement][The ~if~ statement]]
  - [[#the-for-statement][The ~for~ statement]]
  - [[#the-while-statement][The ~while~ statement]]
  - [[#the-range-function][The ~range()~ function]]
  - [[#the-pass-statement][The ~pass~ statement]]
- [[#functions][Functions]]
  - [[#variable-number-of-arguments][Variable number of arguments]]
  - [[#return-multiple-values][Return multiple values]]
  - [[#nested-functions][Nested functions]]
  - [[#functions-returning-functions][Functions returning functions]]
  - [[#lambda-expressions][Lambda Expressions]]
  - [[#documentation-string-doc-string][Documentation string (doc string)]]
  - [[#function-annotations][Function annotations]]
- [[#the-map-filter-and-reduce-functions][The ~map~, ~filter~ and ~reduce~ functions]]
  - [[#the-map-function][The ~map~ function]]
  - [[#the-filter-function][The ~filter~ function]]
  - [[#the-reduce-function][The ~reduce~ function]]
- [[#data-structures][Data structures]]
  - [[#list-comprehensions][List comprehensions]]
  - [[#nested-list-comprehensions][Nested list comprehensions]]
  - [[#looping-techniques][Looping techniques]]
- [[#modules][Modules]]
  - [[#more-on-modules][More on modules]]
  - [[#executing-a-module-as-a-script][Executing a module as a script]]
  - [[#module-search-path][Module search path]]
  - [[#see-the-content-of-a-module-with-the-dir-function][See the content of a module with the ~dir~ function]]
  - [[#packages][Packages]]
- [[#inputoutput][Input/output]]
  - [[#the-print-function][The ~print~ function]]
  - [[#formatting][Formatting]]
  - [[#reading-and-writing-files][Reading and writing files]]
  - [[#reading-from-a-url][Reading from a url]]
  - [[#input][Input]]
- [[#scopes][Scopes]]
  - [[#examples][Examples]]
- [[#classes][Classes]]
  - [[#class-object][Class object]]
  - [[#more-about-attribute-references][More about attribute references]]
  - [[#method-objects][Method Objects]]
  - [[#class-and-instance-variables][Class and instance variables]]
  - [[#random-remarks][Random remarks]]
  - [[#inheritence][Inheritence]]
  - [[#private-variables][Private Variables]]
  - [[#struct-like-classes][Struct like classes]]
  - [[#iterators][Iterators]]
  - [[#generators][Generators]]
- [[#errors-and-exception][Errors and Exception]]
  - [[#handling-exceptions][Handling exceptions]]
  - [[#raising-exceptions][Raising exceptions]]
  - [[#define-your-own-exception][Define your own exception]]
  - [[#clean-up-using-finally-clause][Clean up using ~finally~ clause]]
  - [[#predefined-clean-up-actions][Predefined clean-up actions]]
  - [[#links][Links]]
- [[#decorators][Decorators]]
  - [[#function-decorators][Function decorators]]
- [[#other][Other]]
  - [[#regular-expressions][Regular expressions]]
  - [[#execute-scripts-in-linux][Execute scripts in linux]]
- [[#example-programs][Example programs]]
  - [[#read-command-line-arguments][Read command line arguments]]
  - [[#print-to-stderr][Print to stderr]]
- [[#the-pip-command][The ~pip~ command]]
- [[#things-that-maybe-isnt-included-in-the-tutorial][Things that maybe isn't included in the tutorial]]
  - [[#methods][Methods]]
- [[#links-1][Links]]
- [[#cheat-sheet][Cheat sheet]]
- [[#code-to-inspect][Code to inspect]]
- [[#links-to-read][Links to read]]
#+END_QUOTE

* Test code to check python versions

The ~python~ argument in the code block header accepts a path to your python
executable. I have both =python2= and =python3= in my path so that's why I can
write only the name of the executable. Evaluate the code by placing the cursor
inside the code block and press ~C-c C-c~

The following code block evaluates python2 code:

#+BEGIN_SRC python :python python2 :results output
import sys
print(sys.version)
#+END_SRC

And this code block evaluates python3 code:

#+BEGIN_SRC python :python python3 :results output
import sys
print(sys.version)
#+END_SRC

* Basics
** Types

#+BEGIN_SRC python :python python3 :results output
print("Integer:", 3)
print("Float:", 3.0)
print("Float:", 3.1)
#+END_SRC

** Basic math

Mathematical operators

#+BEGIN_SRC python :python python3 :results output
print(1 + 2)
print(10 - 4)
print(4 * 5)
print(7 / 3)
print(10 / 2, "(The result of division is always a float)")
#+END_SRC

Integer division

#+BEGIN_SRC python :python python3 :results output
print(7 // 3)
print(7.0 // 2.9 , "(Also works on floats)")
print(10.0 // 3.3)
print(10.0 // 3.4)
print(-7 // 3, "(The result is always rounded down)")
print(-7.0 // 3.0)
#+END_SRC

Modulo

#+BEGIN_SRC python :python python3 :results output
print(7 % 3, "(Smallest positive integer)")
print(-7 % 3)
#+END_SRC

Exponentiation

#+BEGIN_SRC python :python python3 :results output
print(2 ** 4)
print(2.0 ** 4)
print(2 ** 4.0)
print(2.0 ** 4.0)
#+END_SRC

Change precedence

#+BEGIN_SRC python :python python3 :results output
print(1 + 2 * 3)
print((1 + 2) * 3)
#+END_SRC

** Comparisons

Boolean values (note capitalization)

#+BEGIN_SRC python :python python3 :results output
print(True)
print(False)
#+END_SRC

Negation

#+BEGIN_SRC python :python python3 :results output
print(not True)
print(not False)
#+END_SRC

Boolean operators (~and~ and ~or~)

#+BEGIN_SRC python :python python3 :results output
print(True and False)
print(True or False)
#+END_SRC

Boolean operators with integers

#+BEGIN_SRC python :python python3 :results output
print(0 and 2)    # 0
print(-5 or 0)    # -5
print(0 == False) # True
print(2 == True)  # False
print(1 == True)  # True
#+END_SRC

Equality symbol (~==~)

#+BEGIN_SRC python :python python3 :results output
print(1 == 1)
print(2 == 1)
#+END_SRC

Inequality operator (~!=~)

#+BEGIN_SRC python :python python3 :results output
print(1 != 1)
print(2 != 1)
#+END_SRC

Size comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 10)
print(1 > 10)
print(2 <= 2)
print(2 >= 2)
#+END_SRC

Chained comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 2 < 3)
print(2 < 3 < 2)
print(1 < 2 == 2)
print(1 < 2 == 1)
#+END_SRC

Lazy evaluation

#+BEGIN_SRC python :python python3 :results output
print(False and (5 / 0))
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
print(5 / 0) # Run as a comparison. This one fails
#+END_SRC

When not comparing booleans the result of a comparison will be equal to the last
evaluated expression

#+BEGIN_SRC python :python python3 :results output
myVar = '' or 'Second string' or 'Third string'
print(myVar)
myVar = '' or 1 or 'Third string'
print(myVar)
#+END_SRC

What different types evaluate to

#+BEGIN_SRC python :python python3 :results output
print(bool(0))
print(bool(0.0))
print(bool(""))
print(bool([])) # Empty list
print(bool({})) # Empty dictionairy
print(bool(())) # Empty tuple
print(bool(None))
print("Other values evaluate to True (this doesn't mean that they are equal to True as seen earlier)")
#+END_SRC

Equality (~==~) vs ~is~ operator
~is~ checks if two variables refer to the same object, but ~==~ checks if the
objects pointed to have the same values

#+BEGIN_SRC python :python python3 :results output
a = [1, 2, 3, 4]         # Point a at a new list, [1, 2, 3, 4]
b = a                    # Point b at what a is pointing to
print("b is a:", b is a) # => True, a and b refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
b = [1, 2, 3, 4]         # Point b at a new list, [1, 2, 3, 4]
print("b is a:", b is a) # => False, a and b do not refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
#+END_SRC

*** The ~id~ function

Every instance have an identity (an integer which is unique within the script or
program). You can get the id by using the ~id~ function

#+BEGIN_SRC python :python python3 :results output
x = [1, 2, 3, 4]
y = x
print(id(x))
print(id(y))
y = [1, 2, 3, 4] # Another instance of an equal object
print(id(y))
#+END_SRC

** Strings

Strings are surrounded with ~"~ or ~'~

#+BEGIN_SRC python :python python3 :results output
print("This is a string.")
print('This is also a string.')
#+END_SRC

Concatenation

#+BEGIN_SRC python :python python3 :results output
print("Hello " + "world!")
print("Hello " "world!") # Prefered way

# Put strings inside brackets to concatenate and put in variable (doesn't work with variables)
myString = ("Hello "
            "world!")
print(myString)
#+END_SRC

Treat it as a list of characters

#+BEGIN_SRC python :python python3 :results output
print("This is a string"[0])
#+END_SRC

Find the length of the string

#+BEGIN_SRC python :python python3 :results output
print(len("This is a string"))
#+END_SRC

Formatting string

#+BEGIN_SRC python :python python3 :results output
print("{} can be {}".format("Strings", "interpolated"))
print("{0} be nimble, {0} be quick, {0} jump over the {1}".format("Jack", "candle stick"))
print("{name} wants to eat {food}".format(name="Bob", food="lasagna"))
#+END_SRC

Raw strings

#+BEGIN_SRC python :python python3 :results output
print('\'Hello\nWorld\'')
print(r'\'Hello\nWorld\'') # print it exactly as it is written
#+END_SRC

Multi line string

#+BEGIN_SRC python :python python3 :results output
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
print("---")
# Add a '\' at the end and no trailing newline will be added
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to\
""")
print("---")
#+END_SRC

Repeating strings

#+BEGIN_SRC python :python python3 :results output
print("na " * 8 + "BATMAN")
#+END_SRC

Joining strings in a [[*Lists][list]] with a separator

#+BEGIN_SRC python :python python3 :results output
my_list = ["This", "is", "a", "test"]
print(" ".join(my_list))
print("!".join(my_list))
print("<separator>".join(my_list))
#+END_SRC

** The ~None~ object

#+BEGIN_SRC python :python python3 :results output
print(None)
#+END_SRC

Compare with ~is~ operator instead of ~==~

#+BEGIN_SRC python :python python3 :results output
print('"etc" is None:', "etc" is None)
print('None is None:', None is None)
print('None == None', None == None)
#+END_SRC

** Variables

No need to declare variables before assigning to them. Convention is to use
lower_case_with_underscores

#+BEGIN_SRC python :python python3 :results output
some_var = 5
print("some_var:", some_var)
#+END_SRC

Accessing a previously unassigned variable raises an exception

#+BEGIN_SRC python :python python3 :results output
# The following error is intentional
some_unknown_var  # Raises a NameError
#+END_SRC

* Lists

Lists are mutable (tuples are not)

** Creating lists

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty list
li = []
print("li:", li)
# Or a prefilled list
prefilled_li = [4, 5, 6]
print("prefilled_li:", prefilled_li)
print("type([]):    ", type([]))
print("type([1,2]): ", type([1,2]))
#+END_SRC

** Add stuff to the end of the list

#+BEGIN_SRC python :python python3 :results output
li = []
print("li:", li)
li.append(1) # We have to do it in a separate step since this function only returns None (run help(list.append))
print("li:", li)
li.append(2)
print("li:", li)
li.append(4)
print("li:", li)
li.append(3)
print("li:", li)
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("li:       ", li)
print("li[0]:    ", li[0])
print("li[1]:    ", li[1])
# Negative index access elements counted from the end
print("li[-1]:   ", li[-1])
print("li[-2]:   ", li[-2])
print("li[2] = 5:")
li[2] = 5
print("li:       ", li)
#+END_SRC

** Remove (and return) from end with ~pop~ method

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
popped_value = li.pop()
print("popped_value:", popped_value)
print("li:", li)
# put it back with li.append
li.append(popped_value)
print("li:", li)
#+END_SRC

You can also pop a value with an index

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
popped_value = li.pop(2)
print("popped_value:", popped_value)
print("li:", li)
# put it back with li.append
li.append(popped_value)
print("li:", li)
#+END_SRC

So ~pop()~ without an argument is the same as ~pop(-1)~

** Slicing

Slicing is performed with ~li[start:end(:step)]~.

We will use a string as an example here. After all, a string is nothing other
than a tuple of characters. In the table below the dots are not included in the
string "Python" but will just point out the different "stops" of a index.

|  . | P |  . | y |  . | t |  . | h |  . | o |  . | n | . |
|----+---+----+---+----+---+----+---+----+---+----+---+---|
|  0 |   |  1 |   |  2 |   |  3 |   |  4 |   |  5 |   | 6 |
| -6 |   | -5 |   | -4 |   | -3 |   | -2 |   | -1 |   |   |

#+BEGIN_SRC python :python python3 :results output
pString = "Python"
print("pString[:] ", pString[:])
print("pString[3:]", pString[3:])
print("pString[:3]", pString[:3])
print("pString[1:5]", pString[1:5])
print("pString[::2]", pString[::2])
print("pString[1::2]", pString[1::2])
print("pString[:4:2]", pString[:4:2])
print("pString[1:5:3]", pString[1:5:3])
# And negative values
print("pString[-6:-1]", pString[-6:-1])
print("pString[::-1]", pString[::-1])
print("pString[-1:-6:-1]", pString[-1:-6:-1]) # Note that the start value now is
                                              # larger than end value
#+END_SRC

You can also update a list using slices

#+BEGIN_SRC python :python python3 :results output
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
print("letters:", letters)
letters[2:5] = ['C', 'D', 'E']
print("letters:", letters)
letters[2:5] = [] # The length can be changed
print("letters:", letters)
#+END_SRC

** Make a one layer deep copy using slices

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = li[:]
print("li: ", li)
print("li2:", li2)
print("li == li2:", li == li2) # Check for equality
print("li is li2:", li is li2) # Check if they are the same object
#+END_SRC

** Make deep copies using ~deepcopy~ function

If you have nested lists and want to make copies of each layer the following
code will achieve that

#+BEGIN_SRC python :python python3 :results output
from copy import deepcopy

lst = ['a','b',['ab','ba']]
shallowCopyLst = lst[:]
deepCopyLst = deepcopy(lst)
print("lst[2] id:           ", id(lst[2]))
print("shallowCopyLst[2] id:", id(shallowCopyLst[2])) # Same object as original list
print("deepCopyLst[2] id:   ", id(deepCopyLst[2]))
#+END_SRC

** Removing an element (~del~)

Removes an element given an index or slice

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 4, 5, 6, 7, 8]
print("li:", li)
print("li[2]:", li[2])
del li[2]
print("li:", li)
print("li[2]:", li[2])
del li[2::2]
print("li:", li)
# Remove the whole list
del li
# The following line will result in an error
#print("li:", li)
#+END_SRC

** Remove first occurence of a value (~remove~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.remove(2) # Calling this twice would result in a ValueError exception since 2 is not in the list
print("li:", li)
#+END_SRC

Only the first occurence would be removed

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 2, 3]
li.remove(2)
print("li:", li)
#+END_SRC

** Inserting an element in list (~insert~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.insert(1, 5) # At index 1 insert 5
print("li:", li)
#+END_SRC

** Get index of first occurence of a value (~index~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 2]
print("li.index(2):", li.index(2)) # A non existing value would raise an ValueError exception
#+END_SRC

You can also use a second argument to tell where to start searching from

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 2]
print("li.index(2, 2):", li.index(2, 2))
#+END_SRC

If you use a third argument this is where the search will stop

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 2]
print("li.index(2, 2, 4):", li.index(2, 2, 4)) # Will rase a ValueError exception
#+END_SRC

** Concatenating lists (~+~ and ~extend~)

The following code will create a new list:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
print("li + li2:", li + li2) # The lists are not affected
print("li:      ", li)
print("li2:     ", li2)
#+END_SRC

This code will update list ~li~:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
li.extend(li2) # Now li has changed
print("li: ", li)
print("li2:", li2)
#+END_SRC

If you would use ~append~ instead you would end up with a nested list

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
li.append(li2)
print("li: ", li)
#+END_SRC

Note that ~+=~ behaves more like ~extend~ than ~+~ as it is actually updating
the list and not creating a new one. See the following two examples

#+BEGIN_SRC python :python python3 :results output
def no_side_effects(cities):
    print(cities)
    cities = cities + ["Birmingham", "Bradford"]
    print(cities)

locations = ["London", "Leeds", "Glasgow", "Sheffield"]
no_side_effects(locations)
print(locations) # Still orignal list
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
def side_effects(cities):
    print(cities)
    cities += ["Birmingham", "Bradford"]
    print(cities)

locations = ["London", "Leeds", "Glasgow", "Sheffield"]
side_effects(locations)
print(locations) # Original list is updated
#+END_SRC

We can instead pass a shallow copy of our list

#+BEGIN_SRC python :python python3 :results output
def side_effects(cities):
    print(cities)
    cities += ["Birmingham", "Bradford"]
    print(cities)

locations = ["London", "Leeds", "Glasgow", "Sheffield"]
side_effects(locations[:])
print(locations) # Original list is not updated
#+END_SRC

** Check for existence (~in~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("1 in li:", 1 in li)
print("7 in li:", 7 in li)
print("7 not in li:", 7 not in li)
#+END_SRC

** Length of list (~len~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("len(li): ", len(li))
#+END_SRC

** Multidimensional lists

#+BEGIN_SRC python :python python3 :results output
matrix = [[1, 2, 3],['a', 'b', 'c']]
print(matrix[0][1]) # 2
#+END_SRC

** Comparing sequences

It will compare each object from left to right

#+BEGIN_SRC python :python python3 :results output
print((1, 2, 3)    < (1, 2, 4))
print([1, 2, 3]    < [1, 2, 4])
print('ABC' < 'C'  < 'Pascal' < 'Python')
print((1, 2, 3, 4) < (1, 2, 4)) # The size doesn't matter. 3 is less than 4
print((1, 2)       < (1, 2, -1)) # One list was a subsequence of the other.
                                 # The shorter is the smaller one
print((1, 2, 3) == (1.0, 2.0, 3.0)) # Different types can be compared if they have appropriate compare methods
print((1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)) # An element is a sequence which will be compared
#+END_SRC

** Some commands in actions

#+BEGIN_SRC python :python python3 :results output
fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
print("fruits:                   ", fruits)
print("fruits.count('apple'):    ", fruits.count('apple'))
print("fruits.count('tangerine'):", fruits.count('tangerine'))
print("fruits.index('banana'):   ", fruits.index('banana'))
# Find next banana starting a position 4
print("fruits.index('banana', 4):", fruits.index('banana', 4))
print("fruits.reverse()")
fruits.reverse()
print("fruits:                   ", fruits)
print("fruits.append('grape')")
fruits.append('grape')
print("fruits:                   ", fruits)
print("fruits.sort()")
fruits.sort()
print("fruits:                   ", fruits)
print("fruits.pop():             ", fruits.pop())
print("fruits:                   ", fruits)
#+END_SRC

** Repetition in lists

As with strings you can use ~*~ for repetition. E.g.

#+BEGIN_SRC python :python python3 :results output
print(3 * ["a","b","c"])
#+END_SRC

But note that it only creates multiple references to the object. See what
happens if we assign a value to a repeated nested list

#+BEGIN_SRC python :python python3 :results output
x = ["a","b","c"]
y = [x] * 4
print(y)
y[0][0] = "p"
print(y)
#+END_SRC

All letter /a/ was replaced with /p/ since we just have 4 references to the list
~x~.

* Tuples

Tuples are immutable. The mutable equivalent would be list

** Creating tuples

#+BEGIN_SRC python :python python3 :results output
print("tup = (1, 2, 3)")
tup = (1, 2, 3)
print("tup:       ", tup)
print("A one element long tuple needs comma after the last element:")
print("type((1)): ", type((1)))
print("type((1,)):", type((1,)))
print("type(()):  ", type(()))
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("tup[0]:", tup[0])
# tup[0] = 3 is not allowed (tuples are immutable) and would raise a TypeError exception
#+END_SRC

** List elements that also works on tuples

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("len(tup):       ", len(tup))
print("tup + (4, 5, 6):", tup + (4, 5, 6))
print("tup[:2]:        ", tup[:2])
print("2 in tup:       ", 2 in tup)
#+END_SRC

** Unpacking tuples (also lists)

The number of variables and values must match

#+BEGIN_SRC python :python python3 :results output
a, b, c = (1, 2, 3)
print("a:", a)
print("b:", b)
print("c:", c)
#+END_SRC

You can also use the asterisk to capture several variables

#+BEGIN_SRC python :python python3 :results output
a, *b, c = (1, 2, 3, 4) # Only one variable may use the asterisk
print("a:", a)
print("b:", b) # This will be a list
print("c:", c)
#+END_SRC

The paranthesis are not needed. Tuples are created by default

#+BEGIN_SRC python :python python3 :results output
d, e, f = 4, 5, 6
print("d:", d)
print("e:", e)
print("f:", f)
#+END_SRC

This makes it very easy to swap two values

#+BEGIN_SRC python :python python3 :results output
d = 4
e = 5
e, d = d, e
print("d:", d)
print("e:", e)
#+END_SRC

* Dictionairies
** Creating dictionairies

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty dictionairy
empty_dict = {}
print("empty_dict:       ", empty_dict)

# Or a prefilled dictionairy
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:      ", filled_dict)
print("type(filled_dict):", type(filled_dict))
#+END_SRC

The keys of the dictionairy needs to be of an immutable type (such as int,
float, string or tuple). This is because python needs to calculate hash values
for lookups. Values can be of any type.

#+BEGIN_SRC python :python python3 :results output
valid_dict = {(1,2,3):[1,2,3]}
print("valid_dict:", valid_dict)
# You are not limited to one type of key/value
other_valid_dict = {1: 2, "three": "four"}
print("other_valid_dict:", other_valid_dict)
#+END_SRC

A dictionairy can also be created with the constructor. It accepts a sequence of
key-value pairs

#+BEGIN_SRC python :python python3 :results output
myDict = dict([("one", 1), ("two", 2), ("three", 3)])
print(myDict)
#+END_SRC

** Look for existence of keys

The ~in~ keyword will search for keys in the dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('"one" in filled_dict:', "one" in filled_dict)
print("1 in filled_dict:    ", 1 in filled_dict)
#+END_SRC

** Look for values (using keys)

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict["one"]:        ', filled_dict["one"])
# Looking up a non-existing key raises and KeyError. Use get instead
print('filled_dict.get("one"):    ', filled_dict.get("one"))
print('filled_dict.get("four"):   ', filled_dict.get("four")) # Not found so returns <None>
print('filled_dict.get("one", 4): ', filled_dict.get("one", 4))
print('filled_dict.get("four", 4):', filled_dict.get("four", 4)) # Not found so returns default value 4
#+END_SRC

** Get all keys and values

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict.keys():        ", filled_dict.keys())       # The order is non predictable
print("list(filled_dict.keys()):  ", list(filled_dict.keys())) # To get the result as a list
print("filled_dict.values():      ", filled_dict.values())     # The indexes seems to match for keys and values
print("list(filled_dict.values()):", list(filled_dict.values()))
#+END_SRC

You can also extract all items as key-value pairs

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict.items():      ", filled_dict.items())
print("list(filled_dict.items()):", list(filled_dict.items()))
#+END_SRC

#+RESULTS:
: filled_dict.items():       dict_items([('three', 3), ('two', 2), ('one', 1)])
: list(filled_dict.items()): [('three', 3), ('two', 2), ('one', 1)]

** Adding/updating value in dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
filled_dict["four"] = 5
print("filled_dict:", filled_dict)
filled_dict["one"] = 2
print("filled_dict:", filled_dict)
#+END_SRC

** Merging directories with the ~update~ method

The ~update~ method will add all entries from the second dictionairy to the
first list and overwrite any values if we have conflicting keys

#+BEGIN_SRC python :python python3 :results output
fst_dict = {"one": 1, "two": 2, "three": 3}
snd_dict = {"three": 33, "four": 44, "five": 55}

fst_dict.update(snd_dict)
print("fst_dict:", fst_dict) # Note that the "three" entry now has 33 as value
print("snd_dict:", snd_dict)
#+END_SRC

** Add value if it is not present

The method ~setdefault()~ is similar to ~get()~, but will set
~dict[key]=default~ if key is not already in dict.

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict.setdefault("five", 5):', filled_dict.setdefault("five", 5))
print("filled_dict:", filled_dict)
print('filled_dict.setdefault("five", 6):', filled_dict.setdefault("five", 6)) # Will still be 5
print("filled_dict:", filled_dict) # This list hasn't changed
#+END_SRC

** Remove key/value pair using key

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
del filled_dict["one"]
print("filled_dict:", filled_dict)
#+END_SRC

** The ~pop()~ method

When running ~dict.pop(key)~, python will remove the entry with key ~k~ and
return it

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
popped = filled_dict.pop("two")
print("popped:", popped)
print("filled_dict:", filled_dict)
#+END_SRC

If the item doesn't exist a ~KeyError~ exception will be raised. We can prevent
this by also providing a default values as a second argument

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
popped = filled_dict.pop("four", 4)
print("popped:", popped)
print("filled_dict:", filled_dict)
#+END_SRC

** The ~popitem()~ method

The ~popitem()~ method will return an arbitrary key-value tuple and remove that
entry from the dictinairy. If the dictionairy is empty a ~KeyError~ exception
will be raised. The example below may have different results in different runs

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
popped = filled_dict.popitem()
print("popped:", popped)
print("filled_dict:", filled_dict)
#+END_SRC

** Create a shallow copy using the ~copy~ method

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
copy_dict = filled_dict.copy()
print("filled_dict:", filled_dict, "id:", id(filled_dict))
print("copy_dict:  ", copy_dict,   "id:", id(copy_dict))
#+END_SRC

** Clearing directories

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
filled_dict.clear()
print("filled_dict:", filled_dict)
#+END_SRC

** Creating a dictionairy from a list

You can easily create a dictionairy from a list of tuples

#+BEGIN_SRC python :python python3 :results output
my_list = [('three', 3), ('two', 2), ('one', 1)]
my_dict = dict(my_list)
print(my_dict)
#+END_SRC

You can also create a dictionairy from two lists (one containing the keys and
the other containing the values)

#+BEGIN_SRC python :python python3 :results output
key_list = ["one", "two", "three"]
value_list = [1, 2, 3]

my_dict = dict(zip(key_list, value_list)) # zip is explained later
print(my_dict)
#+END_SRC

* Sets

A ~set~ is an unordered collection with no duplicate elements. Supports typical
set operations like union, intersection, difference, and symmetric difference.

Uses curly braces, just like dictionairies but with single values instead. To
create an empty set you will have to use ~set()~ as ~{}~ creates an empty
directory

#+BEGIN_SRC python :python python3 :results output
empty = set()
print(empty)
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)
print('orange' in basket)
print('crabgrass' in basket)
#+END_SRC

Note that all objects in a set needs to be immutable

** Set operations

Set operations. String is an iterable so when giving a string to the ~set~
constructor it will build a set of the characters

*** Difference

Either use the ~difference~ method or ~-~ operator

#+BEGIN_SRC python :python python3 :results output
a = set('abracadabra')
b = set('alacazam')

print(a - b)
print(a.difference(b))
#+END_SRC

*** Union

Either use the ~union~ method or the ~|~ operator

#+BEGIN_SRC python :python python3 :results output
a = set('abracadabra')
b = set('alacazam')

print(a | b)
print(a.union(b))
#+END_SRC

*** Intersection

Either use the ~intersection~ method or the ~&~ operator

#+BEGIN_SRC python :python python3 :results output
a = set('abracadabra')
b = set('alacazam')

print(a & b)
print(a.intersection(b))
#+END_SRC

*** Symmetric difference

That is the opposite of ~intersection~

#+BEGIN_SRC python :python python3 :results output
a = set('abracadabra')
b = set('alacazam')

print(a ^ b)
#+END_SRC

*** Check if disjoint

The ~isdisjoint~ method will return ~True~ if the two lists have no common
elements

#+BEGIN_SRC python :python python3 :results output
set0 = {'a', 'b', 'c'}
set1 = {'c', 'd', 'e'}
set2 = {'d', 'e', 'f'}

print(set0.isdisjoint(set1))
print(set0.isdisjoint(set2))
#+END_SRC

** Add objects to set

#+BEGIN_SRC python :python python3 :results output
basket = {'apple', 'orange'}
print(basket)
basket.add('banana')
print(basket)
#+END_SRC

** Remove elements

You can use either the ~discard~ method or the ~remove~ method to remove an
element. If the element doesn't exist the ~remove~ method will raise a
~KeyError~ exception while ~discard~ won't do anything

#+BEGIN_SRC python :python python3 :results output
basket = {'apple', 'pear', 'orange', 'banana'}
print(basket)
basket.discard('pear')
print(basket)
basket.discard('pear')
print(basket)
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
basket = {'apple', 'pear', 'orange', 'banana'}
print(basket)
basket.remove('pear')
print(basket)
#basket.remove('pear') # Will fail
#+END_SRC

** Clear a set

#+BEGIN_SRC python :python python3 :results output
basket = {'apple', 'orange'}
print(basket)
basket.clear()
print(basket)
#+END_SRC

** The ~pop~ method

~pop~ removes and returns an arbitrary element from the set. If the set is empty
a ~KeyError~ exception will be raised

#+BEGIN_SRC python :python python3 :results output
basket = {'apple', 'pear', 'orange', 'banana'}
popped = basket.pop()
print(popped)
print(basket)
#+END_SRC

** Make a shallow copy

#+BEGIN_SRC python :python python3 :results output
basket = {'apple', 'orange'}
basket_copy = basket.copy()
basket.clear()
print(basket)
print(basket_copy)
#+END_SRC

** Frozen sets

As you have seen, sets are mutable. If you want an immutable set you can use the
~frozenset~ instead

#+BEGIN_SRC python :python python3 :results output
basket = frozenset(['apple', 'orange'])
print(basket)
#basket.add('banana') # will fail
#+END_SRC

* Control flows
** The ~if~ statement

#+BEGIN_SRC python :python python3 :results output :preamble def input(x): return 2
# In the header of this block we have redefined input as we can't run this interactively
x = int(input("Please enter an integer: "))

if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
#+END_SRC

*** Ternary operator

Python also supports a ternary operator

#+BEGIN_SRC python :python python3 :results output
a = 1
b = 2
cond = True

c = a if cond else b
print (c)

cond = False
c = a if cond else b
print (c)
#+END_SRC

** The ~for~ statement

Iterates over any sequence and not only an arithmetic progression

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
#+END_SRC

Note that the variable ~w~ will still be set after the loop finishes

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))

print("After loop:", w)
#+END_SRC

When iterating over a dictionairy you will iterate over the keys

#+BEGIN_SRC python :python python3 :results output
my_dict = {"one": 1, "two": 2, "three": 3}
for k in my_dict:
    print(k)
#+END_SRC

You can of course iterate over values and pair by calling the ~values~ and
~items~ methods.

Also supports ~else~ when it is exiting the ~for~ loop

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
else:
    print("exit")
#+END_SRC

~continue~ and ~break~ works as expected. If break is called the ~else~ clause
won't be called if it exists

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        continue
    print(w, len(w))
else:
    print("exit")
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        break
    print(w, len(w))
else:
    print("exit")
#+END_SRC

If you need the index of the elements you can use ~len~ in combination with
[[*The ~range()~ function][the ~range()~ function]]

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for index in range(len(words)):
    print(index, words[index])
#+END_SRC

Or even better, use ~enumerate~

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']

for counter, value in enumerate(words):
    print(counter, value)
#+END_SRC

You can also provide ~enumerate~ with a value of the index it should start
counting from

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']

for counter, value in enumerate(words, 5):
    print(counter, value)
#+END_SRC

*** An example

#+BEGIN_SRC python :python python3 :results output
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
#+END_SRC

** The ~while~ statement

Works as expected

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
#+END_SRC

~continue~ and ~break~ works the same as with ~for~ loops

#+BEGIN_SRC python :python python3 :results output
a = 0
while a < 10:
    if a == 3:
        a += 1
        continue
    elif a == 8:
        break
    else:
        print(a)
    a += 1
#+END_SRC

Also supports ~else~ which is called when we exit the loop

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
else:
    print("done")
#+END_SRC

unless we exit the loop using ~break~

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
    if b >= 5:
        break
else:
    print("done")
#+END_SRC

** The ~range()~ function

Can be used when you need to iterate over an arethmetic progression. The endpoint is never generated

#+BEGIN_SRC python :python python3 :results output
for i in range(5):
    print(i) # Will print 0 to 4
#+END_SRC

You can define start and end point

#+BEGIN_SRC python :python python3 :results output
for i in range(5, 10):
    print(i)
#+END_SRC

And define a step size

#+BEGIN_SRC python :python python3 :results output
for i in range(0, 10, 3):
    print(i)
#+END_SRC

And also ranges with negative step

#+BEGIN_SRC python :python python3 :results output
for i in range(-10, -100, -30):
    print(i)
#+END_SRC

To iterate over the indices of a sequence, you can combine range() and len() as follows

#+BEGIN_SRC python :python python3 :results output
a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])
#+END_SRC

Printing a range

#+BEGIN_SRC python :python python3 :results output
myRange = range(5)
print(myRange)
print(list(myRange))
print(tuple(myRange))
#+END_SRC

** The ~pass~ statement

Does nothing but can be used when a statement is needed syntactically

#+BEGIN_SRC python :python python3 :results output
def f(arg):
    pass    # a function that does nothing
#+END_SRC

* Functions

The first line in the following function is the documenation string (and is
optional). Some tools can extract this string

#+BEGIN_SRC python :python python3 :results output
def fib(n):    # write Fibonacci series up to n
    """Print a Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
#+END_SRC

Call by value

#+BEGIN_SRC python :python python3 :results output
def f(n):
    print("In function:   ", n)
    n = 3
    print("In function:   ", n)

myVar = 5
f(myVar)
print("After function:", myVar)
#+END_SRC

But passes references

#+BEGIN_SRC python :python python3 :results output
def f(aList):
    print("In function:   ", aList)
    aList[1] = 5
    print("In function:   ", aList)

myList = [1, 2, 3]
f(myList)
print("After function:", myList)
#+END_SRC

A function that doesn't return any value will return the value ~None~.

You can create a function which returns a value with the ~return~ keyword

#+BEGIN_SRC python :python python3 :results output
def fib2(n):  # return Fibonacci series up to n
    """Return a list containing the Fibonacci series up to n."""
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)    # see below
        a, b = b, a+b
    return result

f100 = fib2(100)
print(f100)
#+END_SRC

~return~ without arguments will return ~None~. If execution reaches the end of
the method it will also return ~None~

We can have several references to the same function. Deleting the original one
won't delete the copies

#+BEGIN_SRC python :python python3 :results output
def succ(x):
    return x + 1

successor = succ
print(succ(10))
print(successor(10))
del(succ)
print(successor(10))
#+END_SRC

** Variable number of arguments
*** Default argument values

#+BEGIN_SRC python :python python3 :results output
def ask_ok(prompt, retries=100, reminder='Please try again!'):
    print("prompt:  ", prompt)
    print("retries: ", retries)
    print("reminder:", reminder)
    print()

ask_ok("Test", 5, "Last")
ask_ok("Test", 5)
ask_ok("Test")
ask_ok("Test", reminder="Last")
#+END_SRC

Note that the default value will only be evaluated once. Mutable objects may be
updated

#+BEGIN_SRC python :python python3 :results output
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
#+END_SRC

*** Keyword arguments

When you call a function you can provide an argument along with a keyword. All
keyword arguments must be placed after all positional arguments

#+BEGIN_SRC python :python python3 :results output
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")
    print()

# This method can be called in several different ways
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
#+END_SRC

*** Arbitrary Argument Lists

Can be preceded by zero or more normal arguments. Can also be followed by
keyword arguments. A variadic variable will be a tuple

#+BEGIN_SRC python :python python3 :results output
def report(header, *entries, sep='\n'):
    print(header)
    print('-' * len(header))
    print(sep.join(entries))
    print()

report("Food", "Bread", "Butter")
report("Food", "Bread", "Butter", sep=" ")
#+END_SRC

A special variadic element can also be defined with ~**~ which will be treated
as a dictionairy. The dictionairy will _always_ be in the same order as the
arguments passed

#+BEGIN_SRC python :python python3 :results output
def report(header, *entries, **dictentries):
    print(header)
    print('-' * len(header))
    print('\n'.join(entries))
    print('-' * len(header))
    for kw in dictentries:
        print(kw, ":", dictentries[kw])
    print()

report("Food", "Bread", "Butter", test1=1, test2=2)
report("Food", "Bread", "Butter", sep=" ")
#+END_SRC

*** Unpacking variables

Sometimes you have the arguments in a list and you need to provide them to a
function separately. Then you'll have to unpack them

#+BEGIN_SRC python :python python3 :results output
print(list(range(3, 6)))
args = [3, 6]
print(list(range(*args)))
#print(list(range(args))) # This will fail
#+END_SRC

Same thing when unpacking dictionairies. But you'll unpack it with the ~**~
operator

#+BEGIN_SRC python :python python3 :results output
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")

d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)
#+END_SRC

** Return multiple values

Python returns exactly one object. If you need to return multiple these can be
packed into a tuple

#+BEGIN_SRC python :python python3 :results output
def fib_intervall(x):
    if x < 0:
        return -1
    (old, new, lub) = (0,1,0)
    while True:
        if new < x:
            lub = new
            (old,new) = (new,old+new)
        else:
            return lub, new # Will automatically be packed in a tuple

x = 100
(lub, sup) = fib_intervall(x)
print("Largest Fibonacci Number smaller than x: " + str(lub))
print("Smallest Fibonacci Number larger than x: " + str(sup))
#+END_SRC

** Nested functions

In python you can define a function inside another function

#+BEGIN_SRC python :python python3 :results output
def f():
    def g():
        print("Hi, it's me 'g'")
        print("Thanks for calling me")

    print("This is the function 'f'")
    print("I am calling 'g' now:")
    g()

f()
#+END_SRC

** Functions returning functions

A function can return another function

#+BEGIN_SRC python :python python3 :results output
def f(x):
    def g(y):
        return y + x
    return g

plus_one = f(1)
plus_three = f(3)

print(plus_one(1))
print(plus_three(1))
#+END_SRC

** Lambda Expressions

In the following example we uses a lambda to create a new function (currying?)

#+BEGIN_SRC python :python python3 :results output
def make_incrementor(n):
    return lambda x: x + n

f = make_incrementor(42)
print(f(0))
print(f(1))
#+END_SRC

You can also use lambdas when you need to provide a function to another
function. In this example we want to sort the list on the string (the second
entry in each tuple)

#+BEGIN_SRC python :python python3 :results output
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
print(pairs)
#+END_SRC

A lambda can take multiple parameters

#+BEGIN_SRC python :python python3 :results output
sum = lambda x, y : x + y
print(sum(3,4))
#+END_SRC

** Documentation string (doc string)

The first line in the documentation string should be short, concise summary of
the objectâ€™s purpose. If more documentation is needed the second line should be
blank. You can reach the doc string with the ~.__doc__~ call.

#+BEGIN_SRC python :python python3 :results output
def my_function():
    """Do nothing, but document it.

    No, really, it doesn't do anything.
    """
    pass

print(my_function.__doc__)
#+END_SRC

** Function annotations

Function annotations are optional and they can be used for whatever you feel.
Parameter annotations are defined by a colon after the parameter name, followed
by an expression evaluating to the value of the annotation. Return annotations
are defined by a literal ~->~, followed by an expression, between the parameter
list and the colon denoting the end of the def statement.

#+BEGIN_SRC python :python python3 :results output
def f(ham: str, eggs: str = 'eggs') -> str:
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham + ' and ' + eggs

print(f('spam'))
#+END_SRC

A more advanced example

#+BEGIN_SRC python :python python3 :results output
def validate(func, locals):
    for var, test in func.__annotations__.items():
        value = locals[var]
        msg = 'Var: {0}\tValue: {1}\tTest: {2.__name__}'.format(var, value, test)
        assert test(value), msg


def is_int(x):
    return isinstance(x, int)

def between(lo, hi):
    def _between(x):
            return lo <= x <= hi
    return _between

def f(x: between(3, 10), y: is_int = 1):
    validate(f, locals()) # locals return a dictionairy of the current scope's local variables
    print(x, y)


f(5)
f(5, 1)
#+END_SRC

You can also use them for documentation if you want. E.g. what kind of data you
expect or the types of the arguments.

* The ~map~, ~filter~ and ~reduce~ functions

In this section we will use [[*Lambda Expressions][lambda expressions]] together with ~map~, ~filter~ and
~reduce~ (although you could use regular functions as well)

** The ~map~ function

~map~ accepts two arguments; a function to apply to each element in a sequence,
and the sequence where the function should be applied. ~map~ returns an iterator
(in Python 2 it used to return ~list~)

#+BEGIN_SRC python :python python3 :results output
def fahrenheit(T):
    return ((float(9)/5)*T + 32)

temperatures = (36.5, 37, 37.5, 38, 39)
F = map(fahrenheit, temperatures)

print(list(F))
#+END_SRC

Or with lambdas

#+BEGIN_SRC python :python python3 :results output
temperatures = (36.5, 37, 37.5, 38, 39)
F = map(lambda T: ((float(9)/5)*T + 32), temperatures)

print(list(F))
#+END_SRC

~map~ can be applied to several lists. Then it will first feed the function with
the 0th index of each list and then the 1st, 2nd, etc.

#+BEGIN_SRC python :python python3 :results output
a = [1, 2, 3, 4]
b = [17, 12, 11, 10]
c = [-1, -4, 5, 9]

m = list(map(lambda x, y, z : x+y+z, a, b, c))
print(m)
#+END_SRC

If the lists isn't of the same length ~map~ will stop when the shortest list is
consumed

** The ~filter~ function

~filter~ accepts two arguments; a function which should return a boolean and a
sequence. If a the function returns ~True~ for a function it will exist in the
resulting list, otherwise it will be filtered away

#+BEGIN_SRC python :python python3 :results output
fibonacci = [0,1,1,2,3,5,8,13,21,34,55]
odd_numbers = list(filter(lambda x: x % 2, fibonacci))
print(odd_numbers)
#+END_SRC

** The ~reduce~ function

~reduce~ accepts two arguments; a function ~op~ and a sequence ~[s1,s2,s3,s4]~
and will apply ~op~ in like this

#+BEGIN_SRC
op(op(op(s1,s2),s3),s4)
#+END_SRC

In order to use ~reduce~ you need to import it from the ~functools~ module

#+BEGIN_SRC python :python python3 :results output
from functools import reduce

print(reduce(lambda x, y: x + y, [1,2,3,4,5]))
print(reduce(lambda x, y: x + ' ' + y, ['This', 'is', 'a', 'test']))
#+END_SRC

* Data structures
** List comprehensions

Can be used to create new lists where each element is the result of some
operations applied to each member of another sequence or iterable, or to create
a subsequence of those elements that satisfy a certain condition.

#+BEGIN_SRC python :python python3 :results output
squares = []
for x in range(10):
    squares.append(x**2)

print(squares)
# A side effect of doing it this way
print(x)
#+END_SRC

This can be replaced with

#+BEGIN_SRC python :python python3 :results output
squares = list(map(lambda x: x**2, range(10)))
print(squares)
#+END_SRC

or (note that there are no side effects on this call)

#+BEGIN_SRC python :python python3 :results output
x = 3
squares = [x**2 for x in range(10)]
print(squares)
print(x)
#+END_SRC

You can add more ~for~ clauses and optional ~if~ clasuses to the comprehension.

#+BEGIN_SRC python :python python3 :results output
myVar = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
print(myVar)
#+END_SRC

or to find pythagorean triples

#+BEGIN_SRC python :python python3 :results output
pt = [(x,y,z) for x in range(1,30) for y in range(x,30) for z in range(y,30) if x**2 + y**2 == z**2]
print(pt)
#+END_SRC

You can use the variable multiple times

#+BEGIN_SRC python :python python3 :results output
myVar = [(x, x**2) for x in range(6)]
print(myVar)
#+END_SRC

Or flatten a matrix

#+BEGIN_SRC python :python python3 :results output
vec = [[1,2,3], [4,5,6], [7,8,9]]
myVar = [num for elem in vec for num in elem]
print(myVar)
#+END_SRC

*** Set comprehensions

To calculate prime numbers between 1 and 100 you can use sieve of Eratosthenes

#+BEGIN_SRC python :python python3 :results output
noprimes = [j for i in range(2, 8) for j in range(i*2, 100, i)]
primes = [x for x in range(2, 100) if x not in noprimes]
print(primes)
#+END_SRC

It works but if we look at the ~noprimes~ list you will see that there are a lot
of duplicates

#+BEGIN_SRC python :python python3 :results output
noprimes = [j for i in range(2, 8) for j in range(i*2, 100, i)]
print(noprimes)
#+END_SRC

We can then use a set comprehension by replacing the wrapping ~[]~ with ~{}~

#+BEGIN_SRC python :python python3 :results output
noprimes = {j for i in range(2, 8) for j in range(i*2, 100, i)}
print(noprimes)
#+END_SRC

*** Dictionairy comprehensions

You can also create a dictionairy with dict comprehension

#+BEGIN_SRC python :python python3 :results output
myDict = {x: x**2 for x in (2, 4, 6)}
print(myDict)
#+END_SRC

** Nested list comprehensions

The expression in a list comprehension can be another comprehension. The
following code will transpose the matrix

#+BEGIN_SRC python :python python3 :results output
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
transposed = [[row[i] for row in matrix] for i in range(4)]
print(transposed)
#+END_SRC

** Looping techniques

Looping over all key-value pairs in a dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
for k, v in filled_dict.items():
    print ("Key:", k, "Value:", v)
#+END_SRC

If you just call it without ~items()~ it will only loop over the keys

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
for k in filled_dict:
    print ("Key:", k)
#+END_SRC

Loop over a sequence and keep track of the index for each element

#+BEGIN_SRC python :python python3 :results output
for i, v in enumerate(['First', 'Second', 'Third']):
    print(i, v, "element")
#+END_SRC

To loop over multiple sequences at the same time you can use ~zip~

#+BEGIN_SRC python :python python3 :results output
numbers = [1, 2, 3, 4]
squares = [1, 4, 9, 16]

for n, s in zip(numbers, squares):
    print("The square of", n, "is", s)
#+END_SRC

If you want to travese a sequence in reverse order

#+BEGIN_SRC python :python python3 :results output
for i in reversed([1, 2, 3, 4]):
    print(i)
#+END_SRC

* Modules

The module name is the file name without the ~.py~ file ending. The module name
can be fetched from the ~__name__~ variable. Where it was imported from can be
fetched from the ~__file__~ variable

I have already created a module called [[file:mymodule.py][mymodule]] in this directory. We can now
import it to our script with the ~import~ keyword. Now you can access the
module's functions by refering to the module name

#+BEGIN_SRC python :python python3 :results output
import mymodule

mymodule.fib(1000)
myvar = mymodule.fib2(1000)
print(myvar)
print(mymodule.__name__)
print(mymodule.__file__)
#+END_SRC

You can also assign a function to a variable

#+BEGIN_SRC python :python python3 :results output
import mymodule

fib = mymodule.fib
fib(1000)
#+END_SRC

** More on modules

Each module has its own private symbol table, which is used as the global symbol
table by all functions defined in the module. There is no risk of naming
conflicts between modules. On the other hand, if you know what you are doing you
can touch a moduleâ€™s global variables with the same notation used to refer to
its functions, ~modname.itemname~

There is a variant of the import statement that imports names from a module
directly into the importing moduleâ€™s symbol table (no need to call a method
using the module name). With the following code you won't be able to refer to
the ~mymodule~ module

#+BEGIN_SRC python :python python3 :results output
from mymodule import fib, fib2

fib(1000)
#mymodule.fib(1000) # name 'mymodule' is not defined
#+END_SRC

You can also import all names a module defines (except those that begin with a
underscore)

#+BEGIN_SRC python :python python3 :results output
from mymodule import *

fib(1000)
myvar = fib2(1000)
print(myvar)
#+END_SRC

You can also "rename" a module when you import it

#+BEGIN_SRC python :python python3 :results output
import mymodule as fib

fib.fib(1000)
print(fib.__name__)
#+END_SRC

We can also use the ~as~ keyword together with ~from~

#+BEGIN_SRC python :python python3 :results output
from mymodule import fib as fibonacci

fibonacci(1000)
#+END_SRC

If you want to import multiple modules you can put them on multiple rows or you
can put them on the same row

#+BEGIN_SRC python :python python3 :results output
import math, random
#+END_SRC

** Executing a module as a script

If the ~__name__~ variable is set to ~__main__~ it means that the current module
is the file which was invoked (e.g. from command line)

#+BEGIN_SRC python :python python3 :results output :preamble import sys; sys.argv = ["filename","50"]
from mymodule import fib
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
#+END_SRC

If this file is imported to another file now the code will not be called.
Otherwise the code will run. This is often used either to provide a convenient
user interface to a module, or for testing purposes (running the module as a
script executes a test suite).

** Module search path

When importing a module python will first search within the built-in modules,
otherwise it will look in for it in a list of directories given by the variable
~sys.path~. This is initialized to the directory containing the input script and
the path given by the ~PYTHONPATH~ environment variable and lastly the
installation-dependent default. The python program can alter the ~sys.path~
during execution using standard list operations.

** See the content of a module with the ~dir~ function

The ~dir~ function is used to find out which names a module defines. It returns
a sorted list of strings. With no arguments you find the names you have
currently defined. Not the built-in functions and variables. To see those you
can run ~dir(builtins)~

#+BEGIN_SRC python :python python3 :results output
import mymodule, sys
print("mymodule\n", dir(mymodule), sep='')
print("sys\n", dir(sys), sep='')
print("noarg\n", dir(), sep='')
import builtins
print("builtins\n", dir(builtins), sep='')
#+END_SRC

** Packages

Packages are a way of structuring Pythonâ€™s module namespace by using â€œdotted
module namesâ€. Can be used so different authors of multi-module packages won't
have to worry about colliding module names. Here is a directoy structure

#+BEGIN_SRC
mypackage            # The package
|-- __init__.py      # Initialize the package
|-- mysubpackage1    # Subpackage
|   |-- __init__.py
|   |-- module11.py
|   `-- module12.py
`-- mysubpackage2
    |-- __init__.py
    |-- module21.py
    `-- module22.py
#+END_SRC

The ~__init__.py~ are required so python know that the directory contains
packages. It can be empty or contain initialization code for the package or
set the ~__all__~ variable.

You can now import a module by refering to the full name. You have to refer to
it's full name in the code as well

#+BEGIN_SRC python :python python3 :results output
import mypackage.mysubpackage1.module11

mypackage.mysubpackage1.module11.function(var)
#+END_SRC

You can also import the submodule with ~from package import module~. Then you
won't have to refer to the full name

#+BEGIN_SRC python :python python3 :results output
from mypackage.mysubpackage1 import module11

module11.function(var)
#+END_SRC

or

#+BEGIN_SRC python :python python3 :results output
from mypackage.mysubpackage1.module11 import function

function(var)
#+END_SRC

If you would only import ~mypackage~ it will only run the initialization code
in the ~__init__.py~ file. If the ~__init__.py~ contains e.g.

#+BEGIN_SRC python :python python3 :results output
import mypackage.mysubpackage1
import mypackage.mysubpackage2
#+END_SRC

You will be able to run

#+BEGIN_SRC python :python python3 :results output
import mypackage

print(mypackage.mysubpackage1) # prints info about the package
#+END_SRC


*** Import * from a package

If a package's ~__init__.py~ file defines a list called ~__all__~ it will import
all modules defined in that list when ~from package import *~ is encountered.
If the file ~mypackage/mysubpackage1/__init__.py~ contains

#+BEGIN_SRC python :python python3 :results output
__all__ = ["module11", "module12"]
#+END_SRC

those two modules will be imported when ~from mypackage.mysubpackage1 import *~
is encountered. If ~__all__~ is not defined it does not import any modules, it
only runs initialization code in ~__init__.py~

*** Module references inside package

You can use absolute referencing inside a package as described above or you can
use relative referencing. In the ~module11.py~ file you can write

#+BEGIN_SRC python :python python3 :results output
from . import module12
from .. import mysubpackage2
from ..mysubpackage2 import module21
#+END_SRC

Relative import can't be used in the main module of a program!

* Input/output
** The ~print~ function

The arguments to the ~print~ functions are these

#+BEGIN_SRC
print(value1, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
#+END_SRC

By default the arguments to print are separated by spaces.

#+BEGIN_SRC python :python python3 :results output
print('a', 'b', 'c')
#+END_SRC

To change to another separator you can have to set the ~sep~ argument

#+BEGIN_SRC python :python python3 :results output
print('a', 'b', 'c', sep=':')
#+END_SRC

We can also see that each row is appended with a newline

#+BEGIN_SRC python :python python3 :results output
for i in range(4):
    print(i)
#+END_SRC

This can also be changed by updating the ~end~ argument

#+BEGIN_SRC python :python python3 :results output
for i in range(4):
    print(i, end=':')
#+END_SRC

You can also change where the text is printed. By default it is printed to
~stdout~. We can change it to an open file or e.g. ~stderr~

#+BEGIN_SRC python :python python3 :results output
import sys
print('a', 'b', 'c', file=sys.stderr)
#+END_SRC

** Formatting

Python can convert values to strings in two ways, using ~str()~ (used for human
readable text) or ~repr()~ (for generating representations which can be read
by the interpreter). For many values both calls will result in the same string.
Here we used a string but any python object can be passed

#+BEGIN_SRC python :python python3 :results output
s = 'Hello, world.\n'
print("str(s): ", str(s))
print("repr(s):", repr(s))
#+END_SRC

You can justify a string using ~ljust()~, ~rjust()~ and ~center()~. Not that
none of these calls will truncate the value if it would be too long

#+BEGIN_SRC python :python python3 :results output
for x in range(1, 11):
    print(repr(x).rjust(2), repr(x*x).rjust(3), repr(x*x*x).rjust(4))
#+END_SRC

These methods also supports a fillchar if you want to use anything other than
space

#+BEGIN_SRC python :python python3 :results output
for x in range(1, 11):
    print(repr(x).ljust(6, '-'), repr(x*x).center(6, '*'), repr(x*x*x).rjust(6, '='))
#+END_SRC

The ~zfill()~ will pad a numeric string with zeros to the left. It understands
plus and minus

#+BEGIN_SRC python :python python3 :results output
print('12'.zfill(5))
print('-3.14'.zfill(7))
print('3.14159265359'.zfill(5))
#+END_SRC

*** c like formatting using the ~%~ operator

#+BEGIN_SRC python :python python3 :results output
print("Art: %5d, Price per Unit: %8.2f" % (453, 59.058))
#+END_SRC

The format for a format placeholder is

#+BEGIN_SRC
%[flags][width][.precision]type
#+END_SRC

Note that the ~%~ operator is not part of the ~print~ function. It is formatting
a string and will return a string

#+BEGIN_SRC python :python python3 :results output
s = "Art: %5d, Price per Unit: %8.2f" % (453, 59.058)
print(s)
#+END_SRC

See more here: [[https://www.python-course.eu/python3_formatted_output.php]]

*** The ~str.format()~ function

The basic form looks like this

#+BEGIN_SRC python :python python3 :results output
print('{} and {}'.format('rock', 'roll'))
#+END_SRC

You can also add an index the format fields

#+BEGIN_SRC python :python python3 :results output
print('{0} and {1}'.format('rock', 'roll'))
print('{1} and {0}'.format('rock', 'roll'))
print('{0}, {1} and {0}'.format('rock', 'roll'))
#+END_SRC

or keywords

#+BEGIN_SRC python :python python3 :results output
print('{person} smells {smell}'.format(person='Sara', smell='wonderful'))
#+END_SRC

You're also allowed to mix these. You can also add a ~:~ after the field name
which gives you control how a value is formatted

#+BEGIN_SRC python :python python3 :results output
import math
print('The value of PI is approximately {0:.3f}.'.format(math.pi))
#+END_SRC

Passing an integer after ~:~ will force that field to be at least of that length

#+BEGIN_SRC python :python python3 :results output
table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
for name, phone in table.items():
    print('{0:10} ==> {1:10d}'.format(name, phone))
#+END_SRC

You can read more about [[https://www.python-course.eu/python3_formatted_output.php][here]]

You can also pass a dictionairy

#+BEGIN_SRC python :python python3 :results output
table = {'firstkey' : 'firstvalue1', 'secondkey' : 'secondvalue1'}
table2 = {'firstkey' : 'firstvalue2', 'secondkey' : 'secondvalue2'}
print('First: {0[firstkey]}. Second: {1[secondkey]}'.format(table, table2))
#+END_SRC

Something similar could be done with the ~**~ operator

#+BEGIN_SRC python :python python3 :results output
table = {'firstkey' : 'firstvalue1', 'secondkey' : 'secondvalue1'}
print('First: {firstkey}. Second: {secondkey}'.format(**table))
#+END_SRC

Python also has support for printf style string formatting

#+BEGIN_SRC python :python python3 :results output
import math
print('The value of PI is approximately %5.3f.' % math.pi)
#+END_SRC

*** Formatted string literals

You can also use formatted string literals which are prefixed with a ~f~. The
formatting syntax is similar to ~str.format()~. These will be evaluated in real
time when they are created

#+BEGIN_SRC python :python python3.6 :results output
test_var = 'test'
my_formatted_string = f'This is a {test_var}'
print(my_formatted_string)
test_var = 'robbery'
print(my_formatted_string) # Note that it won't print robbery here
#+END_SRC

** Reading and writing files

The ~open()~ function returns a file object. It is commonly used with ~filename~
and ~mode~ arguments

#+BEGIN_SRC python :python python3 :results output
f = open('mymodule.py', 'r')
#+END_SRC

The mode can be any of these strings:

| Mode | Description                                |
|------+--------------------------------------------|
| 'r'  | Read only                                  |
| 'w'  | Write only (overwrite a file if it exists) |
| 'a'  | Append to the end of the file              |
| 'r+' | Read and write                             |

The ~mode~ argument is optional and is defaulted to ~'r'~. If you append a ~b~
to the ~mode~ argument (e.g. ~'rb'~) the file will be opened in binary mode and
the data is read and written in byte objects.

It's a good practice to open a file using the ~with~ keyword. It will close the
file when we exit the block (even if an exception is raised). This can also be
done using ~try-finally~. If you don't use any of these approaches you will have
to make sure you call the ~file.close()~ function yourself

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    read_data = f.read()
    print(read_data)
print("Is file closed?", f.closed)
#+END_SRC

*** Read

If you don't want to read the full file, the ~read()~ method also accepts a
~size~ argument which is the maximum number of data to be read. If EOF has been
reached ~read()~ will return an empty string (~''~)

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    read_data = f.read(15)
    print('First read: ', read_data)
    read_data = f.read(15)
    print('Second read:', read_data)
#+END_SRC

To read a full line you can use the ~readline()~ method. This method will also
read the newline character. It is only omitted on the last line if there is no
newline character. If an empty string is returned it means that we have reached
the end of the file

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    while True:
        read_data = f.readline()
        if read_data == '':
            break
        # The variable already contains a newline
        print(read_data, end='')
#+END_SRC

An easier way to achive the same result is to loop over the file object

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    for line in f:
        print(line, end='')
#+END_SRC

You can also read all lines into a list

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    linesList = list(f)
    print(linesList)
#+END_SRC

or

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    linesList = f.readlines()
    print(linesList)
#+END_SRC

*** Write

If you want to write to a file you can us the ~write()~ function which accepts a
string and returns the number of characters written

#+BEGIN_SRC python :python python3 :results output
with open('temp_output.txt', "w") as f:
    charsWritten = f.write('This is a test\n')
print('Chars written:', charsWritten)
#+END_SRC

The output is now written to [[file:temp_output.txt][temp_output.txt]]. Other types needs to be converted
to string or bytes object before writing them

#+BEGIN_SRC python :python python3 :results output
with open('temp_output.txt', "w") as f:
    value = ('the answer', 42)
    charsWritten = f.write(str(value))
print('Chars written:', charsWritten)
#+END_SRC

*** Search

~tell()~ return the current position represented as the number of bytes from the
beginning of the file for binary files and an non-modifiable object for text
files (only meant to be used to get back to the current position)

To change the current position you can use ~seek()~ which accepts two arguments
~offset~ and ~from_what~. ~from_what~ can be either

| ~from_what~ | Description                 |
|-------------+-----------------------------|
|           0 | Beginning of file (default) |
|           1 | Current file position       |
|           2 | End of file                 |

For text files only ~0~ is allowed. The only exception is to find the very end
of the file ~f.seek(0, 2)~. For text files the only valid offsets are those
which are returned from ~tell()~ and ~0~

** Reading from a url

#+BEGIN_SRC python :python python3 :results output
import re
from urllib.request import urlopen

with urlopen('https://www.python-course.eu/simpsons_phone_book.txt') as fh:
    for line in fh:
        # line is a byte string so we transform it to utf-8:
        line = line.decode('utf-8').rstrip()
        if re.search(r"J.*Neu",line):
            print(line)
#+END_SRC

** Input

To read input from the keyboard you can use the ~input~ method. It will return
when the user press the return key

#+BEGIN_SRC python :python python3 :results output
input_string = input()
#+END_SRC

You can also provide an argument if you want a prompt

#+BEGIN_SRC python :python python3 :results output
input_string = input("Please enter an integer: ")
#+END_SRC

The method will return the string the user entered. If you want to treat it as
something else you need to cast it to that type

#+BEGIN_SRC python :python python3 :results output
input_integer = int(input("Please enter an integer: "))
#+END_SRC

* Scopes

Module attributes are writable. Writable attributes can also be deleted with the
~del~ keyword. I once again use [[file:mymodule.py][mymodule]] as my assisting module

#+BEGIN_SRC python :python python3 :results output
# Add example where we set a module attribute and call a function that prints it
import mymodule

mymodule.printMyVariable()
mymodule.myvariable = 15
mymodule.printMyVariable()

# The following lines will make it fail
#del mymodule.myvariable
#mymodule.printMyVariable()
#+END_SRC

There are at least three nested scopes whose namespaces are directly accessible:

- The innermost scope, which is searched first, contains the local names
- The scopes of any enclosing functions, which are searched starting with the
  nearest enclosing scope, contains non-local, but also non-global names
- The next-to-last scope contains the current moduleâ€™s global names
- The outermost scope (searched last) is the namespace containing built-in names

If a name is declared ~global~, then all references and assignments go directly
to the middle scope containing the moduleâ€™s global names. To rebind variables
found outside of the innermost scope, the ~nonlocal~ statement can be used; if
not declared ~nonlocal~, those variables are read-only (an attempt to write to
such a variable will simply create a new local variable in the innermost scope,
leaving the identically named outer variable unchanged). ~nonlocal~ can only
be used in nested scopes and will not be able to "find" global variables

All operations that introduce new names use the local scope: in particular,
~import~ statements and function definitions bind the module or function name
in the local scope.

Note that a variable which is declared ~nonlocal~ needs to refer to a
pre-existing variable in an enclosing scope. A variable which is declared as
~global~ can be newly introduced

#+BEGIN_SRC python :python python3 :results output
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
#+END_SRC

** Examples

#+BEGIN_SRC python :python python3 :results output
def f():
    print(s)
s = "Python"
f()
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
def f():
    s = "Perl"
    print(s)

s = "Python"
f()
print(s)
#+END_SRC

The following code wont work. Looks like as if we can't mix "implicit" globals
with local variables

#+BEGIN_SRC python :python python3 :results output
def f():
    print(s)
    s = "Perl"
    print(s)

s = "Python"
f()
print(s)
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
def f():
    global s
    print(s)
    s = "dog"
    print(s)

s = "cat"
f()
print(s)
#+END_SRC

* Classes

Just like function definitions (~def~) the class definition needs to be executed
before they have any effect. Classes doesn't have to be defined on global level
but can be defined in e.g. ~if~ statements or functions

** Class object

A class object supports two kinds of operations: /attribute references/ and
/instantiation/.

*** Attribute references

Attribute references uses the syntax for all attribute references ~obj.name~
where name can be any of the names that were in the class's namespace when the
class was defined. The ~doc string~ is also allowed

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

print(MyClass.__doc__)
print(MyClass.i)
MyClass.i = 6
print(MyClass.i)
#+END_SRC

As you can see in the example above you can also assign values to the referenced
attributes

*** Instantiation

To create a new instance of a class you just treat the defined class as a
parameterless function

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

x = MyClass()
y = MyClass()

print(x.f())
print(x.i)
print(y.i)
x.i = 1
y.i = 2
print(x.i)
print(y.i)
print(MyClass.i)
#+END_SRC

The constructor above creates an empty object. We can also define our own
constructor by defining an ~__init__()~ method

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self):
        self.x = 4
        self.y = 5

    def printState(self):
        print("x:", self.x, "y:", self.y)

a = MyClass()
a.printState()
a.x = 10
a.printState()
#+END_SRC

A constuctor can also accept parameters

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def printState(self):
        print("x:", self.x, "y:", self.y)

a = MyClass(20, 30)
a.printState()
a.x = 10
a.printState()
#+END_SRC

** More about attribute references

There are two forms of attribute references: data attributes and methods.

Data attributes corresponds to instance variables. They don't have to be
declared but will be created when they are assigned a vales

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    pass

x = MyClass()

x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter
#+END_SRC

Beware that data attributes override method attributes with the same name when
assigning! The only way to avoid this is to use some kind of convention to
minimize the chance of conflicts

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def f(self):
        return 'hello world'

x = MyClass()

print(type(x.f))
print(x.f())

x.f = 50;

print(type(x.f))
print(x.f)
#+END_SRC

** Method Objects

It's not necessary to call a method directly when referencing a method. Instead
of ~x.f()~ you can get the method object which can be stored away and called
later by calling ~x.f~. E.g.

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def f(self):
        return 'hello world'

x = MyClass()
xf = x.f

for i in range(5):
    print(xf())
#+END_SRC

As you have noticed all methods defined in classes accepts a ~self~ parameter.
Python passes the instance object as the first object when referencing the
method. ~x.f()~ is actually equivalent to ~MyClass.f(x)~. So the example above
could be written as:

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def f(self):
        return 'hello world'

x = MyClass()
f = MyClass.f

for i in range(5):
    print(f(x))
#+END_SRC

Note that the name ~self~ is nothing else but a convention. You can choose
another name for it (but that's discouraged!).

** Class and instance variables

#+BEGIN_SRC python :python python3 :results output
class Dog:
    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

d = Dog('Fido')
e = Dog('Buddy')
print(d.kind)                  # shared by all dogs
print(e.kind)                  # shared by all dogs
Dog.kind = 'doggo'
print(d.kind)                  # shared by all dogs
print(e.kind)                  # shared by all dogs
print(d.name)                  # unique to d
print(e.name)                  # unique to e
#+END_SRC

Here's an example how you can accidentally treat a class variable as if it was
an instance variable

#+BEGIN_SRC python :python python3 :results output
class Dog:
    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

d = Dog('Fido')
e = Dog('Buddy')
d.add_trick('roll over')
e.add_trick('play dead')
print(d.tricks)                # unexpectedly shared by all dogs
#+END_SRC

The correct way to do it would be

#+BEGIN_SRC python :python python3 :results output
class Dog:
    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

d = Dog('Fido')
e = Dog('Buddy')
d.add_trick('roll over')
e.add_trick('play dead')
print(d.tricks)
print(e.tricks)
#+END_SRC

** Random remarks

It is not necessary that a class method itself is defined inside the class
definition. E.g.

#+BEGIN_SRC python :python python3 :results output
# Function defined outside the class
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1

    def g(self):
        return 'hello world'

    h = g

c = C()

print(c.f(1,4))
print(c.g())
print(c.h())
#+END_SRC

Also it's good to know that methods may call other methods by referencing
attributes of the ~self~ object

#+BEGIN_SRC python :python python3 :results output
class Bag:
    def __init__(self):
        self.data = []

    def add(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)

bag = Bag()
print(bag.data)
bag.add('thing')
print(bag.data)
bag.addtwice('stuff')
print(bag.data)
#+END_SRC

** Inheritence

You subclass another class by putting it in paranthesis

#+BEGIN_SRC python :python python3 :results output
class Animal:
    def noise(self):
        print('Noise')

    def run(self):
        print('Running')

class Dog(Animal):
    def noise(self):
        print('Bark')

animal = Animal()
dog = Dog()

animal.noise()
animal.run()
dog.noise()
dog.run()
Animal.noise(dog)
#+END_SRC

As you can see by running the example above a subclass inherits the methods from
its parent and can also override methods. If you still want to call the parent
class method definition it can be done like the last row:
~BaseClass.func(subClass_instance)~. ~BaseClass~ needs to be accessible of
course.

In this case the ~Animal~ class was defined in the same module but if was
defined in another module it could be sub classed with
~class Dog(modulename.Animal):~.

You can check inheritence with the methods ~isinstance~ (to check instance type)
and ~issubclass~ (to check class inheritence)

#+BEGIN_SRC python :python python3 :results output
class Animal:
    pass

class Dog(Animal):
    pass

animal = Animal()
dog = Dog()

print(isinstance(animal, Animal))
print(isinstance(animal, Dog))
print(isinstance(dog, Animal))
print(isinstance(dog, Dog))
print()
print(issubclass(Animal, Animal))
print(issubclass(Animal, Dog))
print(issubclass(Dog, Animal))
print(issubclass(Dog, Dog))
#+END_SRC

It also looks like as if a subclass inherits the initializers (and it can be
overridden). E.g.

#+BEGIN_SRC python :python python3 :results output
class Animal:
    def __init__(self):
        print('Creating Animal')

class Dog(Animal):
    pass

class Cat(Animal):
    def __init__(self):
        print('Creating Cat')

animal = Animal()
dog = Dog()
cat = Cat()
#+END_SRC

*** Multiple Inheritence

You can also have multiple parents in Python

#+BEGIN_SRC python :python python3 :results output
class Animal:
    pass

class Quadruped:
    pass

class Dog(Animal, Quadruped):
    pass

dog = Dog()
#+END_SRC

For most purposes, in the simplest cases, you can think of the search for
attributes inherited from a parent class as depth-first, left-to-right, not
searching twice in the same class where there is an overlap in the hierarchy.
Thus, if an attribute is not found in ~Dog~, it is searched for in ~Animal~,
then (recursively) in the base classes of ~Animal~, and if it was not found
there, it was searched for in ~Quadruped~, and so on. This is not really the
truth as the method resolution order changes dynamically to support cooperative
calls to ~super()~. This is known as /call-next-method/.

** Private Variables

In python there are no private variables. The convention is that if you prefix
the variable, method or function with an underscore it should be treated as non-
public (and may change without notice).

To avoid name clashes with subclasses there is something called /name mangling/.
An identifier which is prefixed with at least two underscores and at most one
trailing underscore is will be prefixed with ~_classname~. E.g. ~__myvar~ will
be replaced with ~_MyClass__myvar~ in the class ~MyClass~. This can only be done
inside classes.

This is helpful for letting subclasses override methods without breaking
intraclass method calls. Compare the examples below

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self, var):
        self.printGreeting()

    def printGreeting(self):
        print('Hi')

class MySubclass(MyClass):
    def printGreeting(self):
        print('Howdy')

myClass = MyClass(1)
mySubclass = MySubclass(1)
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self, var):
        self.__printGreeting()

    def printGreeting(self):
        print('Hi')

    __printGreeting = printGreeting   # private copy of original printGreeting() method

class MySubclass(MyClass):
    def printGreeting(self):
        print('Howdy')

myClass = MyClass(1)
mySubclass = MySubclass(1)
#+END_SRC

** Struct like classes

You can define an empty class and store data on that object (similar to C
structs)

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    pass

a = MyClass()
a.x = 1
a.y = 2

b = MyClass()
b.x = 3
b.y = 4
print(a.x)
print(a.y)
print(b.x)
print(b.y)
#+END_SRC

** Iterators

Most container classes (collections such as tuples, dictionairies, lists, etc.)
can be looped over using the ~for~ statement

#+BEGIN_SRC python :python python3 :results output
for element in [1, 2, 3]:
    print(element)
print()
for element in (1, 2, 3):
    print(element)
print()
for key in {'one':1, 'two':2}:
    print(key)
print()
for char in "123":
    print(char)
print()
for line in open("mymodule.py"):
    print(line, end='')
#+END_SRC

To support this the underlying class must provide a method called ~__iter__()~
which should return an iterator. The iterator should provide a method called
~__next__()~ which will access each element one at a time. When there are no
more elements the ~__next__()~ should throw a ~StopIteration~ exception. E.g.

The ~__next__()~ method can also be called using ~next()~. E.g.

#+BEGIN_SRC python :python python3 :results output
s = 'abc'
iterator = s.__iter__()
print(iterator.__next__())
print(iterator.__next__())
print(iterator.__next__())
#print(iterator.__next__()) #This line will throw a StopIteration exception
#+END_SRC

You can also call these methods using the built functions ~iter()~ and ~next()~

#+BEGIN_SRC python :python python3 :results output
s = 'abc'
iterator = iter(s)
print(next(iterator))
print(next(iterator))
print(next(iterator))
#print(next(iterator)) #This line will throw a StopIteration exception
#+END_SRC

We can simulate a ~for~ loop using a ~while~ loop using the ~iter~ and ~next~
functions

#+BEGIN_SRC python :python python3 :results output
my_list = [1, 2, 3, 4, 5]

the_iter = iter(my_list)
while True:
    try:
        val = next(the_iter)
        print(val)
    except StopIteration:
        break
#+END_SRC

In the example below the class provides both ~__iter__()~ and ~__next__()~. Thus
can the ~__iter__()~ method return itself. What's bad with this method is that
we can only iterate over that instance one time. Even if you would call the
~iter~ method again

#+BEGIN_SRC python :python python3 :results output
class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

for char in Reverse('Spam'):
   print(char)
#+END_SRC

** Generators

Generators can be used for creating something that resembles iterators. You
write them like regular functions but they use the ~yield~ statement whenever
they want to return data. Each time ~__next__()~ is called the generator will
continue where it left off until the next ~yield~ statement (there may be
multiple). Local variables are saved between calls and not reset. They will also
automatically raise a ~StopIteration~ exception when the generator terminates
(e.g. by reaching the end of the function or a ~return~ statement). E.g.

#+BEGIN_SRC python :python python3 :results output
def city_generator():
    yield("London")
    yield("Hamburg")
    yield("Konstanz")
    yield("Amsterdam")
    yield("Berlin")
    yield("Zurich")
    yield("Schaffhausen")
    yield("Stuttgart")

city = city_generator()
print(next(city))
print(next(city))
print(next(city))
print(next(city))
print(next(city))
print(next(city))
print(next(city))
print(next(city))
#print(next(city)) # Raises StopIteration exception
#+END_SRC

or

#+BEGIN_SRC python :python python3 :results output
def reverse(data):
    for index in range(len(data)-1, -1, -1): # Remember that the endpoint is not
                                             # generated (why we use -1)
        yield data[index]

for char in reverse('golf'):
    print(char)
#+END_SRC

An iterator can be used for everything that a generator can be used for but
generators will automatically generate ~__next__()~ and ~__iter__()~ methods.

Generators can't be reset so you should create a new generator instead.

*** Endless generators

We can define a generator which will always return new values

#+BEGIN_SRC python :python python3 :results output
def fibonacci():
    """Generates an infinite sequence of Fibonacci numbers on demand"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

f = fibonacci()

counter = 0
for x in f:
    print(x, " ", end="")
    counter += 1
    if (counter > 10):
        break
print()
#+END_SRC

*** Generators and the ~return~ statement

If you return a value using the ~return~ statement a ~StopIteration~ exception
will be raised with that value as message

#+BEGIN_SRC python :python python3 :results output
def city_generator():
    yield("London")
    yield("Hamburg")
    return "End of iteration"
    yield("Konstanz")

city = city_generator()
print(next(city))
print(next(city))
print(next(city))
#+END_SRC

You could also raise a ~StopIteration~ exception which would be the same (except
that the stacktrace would also print out a line for the line in the generator
where the exception was raised)

*** The ~send~ method

Generators will not only provide values but can also receive values using the
~send~ method. Note that when using the ~send~ method you will also receive the
value yielded by the generator.

The generator needs to be "started" before we can send a value to it (it needs
to reach at least the first ~yield~ statement).

A ~next~ call also sends and receives. It always sends ~None~ and in the example
below you can see both ~next~ and ~send~ in action

#+BEGIN_SRC python :python python3 :results output
def infinite_looper(objects):
    count = 0
    while True:
        if count >= len(objects):
            count = 0
        message = yield objects[count]
        if message != None:
            count = 0 if message < 0 else message
        else:
            count += 1

x = infinite_looper("A string with some words")
#print(x.send(9)) # Won't work as we haven't reached the first yield
print(next(x)) # Basically the same as x.send(None)
print(x.send(9))
print(x.send(10))
#+END_SRC

*** The ~throw~ method

The ~throw~ method raises an exception at the point where the generator was
paused, and returns the next value yielded by the generator. The generator has
to catch the passed-in exception, otherwise the exception will be propagated to
the caller.

In the following example we define our own exception (you could use any
exception) and when the exception is received in the generator the current
count will be printed.

#+BEGIN_SRC python :python python3 :results output
class StateOfGenerator(Exception):
     def __init__(self, message=None):
         self.message = message

def infinite_looper(objects):
    count = 0
    while True:
        if count >= len(objects):
            count = 0
        try:
            message = yield objects[count]
        except StateOfGenerator:
            print("index: " + str(count))
        if message != None:
            count = 0 if message < 0 else message
        else:
            count += 1

looper = infinite_looper("Python")
print(next(looper))
print(next(looper))
print(looper.throw(StateOfGenerator)) # Note that the next value is received here
print(next(looper))
#+END_SRC

*** Decorating generators

If we don't want to manually call ~next~ on a generator before we can use ~send~
to send a value we can write a decorator that will do that for us

#+BEGIN_SRC python :python python3 :results output
from functools import wraps

def get_ready(gen):
    """
    Decorator: gets a generator gen ready
    by advancing to first yield statement
    """
    @wraps(gen)
    def generator(*args,**kwargs):
        g = gen(*args,**kwargs)
        next(g)
        return g
    return generator

@get_ready
def infinite_looper(objects):
    count = -1
    message = yield None # This is where we will end up when calling next the first time
    while True:
        count += 1
        if message != None:
            count = 0 if message < 0 else message
        if count >= len(objects):
            count = 0
        message = yield objects[count]

x = infinite_looper("abcdef")
print(x.send(4))
print(next(x))
print(next(x))
print(x.send(5))
print(next(x))
#+END_SRC

*** The ~yield from~ statement

The ~yield from~ statement is used when you are returning objects from another
iterator (or a generator). The ~yield from~ will return values until the the
iterator encounters an ~StopIteration exception~. ~gen1~ and ~gen2~ will have
the same behaviour in the example below

#+BEGIN_SRC python :python python3 :results output
def gen1():
    for char in "Python":
        yield char
    for i in range(5):
        yield i

def gen2():
    yield from "Python"
    yield from range(5)

g1 = gen1()
g2 = gen2()
print("g1: ", end=", ")
for x in g1:
    print(x, end=", ")
print("\ng2: ", end=", ")
for x in g2:
    print(x, end=", ")
#+END_SRC

The subgenerator can also return a value which will be returned by the
~yield from~ statement when the return has been reached

#+BEGIN_SRC python :python python3 :results output
def subgenerator():
    yield 1
    yield 2
    return 42

def delegating_generator():
    x = yield from subgenerator()
    print(x)

for x in delegating_generator():
    print(x)
#+END_SRC

*** A generator of generators

You can for example create a generator to fetch the first n objects from a
generator which creates an infinite sequence

#+BEGIN_SRC python :python python3 :results output
def fibonacci():
    """Ein Fibonacci-Zahlen-Generator"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

def firstn(g, n):
	for i in range(n):
		yield next(g)

print(list(firstn(fibonacci(), 10)))
#+END_SRC

Running only ~list(fibonacci())~ wont work

*** Generator expressions

Some simple generators can be coded as expressions using a syntax similar to
list comprehensions but with parentheses instead of square brackets. Generator
expressions are more compact but less versatile than full generator definitions
and tend to be more memory friendly than equivalent list comprehensions.

The difference between a generator expression and a list comprehension is that a
generator expression returns a generator which will return new objects on
request while the list comprehension will return a list with all objects already
populated

#+BEGIN_SRC python :python python3 :results output
print(sum(i*i for i in range(10)))
print()

xvec = [10, 20, 30]
yvec = [7, 5, 3]
print(sum(x*y for x,y in zip(xvec, yvec)))
print()

from math import pi, sin
# Is this really a generator expression?
sine_table = {x: sin(x*pi/180) for x in range(0, 91)}
print(sine_table)
print()

data = 'golf'
print(list(data[i] for i in range(len(data)-1, -1, -1)))
#+END_SRC

* Errors and Exception
** Handling exceptions

The example below will throw a ~ValueError~ (as ~x~ is not an interger).

#+BEGIN_SRC python :python python3 :results output
x = 'x'
i = int(x)
print('Done')
#+END_SRC

We can catch the exception using the ~try~ clause

#+BEGIN_SRC python :python python3 :results output
x = 'x'
try:
    i = int(x)
except ValueError:
    print('Exception caught')
print('Done')
#+END_SRC

You can use multiple ~except~ clauses

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

for cls in [A, B]:
    try:
        raise cls
    except A:
        print('Exception caught: A')
    except B:
        print('Exception caught: B')
#+END_SRC

You can also catch several different exceptions in one ~except~ clause using a
tuple

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

for cls in [A, B]:
    try:
        raise cls
    except (A, B):
        print('Exception caught')
#+END_SRC

You can also assign the caught exception in a variable using

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

for cls in [A, B]:
    try:
        raise cls
    except (A, B) as e:
        print('Exception caught:', type(e))
#+END_SRC

You can also add a wild card ~except~ clause in the end which will catch
everything which hasn't been caught

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

class C(Exception):
    pass

for cls in [A, B, C]:
    try:
        raise cls
    except (A, B) as e:
        print('Exception caught:', type(e))
    except:
        print('Unknown exception caught')
#+END_SRC

You can also raise the exception again after you have handled it

#+BEGIN_SRC python :python python3 :results output
try:
    1/0
except ZeroDivisionError as e:
    print('Exception caught')
    raise # The exception is raised again
    #raise e # In this case it looks like this line is added to the stack trace
#+END_SRC

You can also add an ~else~ clause to the ~try.. except~ statement that will only
be run if everything runs ok. It needs to be added after all ~except~ clauses

#+BEGIN_SRC python :python python3 :results output
try:
    1/0
except:
    print('1: Exception caught')
else:
    print('1: Exception not caught')

try:
    0/1
except:
    print('2: Exception caught')
else:
    print('2: Exception not caught')
#+END_SRC

An exception can also have associated attributes. The arguments are stored in a
data attribute called ~args~. The ~__str__()~ method is defined so you can print
the arguments directly

#+BEGIN_SRC python :python python3 :results output
try:
    raise Exception('spam', 'eggs')
except Exception as inst:
    print(type(inst))    # the exception instance
    print(inst.args)     # arguments stored in .args
    print(inst)          # __str__ allows args to be printed directly,
                         # but may be overridden in exception subclasses
    x, y = inst.args     # unpack args
    print('x =', x)
    print('y =', y)
#+END_SRC

** Raising exceptions

You can raise an exception by using the ~raise~ statement. You can call this
using an instance of an exception type (a class that derives ~Exception~) or by
passing a exception class itself. If you pass the class it will be implicitly
instantiated by calling the zero argument constructor

#+BEGIN_SRC python :python python3 :results output
raise ValueError
# is a shorthand for
raise ValueError()
#+END_SRC

As mentioned above, if you want to see if an exception was raised but don't
intend to handle it you can raise it with no argument in the ~except~ clause

#+BEGIN_SRC python :python python3 :results output
try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
#+END_SRC

** Define your own exception

You create your own exception by sub-classing the ~Exception~ class (directly
or indirectly). Exception classes can do anything another class can do but
should be kept simple. When creating modules which can raise several kinds of
errors a good practive is to create a base class for the exceptions defined in
that module. A convention is also to define names that end with /error/

#+BEGIN_SRC python :python python3 :results output
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    """Raised when an operation attempts a state transition that's not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    """

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
#+END_SRC

** Clean up using ~finally~ clause

The ~finally~ clause will always run when leaving the try statement. If there
was an uncaught exception or the exception was raised in an ~except~ clause or
the ~else~ clause then the exception will be raised again after the ~finally~
clause is completed.

#+BEGIN_SRC python :python python3 :results output
def divide(x, y):
    try:
        result = x / y
    except ZeroDivisionError:
        print("division by zero!")
    else:
        print("result is", result)
    finally:
        print("executing finally clause")

divide(2, 1)
divide(2, 0)
#divide("2", "1")
#+END_SRC

The ~finally~ clause will also be executed when the ~statement~ is left via e.g.
~break~, ~continue~ or ~return~

** Predefined clean-up actions

The following example will try to open a file and print its content to the
screen. The problem here is taht the file is not closed:

#+BEGIN_SRC python :python python3 :results output
for line in open("mymodule.py"):
    print(line, end="")
#+END_SRC

You can use the ~with~ statement to objects which provides predefined clean-up
actions. This ensures that the clean-up is always done even if an exception
occurs

#+BEGIN_SRC python :python python3 :results output
with open("mymodule.py") as f:
    for line in f:
        print(line, end="")
#+END_SRC

** Links

[[https://docs.python.org/3/library/exceptions.html][Exceptions]]

* Decorators
** Function decorators

You can decorate a function or class to modify its behaviour. In the case with
function decorators you will create a function that accepts a function as
argument and outputs a modified version of that function

#+BEGIN_SRC python :python python3 :results output
def our_decorator(func):
    def function_wrapper(x):
        print("Before calling " + func.__name__)
        func(x)
        print("After calling " + func.__name__)
    return function_wrapper

@our_decorator
def foo(x):
    print("Hi, foo has been called with " + str(x))

foo("Hi")
#+END_SRC

We can also decorate third party functions. We can't use the ~@~ sign but will
have to call our decorator ourselves

#+BEGIN_SRC python :python python3 :results output
from math import sin, cos

def our_decorator(func):
    def function_wrapper(x):
        print("Before calling " + func.__name__)
        res = func(x)
        print(res)
        print("After calling " + func.__name__)
    return function_wrapper

sin = our_decorator(sin)
cos = our_decorator(cos)

for f in [sin, cos]:
    f(3.1415)
#+END_SRC

The decorator above only works for functions which accepts exactly one argument.
Here is a more general function

#+BEGIN_SRC python :python python3 :results output
from random import random, randint, choice

def our_decorator(func):
    def function_wrapper(*args, **kwargs):
        print("Before calling " + func.__name__)
        res = func(*args, **kwargs)
        print(res)
        print("After calling " + func.__name__)
    return function_wrapper

random = our_decorator(random)
randint = our_decorator(randint)
choice = our_decorator(choice)

random()
randint(3, 8)
choice([4, 5, 6])
#+END_SRC

*** Check arguments with decorator

#+BEGIN_SRC python :python python3 :results output
def argument_test_natural_number(f):
    def helper(x):
        if type(x) == int and x > 0:
            return f(x)
        else:
            raise Exception("Argument is not an integer")
    return helper

@argument_test_natural_number
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

for i in range(1,10):
	print(i, factorial(i))

try:
    print(factorial(-1))
except Exception as e:
    print('Exception caught:', e)
#+END_SRC

*** Counting the number of calls

#+BEGIN_SRC python :python python3 :results output
def call_counter(func):
    def helper(*args, **kwargs):
        helper.calls += 1
        return func(*args, **kwargs)
    helper.calls = 0
    return helper

@call_counter
def succ(x):
    return x + 1

print(succ.calls)
for i in range(10):
    succ(i)

print(succ.calls)
#+END_SRC

*** Decorator to cache result

#+BEGIN_SRC python :python python3 :results output
def memoize(f):
    memo = {}
    def helper(x):
        if x not in memo:
            memo[x] = f(x)
        return memo[x]
    return helper

@memoize
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

print(fib(40))
#+END_SRC

*** Decorators with parameters

If you want your decorator function to accept parameters you can define a
function which returns a decorator function

#+BEGIN_SRC python :python python3 :results output
def greeting(expr):
    def greeting_decorator(func):
        def function_wrapper(x):
            print(expr + ", " + func.__name__ + " returns:")
            func(x)
        return function_wrapper
    return greeting_decorator

@greeting("HallÃ¥")
def foo(x):
    print(42)

@greeting("Hi")
def bar(x):
    print(43)

foo(1)
bar(2)
#+END_SRC

*** Prevent decorate from overriding ~__name__~, ~__doc__~ and ~__module__~ variables

~__name__~, ~__doc__~ and ~__module__~ will be overridden when using decorators.
We can solve this problem by write to these variables ourselves

#+BEGIN_SRC python :python python3 :results output
def greeting(func):
    def function_wrapper(x):
        """ function_wrapper of greeting """
        print("Hi, " + func.__name__ + " returns:")
        return func(x)
    function_wrapper.__name__ = func.__name__
    function_wrapper.__doc__ = func.__doc__
    function_wrapper.__module__ = func.__module__
    return function_wrapper
#+END_SRC

We don't have to do this for every decorator since there is a decorator for this
called ~wraps~ in the ~functools~ module

#+BEGIN_SRC python :python python3 :results output
from functools import wraps

def greeting(func):
    @wraps(func)
    def function_wrapper(x):
        """ function_wrapper of greeting """
        print("Hi, " + func.__name__ + " returns:")
        return func(x)
    return function_wrapper
#+END_SRC

* Other
** Regular expressions

#+BEGIN_SRC python :python python3 :results output
import re

print(re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest'))
print(re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat'))
#+END_SRC

When simple substitutions are done you can use the ~replace~ method instead

#+BEGIN_SRC python :python python3 :results output
print('tea for too'.replace('too', 'two'))
#+END_SRC

** Execute scripts in linux

You can execute python scripts like other shell scripts by putting the line

#+BEGIN_SRC
#!/usr/bin/env python3
#+END_SRC

in the header. E.g.

#+BEGIN_SRC python :python python3 :results output
#!/usr/bin/env python3

print("Hello world!")
#+END_SRC

* Example programs
** Read command line arguments

#+BEGIN_SRC python :python python3 :results output :preamble import sys; sys.argv = ["1","2","a"]
# In the header of this block we have redefined sys.argv
import sys

print(len(sys.argv))
for arg in sys.argv:
    print(arg)
#+END_SRC

** Print to stderr

#+BEGIN_SRC python :python python3 :results output
import sys;
sys.stdout.write('Warning, log file not found starting a new one\n')
sys.stderr.write('Warning, log file not found starting a new one\n')
#+END_SRC

* The ~pip~ command

You can use ~pip~ to install, upgrade or remove packages. By default ~pip~ will
install packages from the Python Package Index ([[https://pypi.org]]).

You can run ~pip~ in the Python repl or directly in the terminal by

#+BEGIN_SRC bash :results output
python3 -m pip search astronomy
#+END_SRC

You can install the latest version of a package by specifying the package name

#+BEGIN_SRC bash :results output
python3 -m pip install <package-name>
# E.g. python3 -m pip install novas
#+END_SRC

You can also install a specific version of a package by giving the package name
followed by ~==~ and the version of the package you're interested in

#+BEGIN_SRC bash :results output
python3 -m pip install <package-name>==<package-version>
# E.g. python3 -m pip install requests==2.6.0
#+END_SRC

If you want a different version of an already defined package you can just rerun
the command above with the other version. If you want to get the latest version
you can run

#+BEGIN_SRC bash :results output
python3 -m pip install --upgrade <package-name>
# E.g. python3 -m pip install --upgrade pip
#+END_SRC

To remove a package you can use the ~uninstall~ command followed by one or more
packages you wish to uninstall

#+BEGIN_SRC bash :results output
python3 -m pip uninstall <package>
# E.g. python3 -m pip uninstall novas
#+END_SRC

You can also display information about a package with the show command (must be
installed?)

#+BEGIN_SRC bash :results output
python3 -m pip show fros
#+END_SRC

To list the currently installed package on the machine (or in the current
[[https://docs.python.org/3/tutorial/venv.html][virtual environment]])

#+BEGIN_SRC bash :results output
python3 -m pip list
#+END_SRC

The ~freeze~ command will produce a similar list but the output will be
formatted the same way as ~pip install~ expects it

#+BEGIN_SRC bash :results output
python3 -m pip freeze
#+END_SRC

A common convention is to put the list in a ~requirements.txt~ file which you
ship your application with. A user can then install all the necessary packages
with the ~install -r~ command

#+BEGIN_SRC bash :results output
# Have not tested this code. Can it handle files outside repl?
python3 -m pip install -r requirements.txt
#+END_SRC

* Things that maybe isn't included in the tutorial

- Inner functions
- ~with~ keyword
- Formatted string literals
- ~exec~ method (run strings as commands?)

** Methods

- ~super()~
- ~getattr()~
- ~setattr()~
- ~delattr()~

* Links

- [[https://docs.python.org/3/library/index.html][The Python Standard Library]]
- [[https://docs.python.org/3/][Python documentation]]
- [[https://docs.python.org/3/reference/index.html#reference-index][The Python Language Reference]]
- [[https://pypi.org/][Python Package Index]]
- [[https://www.python.org/]]
- [[https://docs.python.org/3/library/functions.html][Built-in functions]]
- [[https://www.python.org/dev/peps/pep-0008/][Style guide]]
- [[https://docs.python.org/3.7/py-modindex.html][Module index]]
- [[https://www.python-course.eu/python3_course.php]]

* Cheat sheet

#+BEGIN_SRC
Python indexes and slices for a six-element list.
Indexes enumerate the elements, slices enumerate the spaces between the elements.

Index from rear:    -6  -5  -4  -3  -2  -1      a=[0,1,2,3,4,5]    a[1:]==[1,2,3,4,5]
Index from front:    0   1   2   3   4   5      len(a)==6          a[:5]==[0,1,2,3,4]
                   +---+---+---+---+---+---+    a[0]==0            a[:-2]==[0,1,2,3]
                   | a | b | c | d | e | f |    a[5]==5            a[1:2]==[1]
                   +---+---+---+---+---+---+    a[-1]==5           a[1:-1]==[1,2,3,4]
Slice from front:  :   1   2   3   4   5   :    a[-2]==4
Slice from rear:   :  -5  -4  -3  -2  -1   :
                                                b=a[:]
                                                b==[0,1,2,3,4,5] (shallow copy of a)
#+END_SRC

* Code to inspect

#+BEGIN_SRC python :python python3 :results output
s = "Toronto is the largest City in Canada"
t = "Python courses in Toronto by Bodenseo"
r = "".join(["".join(x) for x in zip(s,t)])
print(r)
print(r[::2])
print(r[1::2])
#+END_SRC

* Links to read

[[https://www.ast.cam.ac.uk/~rgm/dazle/software/dics/src/opdict.html]]
[[https://wiki.python.org/moin/HowTo/Sorting]]
[[https://julien.danjou.info/guide-python-static-class-abstract-methods/]]
[[https://docs.python.org/3/reference/datamodel.html#special-method-names]]

https://docs.python.org/3/
https://docs.python.org/3/library/index.html
https://docs.python.org/3/reference/index.html#reference-index
https://docs.python.org/3/library/functions.html#sorted
