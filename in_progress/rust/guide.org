* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#links][Links]]
  - [[#tutorials][Tutorials]]
  - [[#cargo][Cargo]]
  - [[#api][API]]
- [[#other-things-to-look-at][Other things to look at]]
- [[#getting-started][Getting started]]
  - [[#installation][Installation]]
  - [[#hello-world][Hello, World]]
  - [[#hello-cargo][Hello, Cargo]]
- [[#guessing-game][Guessing game]]
- [[#common-programming-concepts][Common Programming Concepts]]
  - [[#variable-and-mutability][Variable and Mutability]]
  - [[#data-types][Data Types]]
  - [[#functions][Functions]]
  - [[#comments][Comments]]
  - [[#control-flow][Control Flow]]
- [[#ownership][Ownership]]
  - [[#ownership-rules][Ownership rules]]
  - [[#the-string-type][The ~String~ type]]
  - [[#memory-and-allocation][Memory and allocation]]
  - [[#ownership-and-functions][Ownership and functions]]
  - [[#return-values-and-scope][Return Values and Scope]]
  - [[#references-and-borrowing][References and Borrowing]]
  - [[#the-slice-type][The slice type]]
- [[#structs][Structs]]
  - [[#struct-update-syntax][Struct update syntax]]
  - [[#destruct-tuples][Destruct tuples]]
  - [[#tuple-structs][Tuple structs]]
  - [[#unit-like-structs][Unit-like structs]]
  - [[#ownerships-of-struct-data][Ownerships of struct data]]
  - [[#an-example-with-structs][An example with structs]]
  - [[#methods][Methods]]
- [[#enums-and-pattern-matching][Enums and pattern matching]]
  - [[#defining-an-enum][Defining an enum]]
  - [[#the-match-control-flow-construct][The ~match~ control flow construct]]
  - [[#concise-control-flow-with-if-let][Concise Control Flow with ~if let~]]
- [[#debug][Debug]]
- [[#crates-and-dependencies][Crates and dependencies]]
- [[#documentation][Documentation]]
- [[#style-guide][Style guide]]
- [[#clippy][Clippy]]
- [[#misc][Misc]]
#+END_QUOTE

* Links
** Tutorials

- https://lborb.github.io/
- https://doc.rust-lang.org/book/
- https://github.com/rust-lang/rustlings/
- https://doc.rust-lang.org/stable/rust-by-example/

** Cargo

- https://doc.rust-lang.org/cargo/
- https://crates.io/

** API

- https://doc.rust-lang.org/std/index.html

* Other things to look at

- ~rustfmt~ command
- The prelude (a list of things that Rust automatically imports into every Rust
  program): https://doc.rust-lang.org/std/prelude/index.html

* Getting started
** Installation

https://doc.rust-lang.org/book/ch01-01-installation.html

#+BEGIN_SRC bash :noeval
curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh
cargo install rust-script # Run rust files as scripts. Needed for emacs babel
                          # Make sure the script is on your path afterwards!
rust-script --version
#+END_SRC

*** Update

Once Rust is installed via rustup, when a new version of Rust is released,
updating to the latest version is easy. From your shell, run the following
update script:

#+BEGIN_SRC bash :noeval
rustup update
#+END_SRC

*** Get documentation

The installation of Rust also includes a local copy of the documentation, so you
can read it offline. Run rustup doc to open the local documentation in your
browser.

#+BEGIN_SRC bash :noeval
rustup doc
#+END_SRC

This didn't work on my machine since [[https://stackoverflow.com/questions/55961953/access-denied-when-i-run-rustup-doc][firefox was installed with snap]] but I could
get it to work with:

#+BEGIN_SRC bash :noeval
google-chrome ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/index.html
#+END_SRC

** Hello, World

Files in rust are on the format ~program_name.rs~. Words should be separated with ~_~.

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
}
#+END_SRC

*** Compile it

Add the code from the file above in a file called ~hello_world.rs~, compile it
with ~rustc~ and execute the produced file, ~~hello_world~:

#+BEGIN_SRC bash :noeva
rustc hello_world.rs
./hello_world
#+END_SRC

*** Things to note

1. The main ~function~ is special: it is always the first code that runs in
   every executable Rust program. The first line declares a function named main
   that has no parameters and returns nothing. If there were parameters, they
   would go inside the parentheses, ~()~.
2. ~println!~ calls a Rust macro. If it called a function instead, it would be
   entered as ~println~ (without the ~!~). TODO: Link to macro section
3. Rust style is to indent with four spaces, not a tab. Run
   ~rustfmt hello_world.rs~ to format code according to the standard.

** Hello, Cargo

Cargo handles a lot of tasks for you, such as building your code, downloading
the libraries your code depends on, and building those libraries.

All code in this section is available in the [[file:001_hello_cargo][001_hello_cargo]] directory.

*** Creating a project

In a directory where you want to create a project, run:

#+BEGIN_SRC bash :noeval
cargo new hello_cargo
cd hello_cargo
#+END_SRC

This created the following file structure:

#+BEGIN_SRC
.
`-- hello_cargo
    |-- Cargo.toml
    `-- src
        `-- main.rsl
#+END_SRC

The ~Cargo.toml~ file looks like this:

#+BEGIN_SRC toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#+END_SRC

The ~[package]~ heading, is a section heading that indicates that the following
statements are configuring a package.

The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use.

The ~[dependencies]~ heading, is the start of a section for you to list any of
your project’s dependencies (known as /crates/ in Rust).

Cargo expects your source files to live inside the ~src~ directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code.

*** Building and Running a Cargo Project

To build the project, run the following command while standing in the
~hello_cargo~ directory:

#+BEGIN_SRC bash :noeval
cargo build
#+END_SRC

A file is then created in ~target/debug/hello_cargo~. Run it by running the
following command:

#+BEGIN_SRC bash :noeval
./target/debug/hello_cargo
#+END_SRC

The default build is a ~debug~ build and that's why the binary ends up in that
directory.

You may notice that ~cargo build~ also creates a ~Cargo.lock~ in the top level
directory. This file keeps track of the exact versions of dependencies in your
project. Cargo understands [[https://semver.org/][Semantic Versioning]]. If you specify the version
~0.8.3~ this is actually a shorthand for ~^0.8.3~, meaning any version that is
at least ~0.8.3~ but below ~0.9.0~. Between builds the ~Cargo.lock~ file will
guarantee that the same version is used until you explicitly upgrade the
version. You should never need to update this file manually. If you want to make
cargo to reevaluate the version (finding a suitable version at least ~0.8.3~ but
below ~0.9.0~) you can run:

#+BEGIN_SRC bash :noeval
cargo update
#+END_SRC

You can both compile and run the project in one step by running:

#+BEGIN_SRC bash :noeval
cargo run
#+END_SRC

Cargo will automatically figure out what needs to be recompiled and what doesn't.

If you only want to make sure that the project compiles but not actually compile
the project you can run:

#+BEGIN_SRC bash :noeval
cargo check
#+END_SRC

This is much faster than actually compiling the code during development.

*** Building for release

You maybe noticed that the compile binary ended up in ~target/debug~. This is
a development build. They are faster to compile but are not optimized. In order
to optimize the build (which will also increase the build time) you should run
the following command:

#+BEGIN_SRC bash :noeval
cargo build --release
# --release can be used with run as well
cargo run --release
#+END_SRC

This result will end up in ~target/release~ instead of ~target/debug~ now.

* Guessing game

Code and comments for the guessing game is located in [[file:002_guessing_game][002_guessing_game]].

* Common Programming Concepts
** Variable and Mutability

By default variables are immutable. The code below won't compile since you are
trying to reassign the value of an immutable variable.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

But mutability can be very useful. Variables are immutable only by default and
you can make them mutable by adding ~mut~ in front of the variable name. In
addition to allowing this value to change, ~mut~ conveys intent to future
readers of the code by indicating that other parts of the code will be changing
this variable’s value.

#+BEGIN_SRC rust :results output
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

*** Constants

Rust also supports constants using the ~const~ keyword. An immutable variable
and a constant are not exactly the same in Rust.

- You aren’t allowed to use ~mut~ with constants, they're always immutable.
- You declare constants using the ~const~ keyword instead of the ~let~ keyword
- The type of the value /must/ be annotated
- Constants can be declared in any scope, including the global scope
- Constants may be set only to a constant expression, not the result of a value
  that could only be computed at runtime

Rust’s naming convention for constants is to use all uppercase with underscores
between words.

#+BEGIN_SRC rust :results output
fn main() {
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
    println!("{}", THREE_HOURS_IN_SECONDS)
}
#+END_SRC

*** Shadowing

You can declare a new variable with the same name as a previous variable.
Rustaceans say that the first variable is /shadowed/ by the second, which means
that the second variable’s value is what the program sees when the variable is
used.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;

    // This is allowed even though the previous 'x' isn't mutable since this
    // actually creates a new variable 'x' that shadows the previous one
    let x = x + 1;

    {
        // Also this 'x' will shadow the previous 'x'
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x); // 12
    }

    // The inner shadowing end and 'x' returns to bering 6
    println!("The value of x is: {}", x);
}
#+END_SRC

A shadowing variable can also use a different type. E.g. maybe we want to store
a string with spaces (e.g. for indentation) as an integer instead, the following
code would be allowed:

#+BEGIN_SRC rust :results output
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

Using a mutable variable to achieve the same wouldn't work as that would change
the type of the variable:

#+BEGIN_SRC rust :results output
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

** Data Types

Rust is a statically typed language, meaning that all values in Rust is of a
certain data type and that they must be known at compile time. The compiler can
usually infer what type we want to use based on the value and how we use it. In
cases when many types are possible, we must add a type annotation, like this:

#+BEGIN_SRC rust :noeval
let guess: u32 = "42".parse().expect("Not a number!");
#+END_SRC

*** Scalar Types

A scalar type represents a single value. Rust has four primary scalar types:
- integers
- floating-point numbers
- booleans
- characters

**** Integer Types

Integer types in Rust:

| Length  | Signed  | Unsigned |
|---------+---------+----------|
| 8-bit   | ~i8~    | ~u8~     |
| 16-bit  | ~i16~   | ~u16~    |
| 32-bit  | ~i32~   | ~u32~    |
| 64-bit  | ~i64~   | ~u64~    |
| 128-bit | ~i128~  | ~u128~   |
| arch    | ~isize~ | ~usize~  |

the ~isize~ and ~usize~ types depend on the kind of computer your program is
running on: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on
a 32-bit architecture.

You can write integer literals in any of the forms shown in the table below.
Note that number literals that can be multiple numeric types allow a type suffix,
such as ~57u8~, to designate the type. Number literals can also use ~_~ as a
visual separator to make the number easier to read, such as ~1_000~, which will
have the same value as if you had specified ~1000~.

| Number literals  | Example       |
|------------------+---------------|
| Decimal          | ~98_222~      |
| Hex              | ~0xff~        |
| Octal            | ~0o77~        |
| Binary           | ~0b1111_0000~ |
| Byte (~u8~ only) | ~b'A'~        |

Integer types default to ~i32~. The primary situation in which you’d use ~isize~
or ~usize~ is when indexing some sort of collection.

***** Types must match

It looks like as if the types must match when performing arithmetic operations.
The following example will fail to compile as there is no way to add a variable
of type ~i32~ with another variable of type ~i64~.

#+BEGIN_SRC rust :results output
fn main() {
    let x: i32 = 8;
    let y: i64 = 15;
    let z = x + y;

    println!("x: {}", x);
    println!("y: {}", y);
    println!("z: {}", z);
}
#+END_SRC

***** Overflow

Compiling in debug mode will cause the program to /panic/ at runtime if
overflow occurs. When compiling with the ~--release~ flag, no such checks are
included and Rust will perform /two's complement wrapping/. Relying on integer
overflow’s wrapping behavior is considered an error.

To explicitly handle the possibility of overflow, you can use these families of
methods that the standard library provides on primitive numeric types:

- Wrap in all modes with the ~wrapping_*~ methods, such as ~wrapping_add~
- Return the ~None~ value if there is overflow with the ~checked_*~ methods
- Return the value and a boolean indicating whether there was overflow with the
  ~overflowing_*~ methods
- Saturate at the value’s minimum or maximum values with ~saturating_*~ methods

**** Floating-Point Types

Rust’s floating-point types are ~f32~ and ~f64~, which are 32 bits and 64 bits
in size, respectively. The default type is ~f64~ because on modern CPUs it’s
roughly the same speed as ~f32~ but is capable of more precision.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32

    println!("x: {}", x);
    println!("y: {}", y)
}
#+END_SRC

**** Numeric Operations

#+BEGIN_SRC rust :results output
fn main() {
    // addition
    let sum = 5 + 10;
    println!("sum: {}", sum);

    // subtraction
    let difference = 95.5 - 4.3;
    println!("difference: {}", difference);

    // multiplication
    let product = 4 * 30;
    println!("product: {}", product);

    // division
    let quotient = 56.7 / 32.2;
    // The following will fail since you can't divide a float with an int
    //let quotient = 56.7 / 32;
    // The following will work though
    //let quotient = 56.7 / 32f64;
    let floored = 2 / 3; // Results in 0. Integer division rounds down to the nearest integer
    println!("quotient: {}", quotient);
    println!("floored: {}", floored);

    // remainder
    let remainder = 43 % 5;
    println!("remainder: {}", remainder);
}
#+END_SRC

**** The Boolean Type

Boolean type in Rust has two possible values: ~true~ and ~false~. Booleans are
one byte in size. The boolean type in Rust is specified using ~bool~. For
example:

#+BEGIN_SRC rust :results output
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation

    println!("t: {}", t);
    println!("f: {}", f)
}
#+END_SRC

**** The Character Type

Rust’s ~char~ type is the language’s most primitive alphabetic type. ~char~
literals are specified with single quotes, as opposed to string literals, which
use double quotes.

#+BEGIN_SRC rust :results output
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';

    println!("c: {}", c);
    println!("z: {}", z);
    println!("heart_eyed_cat: {}", heart_eyed_cat);
}
#+END_SRC

Rust’s ~char~ type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII.

*** Compbound types

Compound types can group multiple values into one type. Rust has two primitive
compound types: tuples and arrays.

**** The Tuple Type

Tuples have a fixed length: once declared, they cannot grow or shrink in size.
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. Type annotation is
optional:

#+BEGIN_SRC rust :noeval
fn main() {
    let annotated_tup: (i32, f64, u8) = (500, 6.4, 1);
    let unannotated_tup = (500, 6.4, 1);
}
#+END_SRC

To get the individual values out of a tuple, we can use pattern matching to
destructure a tuple value, like this:

#+BEGIN_SRC rust :results output
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+END_SRC

In the example above we clearly only cared about ~y~ so it's unnecessary to
create ~x~ and ~z~ as well. We can use ~_~ as a placeholder for unused values:

#+BEGIN_SRC rust :results output
fn main() {
    let tup = (500, 6.4, 1);
    let (_, y, _) = tup;

    println!("The value of y is: {}", y);
}
#+END_SRC

In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (~.~) followed by the index of the value we
want to access. For example:

#+BEGIN_SRC rust :results output
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("five_hundred:   {}", five_hundred);
    println!("six_point_four: {}", six_point_four);
    println!("one:            {}", one);
}
#+END_SRC

The tuple without any values, ~()~, is a special type that has only one value,
also written ~()~. The type is called the /unit type/ and the value is called
the /unit value/. Expressions implicitly return the unit value if they don’t
return any other value.

***** Mutable tuples

A tuple can be made mutable by adding the ~mut~ keyword. If you remove the ~mut~
keyword below, the compilation will fail

#+BEGIN_SRC rust :results output
fn main() {
    let mut x: (i32, f64, u8) = (500, 6.4, 1);
    x.0 = 400;
    let not_five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("not_five_hundred: {}", not_five_hundred);
    println!("six_point_four:   {}", six_point_four);
    println!("one:              {}", one);
}
#+END_SRC

**** The Array Type

Unlike a tuple, every element of an array must have the same type. Arrays in
Rust are different from arrays in some other languages because arrays in Rust
have a fixed length, like tuples. The length is defined at compile time. The
length of an array is part of its type.

In Rust, the values going into an array are written as a comma-separated list
inside square brackets:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
}
#+END_SRC

You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:

#+BEGIN_SRC rust :noeval
let a: [i32; 5] = [1, 2, 3, 4, 5];
#+END_SRC

Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [3; 5];
    let b = [3i64; 5]; // To define the type of the elements (in this case i64)
}
#+END_SRC

***** Accessing elements

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

If Rust knows at compile time that you are trying to access elements outside the
valid range, the compile will fail and you will get an error message. But checks
are done during run time as well so if you try to access an element outside the
valid range, the program will panic instead of allowing the program to access
the memory. Run the program in [[file:003_invalid_index][003_invalid_index]] for an example.

***** Mutable lists

Lists are immutable by default. You can make it mutable with the ~mut~ keyword

#+BEGIN_SRC rust :results output
fn main() {
    let mut a = [1, 2, 3, 4, 5];
    a[0] = 20;
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

** Functions

Rust code uses snake case as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+END_SRC

Function definitions in Rust start with ~fn~ and have a set of parentheses after
the function name. The curly brackets tell the compiler where the function body
begins and ends. Note that we defined ~another_function~ after the ~main~
function in the source code; we could have defined it before as well. Rust
doesn’t care where you define your functions, only that they’re defined
somewhere.

*** Function parameters

#+BEGIN_SRC rust :results output
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
#+END_SRC

In function signatures, you /must/ declare the type of each parameter. This is a
deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean.

Function with multiple paramaters:

#+BEGIN_SRC rust :results output
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+END_SRC

*** Function Bodies Contain Statements and Expressions

/Statements/ are instructions that perform some action and do not return a
value. /Expressions/ evaluate to a resulting value. Let’s look at some examples.

Creating a variable and assigning a value to it with the ~let~ keyword is a
statement. ~let y = 6;~ is a statement.

Statements do not return values. Therefore, you can’t assign a let statement to
another variable. E.g:

#+BEGIN_SRC rust :noeval
let x = (let y = 6); // Not valid code!
#+END_SRC

Expressions can be part of statements: the ~6~ in the statement ~let y = 6;~ is
an expression that evaluates to the value ~6~. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, ~{}~, is an expression, for example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let y = {
        let x = x + 3;
        x + 1
    };
    println!("The value of y is: {}", y);
}
#+END_SRC

The expression

#+BEGIN_SRC rust :noeval
let y = {
    let x = x + 3;
    x + 1
};
#+END_SRC

is a block that, in this case, evaluates to ~9~. That value gets bound to ~y~ as
part of the ~let~ statement. Note the ~x + 1~ line without a semicolon at the
end. Expressions do not include ending semicolons. If you add a semicolon to the
end of an expression, you turn it into a statement, which will then not return a
value. Keep this in mind as you explore function return values and expressions
next.

*** Functions with Return Values

Functions can return values to the code that calls them. We declare their type
after an arrow (~->~). In Rust, the return value of the function is synonymous
with the value of the final expression in the block of the body of a function.
You can return early from a function by using the ~return~ keyword and
specifying a value, but most functions return the last expression implicitly.

#+BEGIN_SRC rust :results output
fn five() -> i32 {
    5 // Note that there's no semi colon here
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
#+END_SRC

Another example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = plus_one(5);
    println!("The value of x is: {}", x);
    let y = plus_two(5);
    println!("The value of y is: {}", y);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}

fn plus_two(x: i32) -> i32 {
    // You are allowed to use 'return' to return early
    return x + 2 // Seems like the semi colon is optional here
}
#+END_SRC

**** Returning multiple values

You can always return a tuple if you want to:

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
#+END_SRC

** Comments

[[https://doc.rust-lang.org/reference/comments.html][Comments reference]]

Like in Java:

- Single line comments with ~//~
- Multi line comments starting with ~/*~ and ending with ~*/~

** Control Flow
*** ~if~ expressions

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+END_SRC

Blocks of code associated with the conditions in if expressions are sometimes
called /arms/. The ~else~ expression is optional.

It’s also worth noting that the condition in this code must be a ~bool~. If the
condition isn’t a ~bool~, we’ll get an error.

**** Handling Multiple Conditions with ~else if~

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+END_SRC

**** Using ~if~ in a ~let~ Statement

Because ~if~ is an expression, we can use it on the right side of a ~let~
statement:

#+BEGIN_SRC rust :results output
fn main() {
    let condition = true;
    // Notice the lack of semi colons inside the blocks. They are expressions!
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+END_SRC

Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the whole
~if~ expression depends on which block of code executes. This means the values
that have the potential to be results from each arm of the ~if~ must be the same
type. In the code above, the results of both the ~if~ arm and the ~else~ arm
were ~i32~ integers. If the types are mismatched we’ll get an error.

*** Repetition with Loops

Rust has three kinds of loops:

- ~loop~
- ~while~
- ~for~

**** The ~loop~ loop

The ~loop~ keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop. You can place the ~break~
keyword within the loop to tell the program when to stop executing the loop.

We can also use the ~continue~ keyword. The ~continue~ keyword within a loop
tells the program to skip over any remaining code in this iteration of the loop
and go to the next iteration.

If you have loops within loops, ~break~ and ~continue~ apply to the innermost
loop at that point. You can optionally specify a /loop label/ on a loop and then
use the label with ~break~ or ~continue~ to have those keywords applied to the
labeled loop instead of the innermost loop. Here’s an example with two nested
loops:

#+BEGIN_SRC rust :results output
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+END_SRC

The outer loop has the label ~'counting_up~ (you need to start the label with a
~'~), and it will count up from 0 to 2. The inner loop without a label counts
down from 10 to 9. The first ~break~ that doesn’t specify a label will exit the
inner loop only. The ~break 'counting_up;~ statement will exit the outer loop.

***** Returning values from loops

One of the uses of a ~loop~ is to retry an operation you know might fail, such
as checking whether a thread has completed its job. However, you might need to
pass the result of that operation to the rest of your code. To do this, you can
add the value you want returned after the ~break~ expression you use to stop the
loop; that value will be returned out of the loop so you can use it, as shown
here:

#+BEGIN_SRC rust :results output
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("The result is {}", result);
}
#+END_SRC

**** The ~while~ loop

A ~while~ loop works as one would expect. ~break~ and ~continue~ are also allowed.

#+BEGIN_SRC rust :results output
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+END_SRC

**** The ~for~ loop

The ~for~ loop can be used when looping over the elements of a collection. You
could do it with a ~while~ loop as well but it's more error prone (the index may
go out of bounds which will cause the program to panic if you enter the wrong
value) and less efficient (Rust adds a check that the index is within the bound
of the array on every iteration).

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+END_SRC

With the ~for~ loop:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
#+END_SRC

Even in situations in which you want to run some code a certain number of times,
as in the countdown example that used a ~while~ loop above, you can use a ~for~
loop. The way to do that would be to use a ~Range~, provided by the standard
library, which generates all numbers in sequence starting from one number and
ending before another number. ~rev~ reverses the range.

#+BEGIN_SRC rust :results output
fn main() {
    for number in (1..4).rev() {
    // Or
    //for number in (1..=3).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
#+END_SRC

* Ownership
** Ownership rules

Keep these rules in mind as we work through the examples that illustrate them:

- Each value in Rust has an owner.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.

** The ~String~ type

We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable.

When we want a mutable version, Rust has a second string type, ~String~. This
type manages data allocated on the heap and as such is able to store an amount
of text that is unknown to us at compile time. You can create a ~String~ from a
string literal using the ~from~ function and also modify the string:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`
}
#+END_SRC

Why can ~String~ be mutated but literals cannot? The difference is how these two
types deal with memory.

** Memory and allocation

In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.

With the ~String~ type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time, to
hold the contents. This means:

- The memory must be requested from the memory allocator at runtime.
- We need a way of returning this memory to the allocator when we’re done with
  our ~String~.

That first part is done by us: when we call ~String::from~, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.

However, the second part is different. In languages with a garbage collector,
the GC keeps track of and cleans up memory that isn’t being used anymore, and we
don’t need to think about it. In most languages without a GC, it’s our
responsibility to identify when memory is no longer being used and call code to
explicitly free it, just as we did to request it. Doing this correctly has
historically been a difficult programming problem. If we forget, we’ll waste
memory. If we do it too early, we’ll have an invalid variable. If we do it
twice, that’s a bug too. We need to pair exactly one ~allocate~ with exactly one
~free~.

Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. It's returned by Rust calling a special
function called ~drop~, and it’s where the author of of an object type (e.g
~String~) can put the code to return the memory.

*** Move

Multiple variables can interact with the same data in different ways in Rust.

#+BEGIN_SRC rust :results output
fn main() {
    let mut x = 5;
    let mut y = x;
    println!("{}", x);
    println!("{}", y);
    y = 6;
    println!("{}", x);
    println!("{}", y);
}
#+END_SRC

This has the expected behaviour. The variables are simple values with a known,
fixed size and are stored on the stack and the value is simply copied.

What happends with ~String~s?

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1);
    println!("{}", s2);
}
#+END_SRC

A ~String~ is made up of three parts: a pointer to the memory that holds the
contents of the string, a length, and a capacity. This group of data is stored
on the stack (fixed length). The memory on the heap holds the contents.

When we assign ~s1~ to ~s2~, the ~String~ data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to.

So like in other programming languages both strings would be pointing to the
same data on the heap.

So when one of these variables goes out of scope, what would happen? To ensure
memory safety, after the line ~let s2 = s1~, Rust considers ~s1~ as no longer
valid. Therefore, Rust doesn’t need to free anything when ~s1~ goes out of
scope. So the example above will actually now compile!

So what is happening in the example above is not a shallow copy. Because the
first variable is invalidated this is known as a /move/.

*** Clone

If we instead would want to also copy the heap we could use the ~clone~ method.
E.g.:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s1 = String::from("hello");
    let mut s2 = s1.clone();
    println!("{}", s1);
    println!("{}", s2);
    s2.push_str(", world!");
    println!("{}", s1);
    println!("{}", s2);
}
#+END_SRC

This creates two independeny memory areas on the heap with different owners.

*** Stack-Only Data: Copy

Rust has a special annotation called the ~Copy~ trait that we can place on types
that are stored on the stack, as integers are. If a type implements the ~Copy~
trait, variables that use it do not /move/, but rather are trivially copied,
making them still valid after assignment to another variable.

Rust won’t let us annotate a type with ~Copy~ if the type, or any of its parts,
has implemented the ~Drop~ trait. If the type needs something special to happen
when the value goes out of scope and we add the ~Copy~ annotation to that type,
we’ll get a compile-time error.

As a general rule, any group of simple scalar values can implement ~Copy~, and
nothing that requires allocation or is some form of resource can implement
~Copy~. Here are some of the types that implement ~Copy~:


- All the integer types.
- The Boolean type
- All the floating point types
- The character type
- Tuples, if they only contain types that also implement ~Copy~. For example,
  ~(i32, i32)~ implements ~Copy~, but ~(i32, String)~ does not.

** Ownership and functions

The mechanics of passing a value to a function are similar to those when
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does.

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...

    //println!("{}", s);            // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward
    println!("{}", x);

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
#+END_SRC

** Return Values and Scope

Returning values can also transfer ownership.

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3

    let mut s4 = String::from("hello"); // The following also works
    s4 = takes_and_gives_back(s4);
} // Here, s3 and s4 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
#+END_SRC

While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but not
take ownership? It’s quite annoying that anything we pass in also needs to be
passed back if we want to use it again, in addition to any data resulting from
the body of the function that we might want to return as well.

** References and Borrowing

A ~reference~ is like a pointer in that it’s an address we can follow to access
the data stored at that address; that data is owned by some other variable.
Unlike a pointer, a reference is guaranteed to point to a valid value of a
particular type for the life of that reference.

Here is how you would define and use a calculate_length function that has a
reference to an object as a parameter instead of taking ownership of the value:

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, it is not dropped.
#+END_SRC

Note that we pass ~&s1~ into ~calculate_length~ and, in its definition, we take
~&String~ rather than ~String~. These ampersands represent references, and they
allow you to refer to some value without taking ownership of it.

The ~&s1~ syntax lets us create a reference that refers to the value of ~s1~ but
does not own it. Because it does not own it, the value it points to will not be
dropped when the reference stops being used.

When functions have references as parameters instead of the actual values, we
won’t need to return the values in order to give back ownership, because we
never had ownership.

We call the action of creating a reference ~borrowing~. When you’re done, you
have to give it back. You don’t own it.

Just as variables are immutable by default, so are references. We’re not allowed
to modify something we have a reference to. The following code won't compile:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+END_SRC

*** Mutable references

We can fix the code from above to allow us to modify a borrowed value with just
a few small tweaks that use, instead, a ~mutable reference~:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello"); // change s to be mut

    change(&mut s); // create a mutable reference

    println!("{}", s);
}

fn change(some_string: &mut String) { // Change to accept a mutable reference wiht &mut
    some_string.push_str(", world");
}
#+END_SRC

The updated function signature will make it very clear that the change function
will mutate the value it borrows.

Mutable references have one big restriction: if you have a mutable reference to
a value, you can have no other references to that value. This code that attempts
to create two mutable references to ~s~ will fail:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}
#+END_SRC

The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It’s something
that new Rustaceans struggle with, because most languages let you mutate
whenever you’d like. The benefit of having this restriction is that Rust can
prevent data races at compile time. A data race is similar to a race condition
and happens when these three behaviors occur:

- Two or more pointers access the same data at the same time.
- At least one of the pointers is being used to write to the data.
- There’s no mechanism being used to synchronize access to the data.

Rust enforces a similar rule for combining mutable and immutable references.
This code results in an error:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
}
#+END_SRC

Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references, the ~println!~,
occurs before the mutable reference is introduced:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // variables r1 and r2 will not be used after this point
    // and the scope for those variables ends here

    let r3 = &mut s; // no problem
    println!("{}", r3);
}
#+END_SRC

*** Dangling references

A dangling pointer is a pointer that references a location in memory that may
have been given to someone else by freeing some memory while preserving a
pointer to that memory. In Rust, by contrast, the compiler guarantees that
references will never be dangling references: if you have a reference to some
data, the compiler will ensure that the data will not go out of scope before the
reference to the data does.

#+BEGIN_SRC rust :results output
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
#+END_SRC

Because ~s~ is created inside dangle, when the code of dangle is finished, ~s~
will be deallocated. But we tried to return a reference to it. That means this
reference would be pointing to an invalid ~String~. Rust won’t let us do this.

** The slice type

/Slices/ let you reference a contiguous sequence of elements in a collection
rather than the whole collection. A slice is a kind of reference, so it does not
have ownership.

*** String slices

A string slice is a reference to part of a ~String~, and it looks like this:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
    println!("{}", hello);
    println!("{}", world);
}
#+END_SRC

We create slices using a range within brackets by specifying
~[starting_index..ending_index]~. ~starting_index~ is inclusive and
~ending_index~ is exclusive. Internally, the slice data structure stores the
starting position and the length of the slice.

With Rust’s ~..~ range syntax, if you want to start at index zero, you can drop
the value before the two periods and if your slice includes the last index, you
can drop the trailing number.

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");

    let len = s.len();

    let start0 = &s[0..2];
    let start1 = &s[..2];

    let end0 = &s[5..len];
    let end1 = &s[5..];

    let full0 = &s[0..len];
    let full1 = &s[..];
}
#+END_SRC

Here's an example to get the first word of a ~String~:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");
    let fw = first_word(&s);
    println!("{}", fw);
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

This example includes an iteration which there will be more about later (TODO).

What if we try to modify the ~String~ which the slice is referencing?

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello world");
    let fw = first_word(&s);
    s.clear();
    println!("{}", fw);
    //s.clear(); // This clear would work since the immutable reference is out of scope
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

It won't compile! Recall from the borrowing rules that if we have an immutable
reference (e.g. a slice) to something, we cannot also take a mutable reference.
Because ~clear~ needs to truncate the ~String~, it needs to get a mutable
reference. The ~println!~ after the call to ~clear~ uses the reference in ~fw~,
so the immutable reference must still be active at that point.

*** String literals are slices

#+BEGIN_SRC rust :noeval
let s = "Hello, world!";
#+END_SRC

The type of ~s~ here is ~%str~: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; ~&str~ is an
immutable reference.

*** String slices as parameters

Knowing that you can take slices of literals and ~String~ values leads us to one
more improvement on ~first_word~, and that’s its signature:

#+BEGIN_SRC rust :noeval
fn first_word(s: &String) -> &str {
// Becomes
fn first_word(s: &str) -> &str {
#+END_SRC

This allows us to use the same function on both ~&String~ values and ~&str~
values. Defining a function to take a string slice instead of a reference to a
~String~ makes our API more general and useful without losing any functionality:

#+BEGIN_SRC rust :results output
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

*** Other slices

There’s a more general slice type, too. Consider this array:

#+BEGIN_SRC rust :noeval
let a = [1, 2, 3, 4, 5];
#+END_SRC

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3];
    assert_eq!(slice, &[2, 3]);
}
#+END_SRC

This slice has the type ~&[i32]~. It works the same way as string slices do, by
storing a reference to the first element and a length.

* Structs

Structs are similar to [[*The Tuple Type][tuples]], in that both hold multiple related values but in
a struct you’ll name each piece of data so it’s clear what the values mean.

To define a struct, we enter the keyword ~struct~ and name the entire struct.
Then, inside curly brackets, we define the /fields/. To define an /instance/ of
the struct in the following way (we don’t have to specify the fields in the same
order in which we declared them in the struct):

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
}
#+END_SRC

To get a specific value from a struct, we use dot notation. If the instance is
mutable, we can change a value by using the dot notation and assigning into a
particular field.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
#+END_SRC

Rust doesn’t allow us to mark only certain fields as mutable, so the instance
must be mutable. We can also construct a new instance of a struct as the last
expression of a function.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email: email, // Note the repetition!
        username: username, // Note the repetition!
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"));
}
#+END_SRC

The pattern above, that the parameter names and the struct field names are
exactly the same, we can use the /field init shorthand/ syntax to rewrite
~build_user~. Because the ~email~ field and the ~email~ parameter have the same
name, we only need to write ~email~ rather than ~email: email~.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email, // Repetition gone
        username, // Repetition gone
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"));
}
#+END_SRC

** Struct update syntax

It’s often useful to create a new instance of a struct that includes most of the
values from another instance, but changes some. You can do this using /struct
update syntax/. This how you would create a new instance with an updated ~email~
field without the syntax:

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
#+END_SRC

Using struct update syntax it would look like this (the result is the same
though).

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };

    let User {email: e, username: u, .. } = user2;
}
#+END_SRC

The ~..user1~ must come last to specify that any remaining fields should get
their values from the corresponding fields in ~user1~, but we can choose to
specify values for as many fields as we want in any order, regardless of the
order of the fields in the struct’s definition.

Why is it called an update when we still use the ~=~ operator like assignments?
It's because we [[*Move][move]] the data. We can no longer use ~user1~ after creating
~user2~ because the ~String~ in the ~username~ field of ~user1~ was moved into
~user2~. If we had given ~user2~ new ~String~ values for both ~email~ and
~username~, and thus only used the ~active~ and ~sign_in_count~ values from
~user1~, then ~user1~ would still be valid after creating ~user2~. The types of
~active~ and ~sign_in_count~ are types that implement the ~Copy~ trait.

** Destruct tuples

Like a tuple you can destruct a struct.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
}

fn main() {
    let user1 = User {
        username: String::from("someusername123"),
        active: true,
    };

    let User {username: u, active: a} = user1;
}
#+END_SRC

If you don't care about some fields you can omit them and add ~..~ as a
"filler":

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
}

fn main() {
    let user1 = User {
        username: String::from("someusername123"),
        active: true,
    };

    let User {active: a, ..} = user1;
}
#+END_SRC

** Tuple structs

Rust also supports structs that look similar to tuples, called /tuple structs/.
They don’t have names associated with their fields; rather, they just have the
types of the fields. These are useful when you want to give the whole tuple a
name and make the tuple a different type from other tuples.

You define them as a regular ~struct~ but leave out the name of the fields:

#+BEGIN_SRC rust :results output
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
#+END_SRC

Note that the ~black~ and ~origin~ values are different types, because they’re
instances of different tuple structs. A function that takes a parameter of type
~Color~ cannot take a ~Point~ as an argument. If we used regular tuples we could
feed both ~black~ and ~origin~ the the same functions.

Otherwise, tuple struct instances are similar to tuples in that you can
destructure them into their individual pieces, and you can use a ~.~ followed by
the index to access an individual value. ~_~ can be used as a placeholder for
unused values when destructing a struct tuple:

#+BEGIN_SRC rust :results output
struct Color(i32, i32, i32);

fn main() {
    let c = Color(0, 0, 0);
    let Color(r, _, _) = c;
    println!("{}", r)
}
#+END_SRC

** Unit-like structs

You can also define structs that don’t have any fields. These are called
unit-like structs because they behave similarly to ~()~, the unit type.

TODO: Why is this needed?

** Ownerships of struct data

In the examples above we have used the owned ~String~ type instead of the ~&str~
string slice type. This is a deliberate choice because we want each instance of
this struct to own all of its data and for that data to be valid for as long as
the entire struct is valid.

It’s also possible for structs to store references to data owned by something
else, but to do so requires the use of lifetimes (TODO).

** An example with structs

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let width = 30;
    let height = 50;
    let rect_tuple = (30, 50);
    let rect_struct = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_variables(width, height)
    );
    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_tuples(rect_tuple)
    );
    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_struct(&rect_struct)
    );
}

// Bad
fn area_with_variables(width: u32, height: u32) -> u32 {
    width * height
}

// Better
fn area_with_tuples(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}

// Best
fn area_with_struct(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
#+END_SRC

Borrowed struct. What if a type without copy trait?

** Methods

Rust allows structs, enums and traits to define methods and their first
parameter is always ~self~, which represents the instance of the struct the
method is being called on.

*** Defining methods

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
#+END_SRC

To define the function within the context of ~Rectangle~, we start an ~impl~
(implementation) block for ~Rectangle~. Everything within this ~impl~ block will
be associated with the ~Rectangle~ type.

In the signature for area, we use ~&self~ instead of ~rectangle: &Rectangle~ (as
in the example above). The ~&self~ is actually short for ~self: &Self~. Within
an ~impl~ block, the type ~Self~ is an alias for the type that the ~impl~ block
is for. Methods must have a parameter named ~self~ of type ~Self~ for their
first parameter, so Rust lets you abbreviate this with only the name ~self~ in
the first parameter spot. Note that we still need to use the ~&~ in front of the
self shorthand to indicate this method borrows the ~Self~ instance, just as we
did in ~rectangle: &Rectangle~. Methods can take ownership of ~self~, borrow
~self~ immutably as we’ve done here, or borrow ~self~ mutably, just as they can
any other parameter. If we wanted to change the instance that we’ve called the
method on as part of what the method does, we’d use ~&mut self~ as the first
parameter.

You are also allowed to give a method the same name as a structs fields. E.g.

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() { // The parentheses makes rust use the method and not the field
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
#+END_SRC

*** Automatic referencing and dereferencing

When you call a method with ~object.something()~, Rust automatically adds in
~&~, ~&mut~, or ~*~ so object matches the signature of the method. In other
words, the following are the same:

#+BEGIN_SRC rust :noeval
p1.distance(&p2);
(&p1).distance(&p2);
#+END_SRC

The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of ~self~.

*** Methods with more parameters

Working with more parameters works as one would expect

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn is_larger_than(&self, other: &Self) -> bool {
        self.area() > other.area()
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("rect1 is larger than rect2? {}", rect1.is_larger_than(&rect2));
    println!("rect1 is larger than rect3? {}", rect1.is_larger_than(&rect3));
}
#+END_SRC

*** Associated functions

All functions defined within an ~impl~ block are called /associated functions/
because they’re associated with the type named after the ~impl~. We can define
associated functions that don’t have ~self~ as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with.

Associated functions that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called ~new~, but
~new~ isn’t a special name and isn’t built into the language.

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let squared = Rectangle::square(3);
}
#+END_SRC

To call this associated function, we use the ~::~ syntax with the struct name.
This function is namespaced by the struct

*** Multiple ~impl~ blocks

Each struct is allowed to have multiple ~impl~ blocks. The following blocks are
equivalent. In this case, there’s no reason to separate these methods into
multiple ~impl~ blocks here, but this is valid syntax.

#+BEGIN_SRC rust :noeval
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+END_SRC

and

#+BEGIN_SRC rust :noeval
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+END_SRC

* Enums and pattern matching
** Defining an enum

To define am enum representing the different standards for IP addresses you
would define it like this:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}
#+END_SRC

~IpAddrKind~ is now a custom data type that we can use elsewhere in our code. We
can now create instances of each of the two variants of ~IpAddrKind~ and define
functions that takes any ~IpAddrKind~:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}

fn route(ip_kind: IpAddrKind) {}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(four);
    route(six);
}
#+END_SRC

To define the data associated with the enum you may be tempted to use enums in
combination with a struct, like this:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+END_SRC

But you can represent this using only enums. This new definition of the ~IpAddr~
enum says that both ~V4~ and ~V6~ variants will have associated ~String~ values:

#+BEGIN_SRC rust :results output
enum IpAddr {
    V4(String),
    V6(String)
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC

We attach data to each variant of the enum directly, so there is no need for an
extra struct (this is not possible in e.g. Java). Here it’s also easier to see
another detail of how enums work: the name of each enum variant that we define
also becomes a function that constructs an instance of the enum. That is,
~IpAddr::V4()~ is a function call that takes a ~String~ argument and returns an
instance of the ~IpAddr~ type. We automatically get this constructor function
defined as a result of defining the enum.

Each variant can have different types and amounts of associated data. If we
wanted to store ~V4~ addresses as four ~u8~ values but still express ~V6~
addresses as one ~String~ value, we wouldn’t be able to with a struct. Enums
handle this case with ease:

#+BEGIN_SRC rust :results output
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String)
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC

You can put any kind of data inside an enum variant: strings, numeric types,
structs, or another enum for example.

A more advanced example could look like this:

#+BEGIN_SRC rust :results output
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+END_SRC

This enum has four variants with different types:

- ~Quit~ has no data associated with it at all.
- ~Move~ has named fields like a struct does.
- ~Write~ includes a single ~String~.
- ~ChangeColor~ includes three ~i32~ values.

There is one more similarity between enums and structs: just as we’re able to
define methods on structs using ~impl~, we’re also able to define methods on
enums. Here’s a method named ~call~ that we could define on our ~Message~ enum:

#+BEGIN_SRC rust :results output
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+END_SRC

*** The ~Option~ enum

There is no ~null~ value in Rust, but it does have an enum that can encode the
concept of a value being present or absent. This enum is ~Option<T>~, and it is
[[https://doc.rust-lang.org/std/option/enum.Option.html][defined by the standard library]] library as follows:

#+BEGIN_SRC rust :results output
enum Option<T> {
    None,
    Some(T)
}
#+END_SRC

The ~Option<T>~ enum is so useful that it’s even included in the prelude. Its
variants are also included in the prelude: you can use ~Some~ and ~None~
directly without the ~Option::~ prefix. The ~Option<T>~ enum is still just a
regular enum, and ~Some(T)~ and ~None~ are still variants of type ~Option<T>~.

The ~<T>~ syntax is a generic type parameter. Here are some examples of using
~Option~ values to hold number types and string types:

#+BEGIN_SRC rust :results output
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
#+END_SRC

The type of ~some_number~ is ~Option<i32>~. The type of ~some_char~ is
~Option<char>~, which is a different type. Rust can infer these types because
we’ve specified a value inside the ~Some~ variant. For ~absent_number~, Rust
requires us to annotate the overall ~Option~ type: the compiler can’t infer the
type that the corresponding ~Some~ variant will hold by looking only at a ~None~
value.

~Option<T>~ is a different type than ~T~ so the following will fail:

#+BEGIN_SRC rust :results output
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;
#+END_SRC

When we have a value of a type like ~i8~ in Rust, the compiler will ensure that
we always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an ~Option<T>~ do we have to
worry about possibly not having a value, and the compiler will make sure we
handle that case before using the value. In other words, you have to convert an
~Option<T>~ to a ~T~ before you can perform ~T~ operations with it.

** The ~match~ control flow construct

~match~ allows you to compare a value against a series of patterns and then
execute code based on which pattern matches. The power of ~match~ comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.

Here's an example:

#+BEGIN_SRC rust :results output
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10, // Try remove one option
        Coin::Quarter => 25,
    }
}

let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let penny_cents = value_in_cents(Coin::Penny);
println!("{}", penny_cents);
#+END_SRC

The different options in a ~match~ expression are called the ~match~ arms. An
arm has two parts: a pattern and some code. The first arm here has a pattern
that is the value ~Coin::Penny~ and then the ~=>~ operator that separates the
pattern and the code to run. The code in this case is just the value ~1~. Each
arm is separated from the next with a comma.

The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire ~match~ expression.

We don’t typically use curly brackets if the match arm code is short, but if you
want to run multiple lines of code in a ~match~ arm, you must use curly
brackets, and the comma following the arm is then optional. E.g.

#+BEGIN_SRC rust :results output
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let penny_cents = value_in_cents(Coin::Penny);
println!("{}", penny_cents);
#+END_SRC

*** Patterns that bind to values

~match~ can bind to the parts of the values that match the pattern. This is how
we can extract values out of enum variants.

Let's add a ~UsState~ enum to the ~Quarter~ variant of our ~Coin~ enum:

#+BEGIN_SRC rust :results output
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state); // We use the derive(Debug) functionality here
            25
        }
    }
}
let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let quarter_cents = value_in_cents(Coin::Quarter(UsState::Alaska));
println!("{}", quarter_cents)
#+END_SRC

*** Matching with ~Option<T>~

The concept above can also be applied to ~Option<T>~. E.g.

#+BEGIN_SRC rust :results output
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
println!("{:?}", five);
let six = plus_one(five);
println!("{:?}", six);
let none = plus_one(None);
println!("{:?}", none);
#+END_SRC

*** Matches are exhaustive

In a ~match~ statement all patterns must be covered, otherwise it won't compile.
E.g.

#+BEGIN_SRC rust :results output
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        //None => None,
        Some(i) => Some(i + 1),
    }
}
#+END_SRC

Try to run the code above and see that the compilation fails.

*** Catch-all patterns and the ~_~ placeholder

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        other => println!("Just a {}...", other)
    }
}

print_number(3);
print_number(9);
print_number(7);
#+END_SRC

The code above compile even though we haven't covered all possible values a ~u8~
can have. This is because the last pattern will match all values not
specifically listed (the variable may be named anything, not just ~other~).

If we don't care about the "catch all" value we can use ~_~. By using this, the
value won't be bound to ~_~ and Rust won't warn us about an unused variable.

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        _ => println!("Just another value...")
    }
}

print_number(3);
print_number(9);
print_number(7);
#+END_SRC

But what if we don't want to do anything in the catch all scenario? Just use the
/unit value/, ~()~ (discussed in [[*The Tuple Type][The Tuple Type]] section).

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        _ => ()
    }
}

print_number(3);
print_number(9);
print_number(7);
#+END_SRC

** Concise Control Flow with ~if let~

If you only care about one value it may feel unnecessary to write code like
this:

#+BEGIN_SRC rust :results output
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
#+END_SRC

To satisfy the ~match~ expression, we have to add ~_ => ()~ after processing
just one variant, which is annoying boilerplate code to add. Instead we can use
~if let~ when we only want to process one single variant:

#+BEGIN_SRC rust :results output
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
#+END_SRC

Using ~if let~ means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that ~match~ enforces.

In other words, you can think of ~if let~ as syntax sugar for a ~match~ that
runs code when the value matches one pattern and then ignores all other values.

It's also allowed to use ~else~ with ~if let~. The block of code that goes with
the ~else~ is the same as the block of code that would go with the ~_~ case in
the ~match~ expression that is equivalent to the ~if let~ and ~else~.

#+BEGIN_SRC rust :results output
//let config_max = Some(3u8);
let config_max: Option<u8> = None;
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
} else {
    println!("No maximum value is defined");
}
#+END_SRC

* Debug

https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits

* Crates and dependencies

When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the registry, which is a copy of data from
[[https://crates.io/]]. crates.io is where people in the Rust ecosystem post their
open source Rust projects for others to use.

* Documentation

Another neat feature of Cargo is that you can run the command below, which will
build documentation provided by all of your dependencies locally and open it in
your browser.

#+BEGIN_SRC bash :noeval
cargo doc --open
#+END_SRC

* Style guide

https://doc.rust-lang.org/1.0.0/style/style/naming/README.html

* Clippy

https://doc.rust-lang.org/clippy/

* Misc

#+BEGIN_SRC rust :noeval
let apples = 5; // immutable
let mut bananas = 5; // mutable
#+END_SRC
