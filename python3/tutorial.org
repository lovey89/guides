https://docs.python.org/3/
https://docs.python.org/3/library/index.html
https://docs.python.org/3/reference/index.html#reference-index
https://docs.python.org/3/library/functions.html#sorted


* Test code to check python versions

The ~python~ argument in the code block header accepts a path to your python
executable. I have both =python2= and =python3= in my path so that's why I can
write only the name of the executable. Evaluate the code by placing the cursor
inside the code block and press ~C-c C-c~

The following code block evaluates python2 code:

#+BEGIN_SRC python :python python2 :results output
import sys
print(sys.version)
#+END_SRC

And this code block evaluates python3 code:

#+BEGIN_SRC python :python python3 :results output
import sys
print(sys.version)
#+END_SRC

* Basics
** Types

#+BEGIN_SRC python :python python3 :results output
print("Integer:", 3)
print("Float:", 3.0)
print("Float:", 3.1)
#+END_SRC

** Basic math

Mathematical operators

#+BEGIN_SRC python :python python3 :results output
print(1 + 2)
print(10 - 4)
print(4 * 5)
print(7 / 3)
print(10 / 2, "(The result of division is always a float)")
#+END_SRC

Integer division

#+BEGIN_SRC python :python python3 :results output
print(7 // 3)
print(7.0 // 2.9 , "(Also works on floats)")
print(10.0 // 3.3)
print(10.0 // 3.4)
print(-7 // 3, "(The result is always rounded down)")
print(-7.0 // 3.0)
#+END_SRC

Modulo

#+BEGIN_SRC python :python python3 :results output
print(7 % 3, "(Smallest positive integer)")
print(-7 % 3)
#+END_SRC

Exponentiation

#+BEGIN_SRC python :python python3 :results output
print(2 ** 4)
print(2.0 ** 4)
print(2 ** 4.0)
print(2.0 ** 4.0)
#+END_SRC

Change precedence

#+BEGIN_SRC python :python python3 :results output
print(1 + 2 * 3)
print((1 + 2) * 3)
#+END_SRC

** Comparisons

Boolean values (note capitalization)

#+BEGIN_SRC python :python python3 :results output
print(True)
print(False)
#+END_SRC

Negation

#+BEGIN_SRC python :python python3 :results output
print(not True)
print(not False)
#+END_SRC

Boolean operators (~and~ and ~or~)

#+BEGIN_SRC python :python python3 :results output
print(True and False)
print(True or False)
#+END_SRC

Boolean operators with integers

#+BEGIN_SRC python :python python3 :results output
print(0 and 2)    # 0
print(-5 or 0)    # -5
print(0 == False) # True
print(2 == True)  # False
print(1 == True)  # True
#+END_SRC

Equality symbol (~==~)

#+BEGIN_SRC python :python python3 :results output
print(1 == 1)
print(2 == 1)
#+END_SRC

Inequality operator (~!=~)

#+BEGIN_SRC python :python python3 :results output
print(1 != 1)
print(2 != 1)
#+END_SRC

Size comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 10)
print(1 > 10)
print(2 <= 2)
print(2 >= 2)
#+END_SRC

Chained comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 2 < 3)
print(2 < 3 < 2)
#+END_SRC

Lazy evaluation

#+BEGIN_SRC python :python python3 :results output
print(False and (5 / 0))
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
print(5 / 0) # Run as a comparison. This one fails
#+END_SRC

What different types evaluate to

#+BEGIN_SRC python :python python3 :results output
print(bool(0))
print(bool(0.0))
print(bool(""))
print(bool([])) # Empty list
print(bool({})) # Empty dictionairy
print(bool(())) # Empty tuple
print("Other values evaluate to True (this doesn't mean that they are equal to True as seen earlier)")
#+END_SRC

Equality (~==~) vs ~is~ operator
~is~ checks if two variables refer to the same object, but ~==~ checks if the
objects pointed to have the same values

#+BEGIN_SRC python :python python3 :results output
a = [1, 2, 3, 4]         # Point a at a new list, [1, 2, 3, 4]
b = a                    # Point b at what a is pointing to
print("b is a:", b is a) # => True, a and b refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
b = [1, 2, 3, 4]         # Point b at a new list, [1, 2, 3, 4]
print("b is a:", b is a) # => False, a and b do not refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
#+END_SRC

** Strings

Strings are surrounded with ~"~ or ~'~

#+BEGIN_SRC python :python python3 :results output
print("This is a string.")
print('This is also a string.')
#+END_SRC

Concatenation

#+BEGIN_SRC python :python python3 :results output
print("Hello " + "world!")
print("Hello " "world!") # Prefered way

# Put strings inside brackets to concatenate and put in variable (doesn't work with variables)
myString = ("Hello "
            "world!")
print(myString)
#+END_SRC

Treat it as a list of characters

#+BEGIN_SRC python :python python3 :results output
print("This is a string"[0])
#+END_SRC

Find the length of the string

#+BEGIN_SRC python :python python3 :results output
print(len("This is a string"))
#+END_SRC

Formatting string

#+BEGIN_SRC python :python python3 :results output
print("{} can be {}".format("Strings", "interpolated"))
print("{0} be nimble, {0} be quick, {0} jump over the {1}".format("Jack", "candle stick"))
print("{name} wants to eat {food}".format(name="Bob", food="lasagna"))
#+END_SRC

Raw strings

#+BEGIN_SRC python :python python3 :results output
print('\'Hello\nWorld\'')
print(r'\'Hello\nWorld\'') # print it exactly as it is written
#+END_SRC

Multi line string

#+BEGIN_SRC python :python python3 :results output
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
print("---")
# Add a '\' at the end and no trailing newline will be added
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to\
""")
print("---")
#+END_SRC

Repeating strings

#+BEGIN_SRC python :python python3 :results output
print("na " * 8 + "BATMAN")
#+END_SRC

** The ~None~ object

#+BEGIN_SRC python :python python3 :results output
print(None)
#+END_SRC

Compare with ~is~ operator instead of ~==~

#+BEGIN_SRC python :python python3 :results output
print('"etc" is None:', "etc" is None)
print('None is None:', None is None)
print('None == None', None == None)
#+END_SRC

** Variables

No need to declare variables before assigning to them. Convention is to use
lower_case_with_underscores

#+BEGIN_SRC python :python python3 :results output
some_var = 5
print("some_var:", some_var)
#+END_SRC

Accessing a previously unassigned variable raises an exception

#+BEGIN_SRC python :python python3 :results output
# The following error is intentional
some_unknown_var  # Raises a NameError
#+END_SRC

* Lists

Lists are mutable (tuples are not)

** Creating lists

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty list
li = []
print("li:", li)
# Or a prefilled list
prefilled_li = [4, 5, 6]
print("prefilled_li:", prefilled_li)
print("type([]):    ", type([]))
print("type([1,2]): ", type([1,2]))
#+END_SRC

** Add stuff to the end of the list

#+BEGIN_SRC python :python python3 :results output
li = []
print("li:", li)
li.append(1) # We have to do it in a separate step since this function only returns None (run help(list.append))
print("li:", li)
li.append(2)
print("li:", li)
li.append(4)
print("li:", li)
li.append(3)
print("li:", li)
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("li:       ", li)
print("li[0]:    ", li[0])
print("li[1]:    ", li[1])
# Negative index access elements counted from the end
print("li[-1]:   ", li[-1])
print("li[-2]:   ", li[-2])
print("li[2] = 5:")
li[2] = 5
print("li:       ", li)
#+END_SRC

** Remove (and return) from end with ~pop~

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
popped_value = li.pop()
print("popped_value:", popped_value)
print("li:", li)
# put it back with li.append
li.append(popped_value)
print("li:", li)
#+END_SRC

** Slicing with ~li[start:end(:step)]~

We will use a string as an example here. After all, a string is nothing other
than a tuple of characters. In the table below the dots are not included in the
string "Python" but will just point out the different "stops" of a index.

|  . | P |  . | y |  . | t |  . | h |  . | o |  . | n | . |
|----+---+----+---+----+---+----+---+----+---+----+---+---|
|  0 |   |  1 |   |  2 |   |  3 |   |  4 |   |  5 |   | 6 |
| -6 |   | -5 |   | -4 |   | -3 |   | -2 |   | -1 |   |   |

#+BEGIN_SRC python :python python3 :results output
pString = "Python"
print("pString[:] ", pString[:])
print("pString[3:]", pString[3:])
print("pString[:3]", pString[:3])
print("pString[1:5]", pString[1:5])
print("pString[::2]", pString[::2])
print("pString[1::2]", pString[1::2])
print("pString[:4:2]", pString[:4:2])
print("pString[1:5:3]", pString[1:5:3])
# And negative values
print("pString[-6:-1]", pString[-6:-1])
print("pString[::-1]", pString[::-1])
print("pString[-1:-6:-1]", pString[-1:-6:-1]) # Note that the start value now is
                                              # larger than end value
#+END_SRC

You can also update a list using slices

#+BEGIN_SRC python :python python3 :results output
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
print("letters:", letters)
letters[2:5] = ['C', 'D', 'E']
print("letters:", letters)
letters[2:5] = [] # The length can be changed
print("letters:", letters)
#+END_SRC

** Make a one layer deep copy using slices

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = li[:]
print("li: ", li)
print("li2:", li2)
print("li == li2:", li == li2) # Check for equality
print("li is li2:", li is li2) # Check if they are the same object
#+END_SRC

** Removing an element (~del~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("li:", li)
print("li[2]:", li[2])
del li[2]
print("li:", li)
print("li[2]:", li[2])
#+END_SRC

** Remove first occurence of a value (~remove~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.remove(2) # Calling this twice would result in a ValueError exception since 2 is not in the list
print("li:", li)
#+END_SRC

** Inserting an element in list (~insert~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.insert(1, 5) # At index 1 insert 5
print("li:", li)
#+END_SRC

** Get index of first occurence of a value (~index~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 2]
print("li.index(2):", li.index(2)) # A non existing value would raise an ValueError exception
#+END_SRC

** Concatenating lists (~+~ and ~extend~)

The following code will create a new list:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
print("li + li2:", li + li2) # The lists are not affected
print("li:      ", li)
print("li2:     ", li2)
#+END_SRC

This code will update list ~li~:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
li.extend(li2) # Now li has changed
print("li: ", li)
print("li2:", li2)
#+END_SRC

** Check for existence (~in~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("1 in li:", 1 in li)
print("7 in li:", 7 in li)
#+END_SRC

** Length of list (~len~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("len(li): ", len(li))
#+END_SRC

** Multidimensional lists

#+BEGIN_SRC python :python python3 :results output
matrix = [[1, 2, 3],['a', 'b', 'c']]
print(matrix[0][1]) # 2
#+END_SRC

* Tuples

Tuples are immutable. The mutable equivalent would be list

** Creating tuples

#+BEGIN_SRC python :python python3 :results output
print("tup = (1, 2, 3)")
tup = (1, 2, 3)
print("tup:       ", tup)
print("A one element long tuple needs comma after the last element:")
print("type((1)): ", type((1)))
print("type((1,)):", type((1,)))
print("type(()):  ", type(()))
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("tup[0]:", tup[0])
# tup[0] = 3 is not allowed (tuples are immutable) and would raise a TypeError exception
#+END_SRC

** List elements that also works on tuples

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("len(tup):       ", len(tup))
print("tup + (4, 5, 6):", tup + (4, 5, 6))
print("tup[:2]:        ", tup[:2])
print("2 in tup:       ", 2 in tup)
#+END_SRC

** Unpacking tuples (also lists)

The number of variables and values must match

#+BEGIN_SRC python :python python3 :results output
a, b, c = (1, 2, 3)
print("a:", a)
print("b:", b)
print("c:", c)
#+END_SRC

You can also use the asterisk to capture several variables

#+BEGIN_SRC python :python python3 :results output
a, *b, c = (1, 2, 3, 4) # Only one variable may use the asterisk
print("a:", a)
print("b:", b) # This will be a list
print("c:", c)
#+END_SRC

The paranthesis are not needed. Tuples are created by default

#+BEGIN_SRC python :python python3 :results output
d, e, f = 4, 5, 6
print("d:", d)
print("e:", e)
print("f:", f)
#+END_SRC

This makes it very easy to swap two values

#+BEGIN_SRC python :python python3 :results output
d = 4
e = 5
e, d = d, e
print("d:", d)
print("e:", e)
#+END_SRC

* Dictionairies
** Creating dictionairies

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty dictionairy
empty_dict = {}
print("empty_dict:       ", empty_dict)

# Or a prefilled dictionairy
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:      ", filled_dict)
print("type(filled_dict):", type(filled_dict))
#+END_SRC

The keys of the dictionairy needs to be of an immutable type (such as int,
float, string or tuple). This is because python needs to calculate hash values
for lookups. Values can be of any type.

#+BEGIN_SRC python :python python3 :results output
valid_dict = {(1,2,3):[1,2,3]}
print("valid_dict:", valid_dict)
# You are not limited to one type of key/value
other_valid_dict = {1: 2, "three": "four"}
print("other_valid_dict:", other_valid_dict)
#+END_SRC

** Look for existence of keys

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('"one" in filled_dict:', "one" in filled_dict)
print("1 in filled_dict:    ", 1 in filled_dict)
#+END_SRC

** Look for values (using keys)

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict["one"]:        ', filled_dict["one"])
# Looking up a non-existing key raises and KeyError. Use get instead
print('filled_dict.get("one"):    ', filled_dict.get("one"))
print('filled_dict.get("four"):   ', filled_dict.get("four")) # Not found so returns <None>
print('filled_dict.get("one", 4): ', filled_dict.get("one", 4))
print('filled_dict.get("four", 4):', filled_dict.get("four", 4)) # Not found so returns default value 4
#+END_SRC

** Get all keys and values

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict.keys():        ", filled_dict.keys())       # The order is non predictable
print("list(filled_dict.keys()):  ", list(filled_dict.keys())) # To get the result as a list
print("filled_dict.values():      ", filled_dict.values())     # The indexes seems to match for keys and values
print("list(filled_dict.values()):", list(filled_dict.values()))
#+END_SRC

** Adding value to dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
filled_dict["four"] = 5
print("filled_dict:", filled_dict)
# I don't see why I should use this method as the indexing version can both add and update
returnValue = filled_dict.update({"four":4}) # Always return None (not the previous value)
print("returnValue:", returnValue)
print("filled_dict:", filled_dict)
#+END_SRC

** Add value if it is not present

The method ~setdefault()~ is similar to ~get()~, but will set
~dict[key]=default~ if key is not already in dict.

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict.setdefault("five", 5):', filled_dict.setdefault("five", 5))
print("filled_dict:", filled_dict)
print('filled_dict.setdefault("five", 6):', filled_dict.setdefault("five", 6)) # Will still be 5
print("filled_dict:", filled_dict) # This list hasn't changed
#+END_SRC

** Remove key/value pair using key

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
del filled_dict["one"]
print("filled_dict:", filled_dict)
#+END_SRC

* Control flows
** if statement

#+BEGIN_SRC python :python python3 :results output :preamble def input(x): return 2
# In the header of this block we have redefined input as we can't run this interactively
x = int(input("Please enter an integer: "))

if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
#+END_SRC

** for statement

Iterates over any sequence and not only an arithmetic progression

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
#+END_SRC

Also supports ~else~ when it is exiting the ~for~ loop

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
else:
    print("exit")
#+END_SRC

~continue~ and ~break~ works as expected. If break is called the ~else~ clause
won't be called if it exists

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        continue
    print(w, len(w))
else:
    print("exit")
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        break
    print(w, len(w))
else:
    print("exit")
#+END_SRC

** while statement

Works as expected

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
#+END_SRC

Also supports ~else~

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
else:
    print("done")
#+END_SRC

~continue~ and ~break~ works the same as with ~for~ loops

** The ~range()~ function

Can be used when you need to iterate over an arethmetic progression. The endpoint is never generated

#+BEGIN_SRC python :python python3 :results output
for i in range(5):
    print(i) # Will print 0 to 4
#+END_SRC

You can define start and end point

#+BEGIN_SRC python :python python3 :results output
for i in range(5, 10):
    print(i)
#+END_SRC

And define a step size

#+BEGIN_SRC python :python python3 :results output
for i in range(0, 10, 3):
    print(i)
#+END_SRC

And also ranges with negative step

#+BEGIN_SRC python :python python3 :results output
for i in range(-10, -100, -30):
    print(i)
#+END_SRC

To iterate over the indices of a sequence, you can combine range() and len() as follows

#+BEGIN_SRC python :python python3 :results output
a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])
#+END_SRC


* Example programs
** Read command line arguments

#+BEGIN_SRC python :python python3 :results output :preamble import sys; sys.argv = ["1","2","a"]
# In the header of this block we have redefined sys.argv
import sys

print(len(sys.argv))
print(sys.argv[0])
print(sys.argv[1])
print(sys.argv[2])
#+END_SRC


