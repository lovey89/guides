* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#journalctl][journalctl]]
- [[#tar][tar]]
  - [[#main-operation-modes][Main operation modes]]
  - [[#examples][Examples]]
- [[#find][find]]
  - [[#options][Options]]
  - [[#use-find-together-with-the-xargs-command][Use ~find~ together with the ~xargs~ command]]
  - [[#example][Example]]
- [[#tcpdump][tcpdump]]
  - [[#example-1][Example]]
- [[#docker][Docker]]
  - [[#view-stdout-from-container][View stdout from container]]
- [[#ssh][ssh]]
  - [[#attach-to-tmux-on-connect][Attach to ~tmux~ on connect]]
  - [[#port-forwarding][Port forwarding]]
  - [[#reverse-port-forwarding][Reverse port forwarding]]
  - [[#setting-up-a-socks-proxy][Setting up a socks proxy]]
  - [[#handling-keys][Handling keys]]
- [[#dnf][dnf]]
  - [[#adding-a-repo][Adding a repo]]
- [[#disk-and-partition-info][Disk and partition info]]
  - [[#mounted-file-systems][Mounted file systems]]
  - [[#display-disk-information][Display disk information]]
- [[#rmlint][rmlint]]
  - [[#finding-and-deleting-empty-directories][Finding and deleting empty directories]]
- [[#sorting-photos][Sorting photos]]
  - [[#exiftool][Exiftool]]
  - [[#rapid-photo-downloader][rapid-photo-downloader]]
- [[#rsync][rsync]]
  - [[#copy-locally-eg-to-an-external-hard-drive][Copy locally (e.g. to an external hard drive)]]
  - [[#use-slash-in-the-end-or-not][Use slash in the end or not?]]
- [[#grub2-and-related][grub2 and related]]
#+END_QUOTE

* journalctl

See errors in the log from the last boot

#+BEGIN_SRC bash
journalctl -b -p err
#+END_SRC

* tar
** Main operation modes

| Flag | Description               |
|------+---------------------------|
| ~c~  | Create an archive         |
| ~x~  | Extract an archive        |
| ~t~  | Table of contents         |
| ~r~  | Append to exising archive |

** Examples
*** Create a tar (~.tar~)

#+BEGIN_SRC bash
tar -cf file.tar file1 file2 file3
#+END_SRC

It's important that the ~f~ flag is the last parameter as it accepts multiple
arguements. If you want to see what is put in the tar ball also use the verbose
flag, ~v~.

#+BEGIN_SRC bash
tar -cvf file.tar file1 file2 file3
#+END_SRC

Creating a tar is recursive (it accepts directories and it's content). Files
are by default not removed when a tar i created.

**** Extract

Use the ~x~ flag (extract) with ~f~ flag. ~v~ can optionally be used to see what
is extracted.

#+BEGIN_SRC bash
tar -xvf file.tar
#+END_SRC

*** Create a zipped tar (~.tar.gz~)

As above but also include the ~z~ flag for zipped files or ~j~ for ~.bz2~.

#+BEGIN_SRC bash
tar -cvzf files.tar.gz file1 file2 file3
#+END_SRC

**** Extract

As above but also include the ~z~ or ~j~ flag

#+BEGIN_SRC bash
tar -xzvf files.tar.gz
#+END_SRC

*** Add files to an already existing tar file

You should be able to use the command below with the ~v~ flag and ~z~ or ~j~
flags as well

#+BEGIN_SRC bash
tar -rf file.tar file1
#+END_SRC

*** List the files in a tar

I guess you can run this command with the ~z~ or ~j~ flags as well

#+BEGIN_SRC bash
tar -tf file.tar
#+END_SRC

* find

#+BEGIN_SRC bash
find <paths>.. options
#+END_SRC

** Options

| Option            | Description                                                                                                         |
|-------------------+---------------------------------------------------------------------------------------------------------------------|
| ~-print~          | The name of the found file is printed                                                                               |
| ~-name~ /pattern/ | Files that matches /pattern/ which is a glob so don't forget to escape it. Only matches name and not the whole path |
| ~-type~ /type/    | Match file of certain type. Examples of type are: ~d~ (directory), ~f~ (file) or ~l~ (symbolic link)                |
| ~-size~           | Size of the file. See man page                                                                                      |
| ~-mtime~          | When the file was modifiled. See man page                                                                           |
| ~-atime~          | When the file was accessed. See man page                                                                            |
| ~-user~           | Owned of file. The number is found in e.g. ~/etc/passwd~. See man page                                              |
| ~-group~          | Owning group of the file. The number is found in e.g. ~/etc/group~. See man page                                    |
| ~-perm~           | Files that have a set of permissions set. See man page                                                              |
| ~-ls~             | Almost as if you would run ~ls -l~ on the found file                                                                |
| ~-a~              | Logical /AND/ operator. Prio over ~-o~. Lazy evaluation. This is default if multiple options are provided           |
| ~-o~              | Logical /OR/ operator                                                                                               |
| ~!~               | Logical /NOT/. Put in front of the argument. E.g. ~find . \( -name a.out -a ! -type l \) -print~                    |

*** ~-exec~

Executes the command that follows. ~{}~ will be replaced with what the ~find~
command has found (you're only allowed to use it once). Maybe bash forces you to
escape those characters. The command needs to be terminated with a ~;~ (also
needs to be escaped). If you want to remove the group read permission for files
that have it set you can run the following command:

#+BEGIN_SRC bash
find . -perm -020 -exec chmod g-w {} ';'
#+END_SRC

The ~-exec~ option handles files with spaces in the name. If you want to confirm
that the command is to be executed first you can run find with the ~-ok~ option
instead of ~-exec~.

*** ~-prune~

Always returns true. If the currently investigated file is a directory the ~find~
command will not traverse it. The following command will print all files in a
directory but will not look at any files in any found directories:

#+BEGIN_SRC bash
find * -type f -print -o -type d -prune
#+END_SRC

** Use ~find~ together with the ~xargs~ command

~xargs~ executes it's commands as commands and also accepts arguments from stdin.

#+BEGIN_SRC bash
find / -print | xargs ls -ld
#+END_SRC

This would run ~ls -ld~ on all files in the file system.

To handle files with spaces you can make ~find~ output null terminated strings
and make ~xargs~ handle null terminated strings instead:

#+BEGIN_SRC bash
find / -print0 | xargs -0 ls -ld
#+END_SRC

** Example

#+BEGIN_SRC bash
alias efind='find -L . \( ! -name .git -a ! -name <dir_name> -o -prune \) -type f -print0 | xargs -0 grep --color=auto -in'
#+END_SRC

Here we see why it's important that ~-prune~ returns true. We won't search in
directories called ~.git~ and other directories which we can decide ourselves.
If such a directory is found we will end up in the ~prune~ and the content of
that directory will be ignored.

* tcpdump
** Example

#+BEGIN_SRC bash
tcpdump -c 2000 -s 0 -i eth0 -A -w dump.pcap
#+END_SRC

Catch only ~POST~ requests

#+BEGIN_SRC bash
tcpdump -c 2000 -s 0 -i eth0 -A -w dump.pcap '(tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354)'
#+END_SRC

Catch only from and to tcp port 80

#+BEGIN_SRC bash
tcpdump -c 2000 -s 0 -i eth0 -A -w dump.pcap 'tcp port 80'
#+END_SRC

More information about tcpdum and the filter can be found on the man pages for
[[https://www.tcpdump.org/manpages/tcpdump.1.html][tcpdump]] and [[https://www.tcpdump.org/manpages/pcap-filter.7.html][pcap-filter]].

* Docker
** View stdout from container

#+BEGIN_SRC bash
docker logs <containter_name> -f --tail 10
#e.g.
docker logs wiremock -f --tail 10
#+END_SRC

* ssh
** Attach to ~tmux~ on connect

The following command will when connecting to ~host~ attach to an existing tmux
session. If it doesn't exist it will create a new session and if that doesn't
work it will run bash

#+BEGIN_SRC
ssh user@host -t 'tmux a || tmux || /bin/bash'
#+END_SRC

** Port forwarding

** Reverse port forwarding

** Setting up a socks proxy

** Handling keys
* dnf

[[https://www.rootusers.com/25-useful-dnf-command-examples-for-package-management-in-linux/]]

| Command                                   | Description                                                                                           |
|-------------------------------------------+-------------------------------------------------------------------------------------------------------|
| ~dnf check-update~                        | Check for available updates for packages in enabled repositories                                      |
| ~dnf update package_name~                 | Update a specific package                                                                             |
| ~dnf update~                              | Update all packages                                                                                   |
| ~dnf update -x package_name~              | Update all packages except ~package_name~                                                             |
| ~dnf updateinfo list sec~                 | Install security updates only                                                                         |
| ~dnf install rpm-file.rpm~                | Install a ~.rpm~ file. Will also install dependencies (the ~rpm~ command won't do that)               |
| ~dnf remove package_name~                 | Uninstall package. Packages that depend on ~package_name~ will also be removed (you will be prompted) |
| ~dnf reinstall package_name~              | Reinstall a package. Similar to removing and then installing again                                    |
| ~dnf repolist~                            | View enabled repositories                                                                             |
| ~dnf repolist all~                        | View enabled and disabled repositories                                                                |
| ~dnf list installed~                      | List installed packages                                                                               |
| ~dnf clean all~                           | Clear cached information (the cached information is only used to speed up dnf)                        |
| ~dnf info package_name~                   | Shows detailed information about ~package_name~                                                       |
| ~dnf provides */iscsiadm~                 | Shows which package that provides the command ~iscsiadm~                                              |
| ~dnf provides /etc/httpd/conf/httpd.conf~ | Shows which package that provides a file                                                              |

** Adding a repo

We can specify a new repository by manually editing or creating a new ~.repo~
file in the ~/etc/yum.repos.d~ directory, however we can much more easily create
a persistent repository with the ~dnf config-manager~ command.

#+BEGIN_SRC bash
dnf config-manager --add-repo="https://mirror.aarnet.edu.au/pub/centos/7"
#+END_SRC

Which will create the file ~/etc/yum.repos.d/mirror.aarnet.edu.au_pub_centos_7.repo~

* Disk and partition info
** Mounted file systems

#+BEGIN_SRC bash
df -Th
# or
lsblk -f
#+END_SRC

** Display disk information

#+BEGIN_SRC bash
fdisk -l /dev/sda
#+END_SRC

* rmlint

To find duplicate file. The most common usages can be found [[https://rmlint.readthedocs.io/en/latest/tutorial.html][here]].

Note that nothing will be removed. ~rmlint~ will produce a ~rmlint.sh~ and
~rmlint.json~ files. When you execute ~rmlint.sh~ you will be shown some options
before the removal starts.

Find duplicates in the current directory

#+BEGIN_SRC bash
rmlint
#+END_SRC

Find duplicates in the current directory and determine that the first
alphabetical file in a group of conflicts is original.

#+BEGIN_SRC bash
rmlint -S a
#+END_SRC

To use last alpabetical as original you can user

#+BEGIN_SRC bash
rmlint -S A
#+END_SRC

Give multiple dirs to look inside instead of the current dir

#+BEGIN_SRC bash
rmline dir1 dir2
#+END_SRC

By default if there are conflicts found in ~dir1~ and ~dir2~ the file in ~dir1~
is considered to be original

** Finding and deleting empty directories

This is not an ~rmlint~ command but I put it here anyway. Find empty directories:

#+BEGIN_SRC bash
find . -type d -empty -print
#+END_SRC

Delete them (will recursively delete empty directories):

#+BEGIN_SRC bash
find . -type d -empty -delete
#+END_SRC

* Sorting photos
** Exiftool

Read and write meta information in files

*** Renaming images

[[https://exiftool.org/exiftool_pod.html#RENAMING-EXAMPLES]]

**** Move pictures to folder with capture date and name them the capture time

See [[https://superuser.com/a/695050][this]] answer

#+BEGIN_SRC bash
exiftool -r '-FileName<CreateDate' -d '%Y-%m-%d/%H_%M_%S%%-c.%%le' <yourFolder>
#+END_SRC

- ~-r~ is for recursion
- ~-FileName<CreateDate~ tells exiftool to rename the file accordingly to its EXIF tag ~CreateDate~
- ~-d %Y-%m-%d/%H_%M_%S%%-c.%%le~ tells how to build the filename string from the date source ~CreateDate~

The command will sort all files in the current directory and all sub directories
and place them in directories with the date of the day the file was created and
name the files the time when they were created. So the original directories will
be removed (if all files could be handled) and replaced with directories with
the date the images were captured. They will add numbers after the time stamp if
needed (because of collisions). If an EXIF file is not found (or not complete?)
the file will be left as it were.

**** Update picture name to capture date and time but don't move to other foler

#+BEGIN_SRC bash
exiftool -r '-FileName<CreateDate' -d '%Y_%m_%d-%H_%M_%S%%-c.%%le' <yourFolder>
#+END_SRC

This command doesn't include any slash in the argument for the ~-d~ option so
the files will be left in their original directories but the file names will be
updated (in this case the date and time is in the name).

**** Move all pictures in subdirs to current dir and update names to capture date and time

#+BEGIN_SRC bash
exiftool -r '-FileName<CreateDate' -d './%Y_%m_%d-%H_%M_%S%%-c.%%le' <yourFolder>
#+END_SRC

Move all the files from the subdirectories of ~yourFolder~ to ~yourFolder~ and
update the file names

**** Update names using capture date and current name

In the example my files are all named like

#+BEGIN_SRC
HH_MM_SS.jpg
# or
HH_MM_SS_optional_comment.jpg
#+END_SRC

I want to rename them to

#+BEGIN_SRC
yyyy_mm_dd-HH_MM_SS.jpg
# or
yyyy_mm_dd-HH_MM_SS_optional_comment.jpg
#+END_SRC

We need to make use of the /Advanced formatting feature/ (found in man pages)
which allows perl expressions to be run on a "variable"

In this case I don't add the lower case file ending (~%%le~) in the date format.
I remove the regex ~.._.._..~ from the beginning of the file name and keep the
rest.

#+BEGIN_SRC bash
exiftool -r '-FileName<${CreateDate}${filename;s/^.._.._..(.*)/$1/}' -d '%Y_%m_%d-%H_%M_%S%%-c' .
#+END_SRC

Note that this will only substitute part of the file name. If the file name
doesn't match ~^.._.._..(.*)~ nothing will be substituted and the file name will
be returned as is (and be appended to the capture date in the resulting file
name). If you want to replace a file not matching that regex with only it's file
extension you would have to do something like this:

#+BEGIN_SRC bash
exiftool -r '-FileName<${CreateDate}${filename;s/.*(\..*)/$1/ if not /^.._.._../;s/^.._.._..(.*)/$1/}' -d '%Y_%m_%d-%H_%M_%S%%-c' .
#+END_SRC

Files with no exif info (e.g. pictures from WhatsApp) seems to be not updated at
all.

**** Update names with parts of the directory name

In this example I have my files like this

#+BEGIN_SRC
yyyy-mm-dd/file.jpg
# or
yyyy-mm-dd_optional_comment/file.jpg
#+END_SRC

I want to rename them to

#+BEGIN_SRC
yyyy-mm-dd/yyyy_mm_dd-HH_MM_SS.jpg.jpg
# or
yyyy-mm-dd_optional_comment/yyyy_mm_dd-HH_MM_SS_optional_comment.jpg
#+END_SRC

Run this

#+BEGIN_SRC bash
exiftool -r '-FileName<${CreateDate}${directory;s/.*.{4}-.{2}-.{2}(.*)$/$1/g}${filename;s/.*(\..*)/lc($1)/e}' -d '%Y_%m_%d-%H_%M_%S%%-c' .
#+END_SRC

**** Change case in substitutions

To change to upper case use

#+BEGIN_SRC bash
s/.*/uc($1)/e
#+END_SRC

~e~ is used to execute functions in the second part of the substitution. To
change to lower case you use ~lc~ instead of ~uc~.

**** Available tags

[[https://exiftool.org/TagNames/Extra.html]]

Note that there is a writable tag called ~TestName~ that can be used for dry
runs. So use

#+BEGIN_SRC bash
exiftool -r '-TestName<CreateDate' -d '%Y-%m-%d/%H_%M_%S%%-c.%%le' <yourFolder>
#+END_SRC

instead of

#+BEGIN_SRC bash
exiftool -r '-FileName<CreateDate' -d '%Y-%m-%d/%H_%M_%S%%-c.%%le' <yourFolder>
#+END_SRC

It will print each files old name and new name without actually updating it

**** Variables in date string

See ~man strftime~

Additionally variables supported

- ~%d~ current directory of file
- ~%f~ current filename of file
- ~%e~ the file ending of file (extension)
- ~%c~ copy number. If we get duplicates of the date we will append a copy number

** rapid-photo-downloader

Was recommended this tool as well but haven't tested it myself

#+BEGIN_SRC bash
sudo dnf install rapid-photo-downloader
#+END_SRC

* rsync

[[https://www.thegeekstuff.com/2011/01/rsync-exclude-files-and-folders/?utm_source=feedburner]]

** Copy locally (e.g. to an external hard drive)

From [[https://serverfault.com/a/505758][this]] answer:

#+BEGIN_SRC
rsync -avhW --no-compress --progress src/ dst/
#+END_SRC

~-n~ to dry run

** Use slash in the end or not?

[[http://qdosmsq.dunbar-it.co.uk/blog/2013/02/rsync-to-slash-or-not-to-slash/]]

A trailing slash on the destination doesn't matter but it does for the source.
If you don't include a slash the directory and it's content is copied to the
destination folder. If you use a slash only the content of the source directory
will be copied to the destination directory

* grub2 and related

~grub2~ will try to boot from an /ESP partition/ which in linux will be mounted
on ~/boot/efi/~.

If you get problems with grub and you need to boot you system using the grub
command line you can follow [[https://fedoraproject.org/wiki/GRUB_2#Encountering_the_dreaded_GRUB_2_boot_prompt][this]] guide. Since I am running UEFI had to replace
the ~linux~ command with ~linuxefi~ and ~initrd~ with ~initrdefi~.

To see the boot order of the system you can use the ~efibootmgr -v~ command. On
my system the first option is:

#+BEGIN_SRC
Boot0000* fedora        HD(2,GPT,xxxxxxxx-yyyy-zzzz-aaaa-bbbbbbbbbbbb,0xe1800,0x32000)/File(\EFI\FEDORA\GRUBX64.EFI)
#+END_SRC

which in my case means ~/dev/sda2~ (notice the ~2~ after ~HD~). To verify that
this is actually the case run:

- Run ~gdisk /dev/sda~
- Choose ~i~ (show detailed information on a partition)
- Choose the partition you think is used (in my case ~2~)
- Verify that /Partition unique GUID/ is set to the guid above (~xxxxxxxx-yyyy-zzzz-aaaa-bbbbbbbbbbbb~)

In my case the computer booted with the wrong partiotion. I followed [[https://www.linuxbabe.com/command-line/how-to-use-linux-efibootmgr-examples][this]] guide
to add another boot entry.

I had to install ~grub2-efi-x64-modules~ using

#+BEGIN_SRC bash
sudo dnf install grub2-efi-x64-modules
#+END_SRC

and then run

#+BEGIN_SRC bash
sudo grub-install /dev/sda --target=x86_64-efi --efi-directory=/boot/efi/
#+END_SRC

This added a new boot entry on top when you ran ~efibootmgr -v~ and solved my
problem in the end
