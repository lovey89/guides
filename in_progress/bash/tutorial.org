* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#temp][Temp]]
- [[#special-constructs][Special constructs]]
- [[#special-variables][Special variables]]
- [[#parameter-expansion][Parameter expansion]]
- [[#the-if-statement][The ~if~ statement]]
  - [[#different-tests][Different tests]]
- [[#the-for-loop][The ~for~ loop]]
  - [[#examples][Examples]]
- [[#the-while-loop][The ~while~ loop]]
- [[#the-case-expression][The ~case~ expression]]
- [[#the-select-expression][The ~select~ expression]]
- [[#arrays][Arrays]]
  - [[#creation][Creation]]
  - [[#an-example-to-read-the-result-from-find-to-an-array][An example to read the result from ~find~ to an array]]
- [[#file-redirection][File redirection]]
- [[#pipes][Pipes]]
- [[#process-substitution][Process substitution]]
- [[#arithmetic-evaluation][Arithmetic evaluation]]
- [[#colors][Colors]]
- [[#other][Other]]
- [[#examples-1][Examples]]
  - [[#script-with-curl-having-a-json-body][Script with curl having a json body]]
  - [[#run-script-with-arguments-from-a-file][Run script with arguments from a file]]
  - [[#assigning-multiple-variables-at-once][Assigning multiple variables at once]]
#+END_QUOTE

* Temp

https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/

#+BEGIN_SRC bash :results output :shebang "#!/bin/bash\nset bon jour"
#!/bin/bash

# An example where the input variables are provided in the source block header

echo $1
echo $2
echo $1$2
echo $#
#+END_SRC

* Special constructs

| Construct                   | Description                                                                                                                                                                                                                                                                      |
|-----------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~$VAR~ or ~${VAR}~          | Substitutes the variable ~VAR~ with its value                                                                                                                                                                                                                                    |
| ~'text'~                    | All characters surrounded with the ~'~ will remain as they are. No variable substitution or escaping of characters                                                                                                                                                               |
| ~$'text'~                   | Like the one above but it is allowed to escape characters                                                                                                                                                                                                                        |
| ~”text”~                    | Everything surrouned in ~"~ will not be targeted for word splitting (will be kept as one argument). Variable substitution, arithmetic expansion and command substitutions is allowed. Globs are not allowed                                                                      |
| ~$(command)~ or ~`command`~ | Command substitution. Execute the command. Quotes within the parantheses are independent on parantheses which surrounds the commadn execution expression. So nesting is possible                                                                                                 |
| ~#comment~                  | A comment                                                                                                                                                                                                                                                                        |
| ~;~                         | Command separator if you want multiple commands on same line                                                                                                                                                                                                                     |
| ~\~                         | Escape character                                                                                                                                                                                                                                                                 |
| ~~~                         | Used for you home directory. Can also be used as ~~user~ for the home directory of the user ~user~                                                                                                                                                                               |
| ~{ commands; }~             | Group commands. Usefull if bash expects a command and you don't want to define a function. The last ~;~ seems important (unless you split up all commands on separate lines). Will be run in the same shell. A file redirect will affect all commands in the group. ~{..} >file~ |
| ~(command)~                 | Subshell execution. Run the command in new bash shell. If the command has any side effects (changed directory, changed variables), they won't affect the current shell. Commands can be separated with ~;~                                                                       |
| ~(( expression ))~          | Arithmetic command. Operators such as ~+~, ~-~, ~*~ and ~/~ are allowed. E.g. ~(( a=b+7 ))~ or ~if (( a < b ))~                                                                                                                                                                  |
| ~$(( expression ))~         | Arithmetic substitution. Like the previous but the whole expression will be replaced with the result. E.g. ~echo ”The average is $(( (a+b)/2 ))”~                                                                                                                                |
| ~command &~                 | The command will be executed in the background                                                                                                                                                                                                                                   |

* Special variables

| Variable           | Description                                                                                                        |
|--------------------+--------------------------------------------------------------------------------------------------------------------|
| ~"$0"~             | The name or the path of the running script                                                                         |
| ~"$1"~, ~"$2"~ ... | Argument to the script. /Positional parameters/. Also ~${10}~ and larger are available                             |
| ~"$*"~             | Expands to all words in all arguments. Separated by the first character in the ~IFS~ variable                      |
| ~"$@"~             | Expands all arguments to array. Imporant to put quotes around this variable to make each entry in the array quoted |
| ~$#~               | Number of set arguments                                                                                            |
| ~$?~               | The exit code of the last completed command running in the foreground                                              |
| ~$$~               | The PID of the current shell                                                                                       |
| ~$!~               | The PID for the last executed command in the background                                                            |
| ~$_~               | The last argument to the last command that was executed                                                            |

You can use the ~shift~ command to shift all positional parameters down one
step. I.e. ~$2~ becomes ~$1~, ~$3~ becomes ~$2~ etc.

* Parameter expansion

| Syntax                   | Description                                                                                                                                                                                           |
|--------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~${var:-word}~           | If ~var~ is unset or null this will expand to ~word~. Else to the value of ~var~                                                                                                                      |
| ~${var-word}~            | If ~var~ is unset this will expand to ~word~. Else to the value of ~var~                                                                                                                              |
| ~${var:=word}~           | If ~var~ is unset or null ~var~ will get the value ~word~. Then expand to the value of ~var~                                                                                                          |
| ~${var=word}~            | If ~var~ is unset ~var~ will get the value ~word~. Then expand to the value of ~var~                                                                                                                  |
| ~${var:+word}~           | If ~var~ is unset or null this will expand to null, else ~word~                                                                                                                                       |
| ~${var+word}~            | If ~var~ is unset this will expand to null, else ~word~                                                                                                                                               |
| ~${var:?word}~           | If ~var~ is unset or null, the expansion of ~word~ will be printer on stderr (or another message if ~word~ is absent) and the shell with exit with non zero exit code. Otherwise the value of ~var~   |
| ~${var?word}~            | If ~var~ is unset, the expansion of ~word~ will be printer on stderr (or another message if ~word~ is absent) and the shell with exit with non zero exit code. Otherwise the value of ~var~           |
| ~${var:offset:length}~   | Expand up to ~length~ characters of the value starting with ~offset~ (0 indexed). If ~length~ is absent, take everything until the end. If ~offset~ is negative (use parentheses), count from the end |
| ~${#var}~                | Expands to the number of characters of the value of ~var~                                                                                                                                             |
| ~${var#pattern}~         | ~pattern~ (glob) will match from the beginning of ~var~. Will expand to the value of ~var~ with the shortest match removed                                                                            |
| ~${var##pattern}~        | ~pattern~ (glob) will match from the beginning of ~var~. Will expand to the value of ~var~ with the longest match removed                                                                             |
| ~${var%pattern}~         | ~pattern~ (glob) will match from the end of ~var~. Will expand to the value of ~var~ with the shortest match removed                                                                                  |
| ~${var%%pattern}~        | ~pattern~ (glob) will match from the end of ~var~. Will expand to the value of ~var~ with the longest match removed                                                                                   |
| ~${var/pattern/string}~  | The first occurence of ~pattern~ (glob) in the value of ~var~ will be replaced with string                                                                                                            |
| ~${var//pattern/string}~ | All occurences of ~pattern~ (glob) in the value of ~var~ will be replaced with string                                                                                                                 |

#+BEGIN_SRC bash :results output
#!/bin/bash

var="a/b/c/d"
echo "${#var}"
echo "${var#*/}"
echo "${var##*/}"
echo "${var%/*}"
echo "${var%%/*}"
echo "${var/\//|}"
echo "${var//\//|}"

echo "${var2:-${var#*/}}" # Looks like we can nest
#+END_SRC

* The ~if~ statement

The basic form

#+BEGIN_SRC bash :results output
if test # Or a command
then
  # Code here
fi
#+END_SRC

or with ~else~ statements. E.g.

#+BEGIN_SRC bash :results output
if test # Or a command
then
  # Code here
elif test2
then
  # Code here
else
  # Code here
fi
#+END_SRC

** Different tests

See ~man test~ for more information. The spaces between the brackets and the
command is important since ~[~ is the ~test~ command

*** Files tests

| Expression            | Description                                |
|-----------------------+--------------------------------------------|
| ~[ -e file ]~         | True if ~file~ exists                      |
| ~[ -f file ]~         | True if ~file~ is a file (not a directory) |
| ~[ -d file ]~         | True if ~file~ is a directory              |
| ~[ -h file ]~         | True if ~file~ is a symbolic link          |
| ~[ -s file ]~         | True if ~file~ exists and is not empty     |
| ~[ -r file ]~         | True if ~file~ is readable                 |
| ~[ -w file ]~         | True if ~file~ is writable                 |
| ~[ -x file ]~         | True if ~file~ is executable               |
| ~[ -O file ]~         | True if ~file~ is owned by you             |
| ~[ -G file ]~         | True if ~file~ is owned by your group      |
| ~[ file1 -nt file2 ]~ | True if ~file1~ is newer than ~file2~      |
| ~[ file1 -ot file2 ]~ | True if ~file1~ is older than ~file2~      |

*** Numerical tests

| Expression      | Description                                |
|-----------------+--------------------------------------------|
| ~[ n1 -eq n2 ]~ | True if ~n1~ is equal to ~n2~              |
| ~[ n1 -ne n2 ]~ | True if ~n1~ is not equal to ~n2~          |
| ~[ n1 -lt n2 ]~ | True if ~n1~ less than ~n2~                |
| ~[ n1 -gt n2 ]~ | True if ~n1~ greater than ~n2~             |
| ~[ n1 -le n2 ]~ | True if ~n1~ less than or equal to ~n2~    |
| ~[ n1 -ge n2 ]~ | True if ~n1~ greater than or equal to ~n2~ |

*** String test

| Expression         | Description                               |
|--------------------+-------------------------------------------|
| ~[ str ]~          | True if ~str~ is not empty                |
| ~[ str1 = str2 ]~  | True if ~str1~ is equal to ~str2~         |
| ~[ str1 != str2 ]~ | True if ~str1~ is not equal to ~str2~     |
| ~[ -n str ]~       | True if ~str~ is longer than 0 characters |
| ~[ -z str ]~       | True if ~str~ is 0 characters long        |
| ~str1 < str2~      | String comparision                        |
| ~str1 > str2~      | String comparision                        |

When using ~[[~ instead of ~[~ you can use ~=~ or ~==~ to compare word with a
glob expression (the glob expression need to be on the right hand side).
Remember that if you surround the glob expression with quotes it can't be
treated like a glob. You can also compare a string with a regex with the ~=~~
operator like

#+BEGIN_SRC bash :results output
STRING =~ REGEX
#+END_SRC

#+BEGIN_SRC bash :results output
#!/bin/bash

filename="somefile.jpg"
if [[ $filename = *.jpg ]]; then
  echo "$filename is a jpeg"
else
  echo "$filename is not a jpeg"
fi
#+END_SRC

*** Boolean tests

| Expression                   | Description                                                                                                               |
|------------------------------+---------------------------------------------------------------------------------------------------------------------------|
| ~! EXPRESSION~               | True if ~EXPRESSION~ is false                                                                                             |
| ~EXPRESSION1 -o EXPRESSION2~ | Logical /or/. Both ~EXPRESSION1~ and ~EXPRESSION2~ will always be evaluated (no lazy evaluation)                          |
| ~EXPRESSION1 -a EXPRESSION2~ | Logical /and/. Both ~EXPRESSION1~ and ~EXPRESSION2~ will always be evaluated (no lazy evaluation). Has priority over ~-o~ |

The following will only work when we surround a test expression with ~[[~
instead of ~[~

| Expression                   | Description                                                                                                   |
|------------------------------+---------------------------------------------------------------------------------------------------------------|
| ~EXPRESSION1 ¦¦ EXPRESSION2~ | Like ~-o~ but ~EXPRESSION2~ will not be evaluated if ~EXPRESSION1~ evaluates to true                          |
| ~EXPRESSION1 && EXPRESSION2~ | Like ~-a~ but ~EXPRESSION2~ will not be evaluated if ~EXPRESSION1~ evaluates to false. Has priority over ~¦¦~ |
| ~( EXPRESSION )~             | To change priority. The spaces around the parantheses are important                                          |

*** Examples

#+BEGIN_SRC bash :results output
#!/bin/bash

test -e /etc/X11/xorg.conf && echo 'Your Xorg is configured!'
test -n "$HOME" && echo 'Your homedir is set!'
[[ boar != bear ]] && echo "Boars aren't bears."
[[ boar != b?ar ]] && echo "Boars don't look like bears."
[[ $DISPLAY ]] && echo "Your DISPLAY variable is not empty, you probably have Xorg running."
# The line below is commented out since the final result of that one is failing which gives problems for org mode
#[[ ! $DISPLAY ]] && echo "Your DISPLAY variable is not not empty, you probably don't have Xorg running."
#+END_SRC

#+BEGIN_SRC bash :results output
#!/bin/bash
# Program for moving files to a private garbage bucket.
# The garbage bucket is located to the hidden directory .garbage
# in the home directory
# Command: throw filename
if [[ "$#" -ne 1 ]]
  then
    echo "The command $0 should have only one argument, the file"
    echo "that should be deleted"
    exit 1
fi
echo "You have asked for moving the file $1 to the garbage bucket."
echo -n "Should the file be moved (yes/YES)? "
read answer
if [[ "$answer" = "yes" -o $answer = "YES" ]]
  then
    echo "The file has been moved to the garbage bucket"
    mv -f "$1" ~/.garbage
  else
    echo "The file is not moved to the garbage bucket"
fi
#+END_SRC

* The ~for~ loop

Comes in two forms. Like a for each loop:

#+BEGIN_SRC bash :results output
for variable in argument_list
do
  commands
done
#+END_SRC

And a more ~c~ like for loop with a start expression, test expression and next
step expression

#+BEGIN_SRC bash :results output
for ((expression1, expression2, expression3)) #Som i c
do
  commands
done
#+END_SRC

** Examples

#+BEGIN_SRC bash :results output
#!/bin/bash

echo "Linux distributions:"
for distro in mandrake redhat suse debian caldera
do
  echo "$distro"
done
echo "**** Finished *****"
#+END_SRC

#+BEGIN_SRC bash :results output
#!/bin/bash
for filename in `ls` # A glob or brace expression would fit better here
do
  if [ -d "$filename" ]
  then
    echo "Directory: $filename"
  fi
done
#+END_SRC

#+BEGIN_SRC bash :results output
for (( i=10; i > 0; i-- ))
do
  echo "$i empty cans of beer."
done
#+END_SRC

Which could be written as

#+BEGIN_SRC bash :results output
for i in {10..1}
do
  echo "$i empty cans of beer."
done
#+END_SRC

We can also read from a file

#+BEGIN_SRC bash :results output
for var in {a..c}; do
  read -r "$var"
done < <(echo -n 'cat
mouse
dog')
echo "$b"
echo "$c"
#+END_SRC

* The ~while~ loop

The basic form

#+BEGIN_SRC bash :results output
while test # Or a command
do
  # code here
done
#+END_SRC

The keywords ~continue~ and ~break~ both exist for both the ~for~ loop and the
~while~ loop. There is also an ~until~ loop which works exactly like the ~while~
loop but which negates the test result

* The ~case~ expression

An example

#+BEGIN_SRC bash :results output
#!/bin/bash

echo $LANG

case $LANG in
  en*) echo 'Hello!' ;;
  fr*) echo 'Salut!' ;;
  de*) echo 'Guten Tag!' ;;
  nl*) echo 'Hallo!' ;;
  it*) echo 'Ciao!' ;;
  es*) echo 'Hola!' ;;
  C|POSIX) echo 'hello world' ;;
  *)   echo 'I do not speak your language.' ;;
esac
#+END_SRC

Each choice consists of a pattern (or a ~|~ separated list of patterns), a
closing parenthesis, the code that is to be executed and two semicolons that
denotes the ~break~. The code and ~;;~ can be written on multiple lines. It
looks like the ~;;~ needs to be there for each line and that bash doesn't
support fall through.

The example above on multiple lines (removed some options to shorten the code):

#+BEGIN_SRC bash :results output
#!/bin/bash

echo $LANG

case $LANG in
  en*)
    echo 'Hello!'
    ;;
  fr*)
    echo 'Salut!'
    ;;
  C|POSIX)
    echo 'hello world'
    ;;
  *)
    echo 'I do not speak your language.'
    ;;
esac
#+END_SRC

* The ~select~ expression

An example (needs to be run as a script as it depends on input from the user)

#+BEGIN_SRC bash
#/bin/bash

echo "Which of these does not belong in the group?"
select choice in Apples Pears Crisps Lemons Kiwis
do
  if [[ $choice = Crisps ]]
  then
    echo "Correct!  Crisps are not fruit."
    break
  fi
  echo "Errr... no.  Try again."
done
#+END_SRC

The program above wil present the user with a list of all the alternatives
associated with a number. The variable (in this case ~choice~) will be set to
the value the user picked (or empty if the answer was not valid). The menu will
be deplayed until ~break~ is called

* Arrays

Arrays indices starts at 0 in bash

** Creation

#+BEGIN_SRC bash :results output
names=("Bob" "Peter" "$USER" "Big Bad John") # Fixed size
( IFS=,; echo "Today's contestants are: ${names[*]}" ) # Run in a subshell so IFS is not updated for rest of program
#+END_SRC

#+BEGIN_SRC bash :results output
names=([0]="Bob" [1]="Peter" [20]="$USER" [21]="Big Bad John")
( IFS=,; echo "Today's contestants are: ${names[*]}" )
#+END_SRC

#+BEGIN_SRC bash :results output
names[0]="Bob"
names[3]="$USER"
( IFS=,; echo "Today's contestants are: ${names[*]}" )
#+END_SRC

#+BEGIN_SRC bash :results output
files=($HOME/*) # Globs are permitted
( IFS=,; echo "Files in home dir are: ${files[*]}" )
#+END_SRC

#+BEGIN_SRC bash :results output
files=($(ls "$HOME")) # Not the recommended way since spaces in names may make thing difficult
( IFS=,; echo "Files in home dir are: ${files[*]}" )
#+END_SRC

#+BEGIN_SRC bash :results output
names=("Bob" "Peter" "$USER" "Big Bad John") # Fixed size
#names_copy=$names # Will only set the first element
names_copy=("${names[@]}")
( IFS=,; echo "Today's contestants are: ${names_copy[*]}" )
#+END_SRC

** An example to read the result from ~find~ to an array

~+=()~ will add one or more elements to the end of the array

#+BEGIN_SRC bash :results output
files=()
while read -r -d $'\0'; do # If you don't want to use null you can use $'\n' for newline and $'\t' for tab.. 
    files+=("$REPLY") # If you provide no variable to read the result will be put in REPLY
done < <(find $HOME -print0) # < for file redirection and <(..) for process substitution

echo "${files[0]}"
echo "${files[1]}"
#+END_SRC

* File redirection

| Syntax            | Description                                             |
|-------------------+---------------------------------------------------------|
| ~command > file~  | stdout to ~file~                                        |
| ~command 1> file~ | Same as above                                           |
| ~command < file~  | The content of ~file~ the command is reading from stdin |
| ~command 0< file~ | Same as above                                           |
| ~command 2> file~ | stderr ro ~file~                                        |

If the file already exists it will be emptied, otherwise it will be created. You
can use ~>>~ or ~2>>~ if you want to append on the file instead. Remember that
you can redirect to ~/dev/null~ if you're not interested in the result. You can
also redirect the content from loops, i.e. all the commands inside the loop

#+BEGIN_SRC bash :results output
for homedir in /path/*
do
  rm "$homedir/secret"
done 2> /dev/null
#+END_SRC

If you want to redirect stdout and stderr to the same file you will have to use
~2>&1~. E.g.

#+BEGIN_SRC bash :results output
grep proud file 'not a file' > proud.log 2>&1
#+END_SRC

stderr will now point to where stdout is pointing. The order is important. If
you don't use this syntax both stderr and stdout will point to the beginning of
the file and will overwrite eachother. ~1>&2~ is also permitted.

* Pipes

Used to redirect one commands stdout to another commands stdin. Each command
will be executed in its own subshell, i.e. variables that you change or
initialize will not be available for the other commands.

#+BEGIN_SRC bash :results output
message=Test
echo 'Salut, le monde!' | read message
echo "The message is: $message"
echo 'Salut, le monde!' | { read message; echo "The message is: $message"; }
echo "The message is: $message"
#+END_SRC

The example above uses anonymous pipes. You can also use named pipes by creating
a fifo file with the ~mkfifo~ command. This file can be read by a process and
written to by another process. A read operation will block as long as there is
nothing to be read. Same for writes (i.e. it will block as long as nobody is
reading). A fifo file will not contain any information on it's own.

* Process substitution

~<(..)~ runs the command in the parentheses and puts the result in a temporary
named pipe (or something like it) which then the file will look in. Good to use
if a command expects a file but you want to hand it the output from a command.

So instead of running the following commands

#+BEGIN_SRC bash :results output
head -n 1 .dictionary > file1
tail -n 1 .dictionary > file2
diff -y file1 file2
rm file1 file2
#+END_SRC

You can run

#+BEGIN_SRC bash :results output
diff -y <(head -n 1 .dictionary) <(tail -n 1 .dictionary)
#+END_SRC

which will leave no traces of temporary files. If you put ~echo~ in front of the
command you can see what happens

#+BEGIN_SRC
$ echo diff -y <(head -n 1 .dictionary) <(tail -n 1 .dictionary)
diff -y /dev/fd/63 /dev/fd/62
#+END_SRC

~>(..)~ can be used when a file writes it output to a file but you want to pass
the output to a command. E.g.

#+BEGIN_SRC bash :results output
tar -cf >(ssh host tar xf -) .
#+END_SRC

* Arithmetic evaluation

With the ~let~ keyword you can evaluate arithmetic expressions

#+BEGIN_SRC bash :results output
let a=4+5 # if you also put quotes around the expression you are allowed to use spaces
echo $a
#+END_SRC

See ~help let~ for a list of operands

You can also use ~((..))~ which is equivalent with the ~let~ keyword but which
can also be used in e.g. ~if~ statement

#+BEGIN_SRC bash :results output
((a=(5+2)*3))
#or
if (($a == 21)); then echo 'Blackjack!'; fi
# We don't need the $ since we expect variables in arithmetic contexts
if ((a == 21)); then echo 'Blackjack!'; fi
#+END_SRC

Arithmetic substitution is also possible with ~$((..))~

#+BEGIN_SRC bash :results output
a=4
b=8
echo "There are $(($a * $b)) cells"
# or
echo "There are $((a * b)) cells"
#+END_SRC

A few C features is also available. The ternary operator

#+BEGIN_SRC bash :results output
a=-4
echo $a
((abs = (a >= 0) ? a : -a))
echo $abs
#+END_SRC

And in ~if~ statement, if the value is ~0~ it is treated as ~false~ and
everything else if ~true~

#+BEGIN_SRC bash :results output
flag=5
if ((flag)); then echo "uh oh, our flag is up"; fi
#+END_SRC

* Colors

#+BEGIN_SRC bash :results output
#!/bin/bash

for i in {0..255} ; do
    printf "\x1b[38;5;${i}mcolour${i}\n"
done
#+END_SRC

* Other

When you run a command in Bash, you have the option of specifying a temporary
environment change which only takes effect for the duration of that command.
This is done by putting ~VAR=value~ in front of the command. In the example
below I open a new shell for demonstration

#+BEGIN_SRC bash :results output
bash -c 'echo "x is set to \"$x\" and y is set to \"$y\""'
x="x-value" y="y-value" bash -c 'echo "x is set to \"$x\" and y is set to \"$y\""'
bash -c 'echo "x is set to \"$x\" and y is set to \"$y\""'
#+END_SRC

* Examples
** Script with curl having a json body

#+BEGIN_SRC bash :results output :shebang "#!/bin/bash\nset input1 input2"
#!/bin/bash

ARG1="$1"
ARG2="$2"

PAYLOAD=$(cat << END_HEREDOC
{
   "field1": "Fixed value",
   "field2": "$ARG1",
   "field3": "$ARG2",
}
END_HEREDOC
)

# The echo should be removed of course
echo curl -X POST --header 'Content-Type: content-type' -d "$PAYLOAD" 'http://host:port/path/to/call'
#+END_SRC

** Run script with arguments from a file

#+BEGIN_SRC bash :results output
while read p; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n "First
second
third")
#+END_SRC

The example above will not process the last row as there is no ~\n~ on that row.
To overcome this problem you can use the following code

#+BEGIN_SRC bash :results output
while read p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading and trailing spaces  
third')
#+END_SRC

Now we have a problem that leading and trailing whitespaces are removed. This is
fixed by setting ~IFS~ to an empty string.

#+BEGIN_SRC bash :results output
while IFS="" read p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

Now the ~\~ on the third line is escaped. Add the ~-r~ option to ~read~ so
backslashes doesn't act as escape charactes

#+BEGIN_SRC bash :results output
while IFS="" read -r p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

Below is an example where we read 3 lines at a time and put each row in the
array variable ~ary~. I also added a helper function just so we can see what
each argument looks like. The newline character is not part of the variable
and all leading and trailing whitespaces are where they are supposed to be.
Also no characters are escaped. It will also read as many lines as possible
even if there is not enough to fill the wanted numbers of lines

#+BEGIN_SRC bash :results output
myfunc () {
  echo $#
  for var in "$@"
  do
    echo -n "\"$var\","
  done
  echo
}

while mapfile -t -n 3 ary && ((${#ary[@]})); do
  myfunc "${ary[@]}"
  printf '%s\n' "${ary[@]}"
  printf -- '--- SNIP ---\n'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

** Assigning multiple variables at once

Can be useful when using ~sed~ but here is a minimal example

#+BEGIN_SRC bash :results output
read VAR1 VAR2 <<< "  One   Two    Three  "

echo "$VAR1"
echo "$VAR2"
#+END_SRC

As you will notice from the example above all the text that doesn't get placed
in its own variable will be placed in the last variable

If you want to change the separator you can update the ~IFS~ variable.

#+BEGIN_SRC bash :results output
IFS=':' read VAR1 VAR2 <<< "  One    Two:   Three   Four"

echo "$VAR1"
echo "$VAR2"
#+END_SRC

