https://docs.python.org/3/
https://docs.python.org/3/library/index.html
https://docs.python.org/3/reference/index.html#reference-index
https://docs.python.org/3/library/functions.html#sorted


* Test code to check python versions

The ~python~ argument in the code block header accepts a path to your python
executable. I have both =python2= and =python3= in my path so that's why I can
write only the name of the executable. Evaluate the code by placing the cursor
inside the code block and press ~C-c C-c~

The following code block evaluates python2 code:

#+BEGIN_SRC python :python python2 :results output
import sys
print(sys.version)
#+END_SRC

And this code block evaluates python3 code:

#+BEGIN_SRC python :python python3 :results output
import sys
print(sys.version)
#+END_SRC

* Basics
** Types

#+BEGIN_SRC python :python python3 :results output
print("Integer:", 3)
print("Float:", 3.0)
print("Float:", 3.1)
#+END_SRC

** Basic math

Mathematical operators

#+BEGIN_SRC python :python python3 :results output
print(1 + 2)
print(10 - 4)
print(4 * 5)
print(7 / 3)
print(10 / 2, "(The result of division is always a float)")
#+END_SRC

Integer division

#+BEGIN_SRC python :python python3 :results output
print(7 // 3)
print(7.0 // 2.9 , "(Also works on floats)")
print(10.0 // 3.3)
print(10.0 // 3.4)
print(-7 // 3, "(The result is always rounded down)")
print(-7.0 // 3.0)
#+END_SRC

Modulo

#+BEGIN_SRC python :python python3 :results output
print(7 % 3, "(Smallest positive integer)")
print(-7 % 3)
#+END_SRC

Exponentiation

#+BEGIN_SRC python :python python3 :results output
print(2 ** 4)
print(2.0 ** 4)
print(2 ** 4.0)
print(2.0 ** 4.0)
#+END_SRC

Change precedence

#+BEGIN_SRC python :python python3 :results output
print(1 + 2 * 3)
print((1 + 2) * 3)
#+END_SRC

** Comparisons

Boolean values (note capitalization)

#+BEGIN_SRC python :python python3 :results output
print(True)
print(False)
#+END_SRC

Negation

#+BEGIN_SRC python :python python3 :results output
print(not True)
print(not False)
#+END_SRC

Boolean operators (~and~ and ~or~)

#+BEGIN_SRC python :python python3 :results output
print(True and False)
print(True or False)
#+END_SRC

Boolean operators with integers

#+BEGIN_SRC python :python python3 :results output
print(0 and 2)    # 0
print(-5 or 0)    # -5
print(0 == False) # True
print(2 == True)  # False
print(1 == True)  # True
#+END_SRC

Equality symbol (~==~)

#+BEGIN_SRC python :python python3 :results output
print(1 == 1)
print(2 == 1)
#+END_SRC

Inequality operator (~!=~)

#+BEGIN_SRC python :python python3 :results output
print(1 != 1)
print(2 != 1)
#+END_SRC

Size comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 10)
print(1 > 10)
print(2 <= 2)
print(2 >= 2)
#+END_SRC

Chained comparisons

#+BEGIN_SRC python :python python3 :results output
print(1 < 2 < 3)
print(2 < 3 < 2)
print(1 < 2 == 2)
print(1 < 2 == 1)
#+END_SRC

Lazy evaluation

#+BEGIN_SRC python :python python3 :results output
print(False and (5 / 0))
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
print(5 / 0) # Run as a comparison. This one fails
#+END_SRC

When not comparing booleans the result of a comparison will be equal to the last
evaluated expression

#+BEGIN_SRC python :python python3 :results output
myVar = '' or 'Second string' or 'Third string'
print(myVar)
myVar = '' or 1 or 'Third string'
print(myVar)
#+END_SRC

What different types evaluate to

#+BEGIN_SRC python :python python3 :results output
print(bool(0))
print(bool(0.0))
print(bool(""))
print(bool([])) # Empty list
print(bool({})) # Empty dictionairy
print(bool(())) # Empty tuple
print("Other values evaluate to True (this doesn't mean that they are equal to True as seen earlier)")
#+END_SRC

Equality (~==~) vs ~is~ operator
~is~ checks if two variables refer to the same object, but ~==~ checks if the
objects pointed to have the same values

#+BEGIN_SRC python :python python3 :results output
a = [1, 2, 3, 4]         # Point a at a new list, [1, 2, 3, 4]
b = a                    # Point b at what a is pointing to
print("b is a:", b is a) # => True, a and b refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
b = [1, 2, 3, 4]         # Point b at a new list, [1, 2, 3, 4]
print("b is a:", b is a) # => False, a and b do not refer to the same object
print("b == a:", b == a) # => True, a's and b's objects are equal
#+END_SRC

** Strings

Strings are surrounded with ~"~ or ~'~

#+BEGIN_SRC python :python python3 :results output
print("This is a string.")
print('This is also a string.')
#+END_SRC

Concatenation

#+BEGIN_SRC python :python python3 :results output
print("Hello " + "world!")
print("Hello " "world!") # Prefered way

# Put strings inside brackets to concatenate and put in variable (doesn't work with variables)
myString = ("Hello "
            "world!")
print(myString)
#+END_SRC

Treat it as a list of characters

#+BEGIN_SRC python :python python3 :results output
print("This is a string"[0])
#+END_SRC

Find the length of the string

#+BEGIN_SRC python :python python3 :results output
print(len("This is a string"))
#+END_SRC

Formatting string

#+BEGIN_SRC python :python python3 :results output
print("{} can be {}".format("Strings", "interpolated"))
print("{0} be nimble, {0} be quick, {0} jump over the {1}".format("Jack", "candle stick"))
print("{name} wants to eat {food}".format(name="Bob", food="lasagna"))
#+END_SRC

Raw strings

#+BEGIN_SRC python :python python3 :results output
print('\'Hello\nWorld\'')
print(r'\'Hello\nWorld\'') # print it exactly as it is written
#+END_SRC

Multi line string

#+BEGIN_SRC python :python python3 :results output
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
print("---")
# Add a '\' at the end and no trailing newline will be added
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to\
""")
print("---")
#+END_SRC

Repeating strings

#+BEGIN_SRC python :python python3 :results output
print("na " * 8 + "BATMAN")
#+END_SRC

** The ~None~ object

#+BEGIN_SRC python :python python3 :results output
print(None)
#+END_SRC

Compare with ~is~ operator instead of ~==~

#+BEGIN_SRC python :python python3 :results output
print('"etc" is None:', "etc" is None)
print('None is None:', None is None)
print('None == None', None == None)
#+END_SRC

** Variables

No need to declare variables before assigning to them. Convention is to use
lower_case_with_underscores

#+BEGIN_SRC python :python python3 :results output
some_var = 5
print("some_var:", some_var)
#+END_SRC

Accessing a previously unassigned variable raises an exception

#+BEGIN_SRC python :python python3 :results output
# The following error is intentional
some_unknown_var  # Raises a NameError
#+END_SRC

* Lists

Lists are mutable (tuples are not)

** Creating lists

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty list
li = []
print("li:", li)
# Or a prefilled list
prefilled_li = [4, 5, 6]
print("prefilled_li:", prefilled_li)
print("type([]):    ", type([]))
print("type([1,2]): ", type([1,2]))
#+END_SRC

** Add stuff to the end of the list

#+BEGIN_SRC python :python python3 :results output
li = []
print("li:", li)
li.append(1) # We have to do it in a separate step since this function only returns None (run help(list.append))
print("li:", li)
li.append(2)
print("li:", li)
li.append(4)
print("li:", li)
li.append(3)
print("li:", li)
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("li:       ", li)
print("li[0]:    ", li[0])
print("li[1]:    ", li[1])
# Negative index access elements counted from the end
print("li[-1]:   ", li[-1])
print("li[-2]:   ", li[-2])
print("li[2] = 5:")
li[2] = 5
print("li:       ", li)
#+END_SRC

** Remove (and return) from end with ~pop~

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
popped_value = li.pop()
print("popped_value:", popped_value)
print("li:", li)
# put it back with li.append
li.append(popped_value)
print("li:", li)
#+END_SRC

** Slicing with ~li[start:end(:step)]~

We will use a string as an example here. After all, a string is nothing other
than a tuple of characters. In the table below the dots are not included in the
string "Python" but will just point out the different "stops" of a index.

|  . | P |  . | y |  . | t |  . | h |  . | o |  . | n | . |
|----+---+----+---+----+---+----+---+----+---+----+---+---|
|  0 |   |  1 |   |  2 |   |  3 |   |  4 |   |  5 |   | 6 |
| -6 |   | -5 |   | -4 |   | -3 |   | -2 |   | -1 |   |   |

#+BEGIN_SRC python :python python3 :results output
pString = "Python"
print("pString[:] ", pString[:])
print("pString[3:]", pString[3:])
print("pString[:3]", pString[:3])
print("pString[1:5]", pString[1:5])
print("pString[::2]", pString[::2])
print("pString[1::2]", pString[1::2])
print("pString[:4:2]", pString[:4:2])
print("pString[1:5:3]", pString[1:5:3])
# And negative values
print("pString[-6:-1]", pString[-6:-1])
print("pString[::-1]", pString[::-1])
print("pString[-1:-6:-1]", pString[-1:-6:-1]) # Note that the start value now is
                                              # larger than end value
#+END_SRC

You can also update a list using slices

#+BEGIN_SRC python :python python3 :results output
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
print("letters:", letters)
letters[2:5] = ['C', 'D', 'E']
print("letters:", letters)
letters[2:5] = [] # The length can be changed
print("letters:", letters)
#+END_SRC

** Make a one layer deep copy using slices

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = li[:]
print("li: ", li)
print("li2:", li2)
print("li == li2:", li == li2) # Check for equality
print("li is li2:", li is li2) # Check if they are the same object
#+END_SRC

** Removing an element (~del~)

Removes an element given an index or slice

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 4, 5, 6, 7, 8]
print("li:", li)
print("li[2]:", li[2])
del li[2]
print("li:", li)
print("li[2]:", li[2])
del li[2::2]
print("li:", li)
# Remove the whole list
del li
# The following line will result in an error
#print("li:", li)
#+END_SRC

** Remove first occurence of a value (~remove~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.remove(2) # Calling this twice would result in a ValueError exception since 2 is not in the list
print("li:", li)
#+END_SRC

** Inserting an element in list (~insert~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li.insert(1, 5) # At index 1 insert 5
print("li:", li)
#+END_SRC

** Get index of first occurence of a value (~index~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3, 2]
print("li.index(2):", li.index(2)) # A non existing value would raise an ValueError exception
#+END_SRC

** Concatenating lists (~+~ and ~extend~)

The following code will create a new list:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
print("li + li2:", li + li2) # The lists are not affected
print("li:      ", li)
print("li2:     ", li2)
#+END_SRC

This code will update list ~li~:

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
li2 = [11, 12, 14, 13]
li.extend(li2) # Now li has changed
print("li: ", li)
print("li2:", li2)
#+END_SRC

** Check for existence (~in~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("1 in li:", 1 in li)
print("7 in li:", 7 in li)
#+END_SRC

** Length of list (~len~)

#+BEGIN_SRC python :python python3 :results output
li = [1, 2, 4, 3]
print("len(li): ", len(li))
#+END_SRC

** Multidimensional lists

#+BEGIN_SRC python :python python3 :results output
matrix = [[1, 2, 3],['a', 'b', 'c']]
print(matrix[0][1]) # 2
#+END_SRC

** Comparing sequences

It will compare each object from left to right

#+BEGIN_SRC python :python python3 :results output
print((1, 2, 3)    < (1, 2, 4))
print([1, 2, 3]    < [1, 2, 4])
print('ABC' < 'C'  < 'Pascal' < 'Python')
print((1, 2, 3, 4) < (1, 2, 4)) # The size doesn't matter. 3 is less than 4
print((1, 2)       < (1, 2, -1)) # One list was a subsequence of the other.
                                 # The shorter is the smaller one
print((1, 2, 3) == (1.0, 2.0, 3.0)) # Different types can be compared if they have appropriate compare methods
print((1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)) # An element is a sequence which will be compared
#+END_SRC

** Some commands in actions

#+BEGIN_SRC python :python python3 :results output
fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
print("fruits:                   ", fruits)
print("fruits.count('apple'):    ", fruits.count('apple'))
print("fruits.count('tangerine'):", fruits.count('tangerine'))
print("fruits.index('banana'):   ", fruits.index('banana'))
# Find next banana starting a position 4
print("fruits.index('banana', 4):", fruits.index('banana', 4))
print("fruits.reverse()")
fruits.reverse()
print("fruits:                   ", fruits)
print("fruits.append('grape')")
fruits.append('grape')
print("fruits:                   ", fruits)
print("fruits.sort()")
fruits.sort()
print("fruits:                   ", fruits)
print("fruits.pop():             ", fruits.pop())
print("fruits:                   ", fruits)
#+END_SRC

* Tuples

Tuples are immutable. The mutable equivalent would be list

** Creating tuples

#+BEGIN_SRC python :python python3 :results output
print("tup = (1, 2, 3)")
tup = (1, 2, 3)
print("tup:       ", tup)
print("A one element long tuple needs comma after the last element:")
print("type((1)): ", type((1)))
print("type((1,)):", type((1,)))
print("type(()):  ", type(()))
#+END_SRC

** Accessing elements

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("tup[0]:", tup[0])
# tup[0] = 3 is not allowed (tuples are immutable) and would raise a TypeError exception
#+END_SRC

** List elements that also works on tuples

#+BEGIN_SRC python :python python3 :results output
tup = (1, 2, 3)
print("len(tup):       ", len(tup))
print("tup + (4, 5, 6):", tup + (4, 5, 6))
print("tup[:2]:        ", tup[:2])
print("2 in tup:       ", 2 in tup)
#+END_SRC

** Unpacking tuples (also lists)

The number of variables and values must match

#+BEGIN_SRC python :python python3 :results output
a, b, c = (1, 2, 3)
print("a:", a)
print("b:", b)
print("c:", c)
#+END_SRC

You can also use the asterisk to capture several variables

#+BEGIN_SRC python :python python3 :results output
a, *b, c = (1, 2, 3, 4) # Only one variable may use the asterisk
print("a:", a)
print("b:", b) # This will be a list
print("c:", c)
#+END_SRC

The paranthesis are not needed. Tuples are created by default

#+BEGIN_SRC python :python python3 :results output
d, e, f = 4, 5, 6
print("d:", d)
print("e:", e)
print("f:", f)
#+END_SRC

This makes it very easy to swap two values

#+BEGIN_SRC python :python python3 :results output
d = 4
e = 5
e, d = d, e
print("d:", d)
print("e:", e)
#+END_SRC

* Dictionairies
** Creating dictionairies

#+BEGIN_SRC python :python python3 :results output
# Can be either an empty dictionairy
empty_dict = {}
print("empty_dict:       ", empty_dict)

# Or a prefilled dictionairy
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:      ", filled_dict)
print("type(filled_dict):", type(filled_dict))
#+END_SRC

The keys of the dictionairy needs to be of an immutable type (such as int,
float, string or tuple). This is because python needs to calculate hash values
for lookups. Values can be of any type.

#+BEGIN_SRC python :python python3 :results output
valid_dict = {(1,2,3):[1,2,3]}
print("valid_dict:", valid_dict)
# You are not limited to one type of key/value
other_valid_dict = {1: 2, "three": "four"}
print("other_valid_dict:", other_valid_dict)
#+END_SRC

A dictionairy can also be created with the constructor. It accepts a sequence of
key-value pairs

#+BEGIN_SRC python :python python3 :results output
myDict = dict([("one", 1), ("two", 2), ("three", 3)])
print(myDict)
#+END_SRC

** Look for existence of keys

The ~in~ keyword will search for keys in the dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('"one" in filled_dict:', "one" in filled_dict)
print("1 in filled_dict:    ", 1 in filled_dict)
#+END_SRC

** Look for values (using keys)

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict["one"]:        ', filled_dict["one"])
# Looking up a non-existing key raises and KeyError. Use get instead
print('filled_dict.get("one"):    ', filled_dict.get("one"))
print('filled_dict.get("four"):   ', filled_dict.get("four")) # Not found so returns <None>
print('filled_dict.get("one", 4): ', filled_dict.get("one", 4))
print('filled_dict.get("four", 4):', filled_dict.get("four", 4)) # Not found so returns default value 4
#+END_SRC

** Get all keys and values

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict.keys():        ", filled_dict.keys())       # The order is non predictable
print("list(filled_dict.keys()):  ", list(filled_dict.keys())) # To get the result as a list
print("filled_dict.values():      ", filled_dict.values())     # The indexes seems to match for keys and values
print("list(filled_dict.values()):", list(filled_dict.values()))
#+END_SRC

You can also extract all items as key-value pairs

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict.items():      ", filled_dict.items())
print("list(filled_dict.items()):", list(filled_dict.items()))
#+END_SRC

** Adding value to dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
filled_dict["four"] = 5
print("filled_dict:", filled_dict)
# I don't see why I should use this method as the indexing version can both add and update
returnValue = filled_dict.update({"four":4}) # Always return None (not the previous value)
print("returnValue:", returnValue)
print("filled_dict:", filled_dict)
#+END_SRC

** Add value if it is not present

The method ~setdefault()~ is similar to ~get()~, but will set
~dict[key]=default~ if key is not already in dict.

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print('filled_dict.setdefault("five", 5):', filled_dict.setdefault("five", 5))
print("filled_dict:", filled_dict)
print('filled_dict.setdefault("five", 6):', filled_dict.setdefault("five", 6)) # Will still be 5
print("filled_dict:", filled_dict) # This list hasn't changed
#+END_SRC

** Remove key/value pair using key

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
print("filled_dict:", filled_dict)
del filled_dict["one"]
print("filled_dict:", filled_dict)
#+END_SRC

* Sets

A ~set~ is an unordered collection with no duplicate elements. Supports typical
set operations like union, intersection, difference, and symmetric difference.

Uses curly braces, just like dictionairies but with single values instead. To
create an empty set you will have to use ~set()~ as ~{}~ creates an empty
directory

#+BEGIN_SRC python :python python3 :results output
empty = set()
print(empty)
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)
print('orange' in basket)
print('crabgrass' in basket)
#+END_SRC

Set operations. String is an iterable so when giving a string to the ~set~
constructor it will build a set of the characters

#+BEGIN_SRC python :python python3 :results output
a = set('abracadabra')
b = set('alacazam')

print("a:    ", a)
print("b:    ", b)
print()
# Difference
print("a - b:", a - b)
# Union
print("a | b:", a | b)
# Intersection
print("a & b:", a & b)
# Symmetric difference
print("a ^ b:", a ^ b)
#+END_SRC

* Control flows
** ~if~ statement

#+BEGIN_SRC python :python python3 :results output :preamble def input(x): return 2
# In the header of this block we have redefined input as we can't run this interactively
x = int(input("Please enter an integer: "))

if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
#+END_SRC

*** Ternary operator

Python also supports a ternary operator

#+BEGIN_SRC python :python python3 :results output
a = 1
b = 2
cond = True

c = a if cond else b
print (c)

cond = False
c = a if cond else b
print (c)
#+END_SRC

** ~for~ statement

Iterates over any sequence and not only an arithmetic progression

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
#+END_SRC

Note that the variable w will still be set after the loop finishes

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))

print("After loop:", w)
#+END_SRC

Also supports ~else~ when it is exiting the ~for~ loop

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
else:
    print("exit")
#+END_SRC

~continue~ and ~break~ works as expected. If break is called the ~else~ clause
won't be called if it exists

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        continue
    print(w, len(w))
else:
    print("exit")
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
words = ['cat', 'window', 'defenestrate']
for w in words:
    if w == 'window':
        break
    print(w, len(w))
else:
    print("exit")
#+END_SRC

*** An example

#+BEGIN_SRC python :python python3 :results output
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
#+END_SRC

** ~while~ statement

Works as expected

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
#+END_SRC

Also supports ~else~

#+BEGIN_SRC python :python python3 :results output
a, b = 0, 1
while b < 10:
    print(b)
    a, b = b, a+b
else:
    print("done")
#+END_SRC

~continue~ and ~break~ works the same as with ~for~ loops

** The ~range()~ function

Can be used when you need to iterate over an arethmetic progression. The endpoint is never generated

#+BEGIN_SRC python :python python3 :results output
for i in range(5):
    print(i) # Will print 0 to 4
#+END_SRC

You can define start and end point

#+BEGIN_SRC python :python python3 :results output
for i in range(5, 10):
    print(i)
#+END_SRC

And define a step size

#+BEGIN_SRC python :python python3 :results output
for i in range(0, 10, 3):
    print(i)
#+END_SRC

And also ranges with negative step

#+BEGIN_SRC python :python python3 :results output
for i in range(-10, -100, -30):
    print(i)
#+END_SRC

To iterate over the indices of a sequence, you can combine range() and len() as follows

#+BEGIN_SRC python :python python3 :results output
a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])
#+END_SRC

Printing a range

#+BEGIN_SRC python :python python3 :results output
myRange = range(5)
print(myRange)
print(list(myRange))
print(tuple(myRange))
#+END_SRC

** ~pass~ statement

Does nothing but can be used when a statement is needed syntactically

#+BEGIN_SRC python :python python3 :results output
def f(arg):
    pass    # a function that does nothing
#+END_SRC

* Functions

The first line in the following function is the documenation string (and is
optional). Some tools can extract this string

#+BEGIN_SRC python :python python3 :results output
def fib(n):    # write Fibonacci series up to n
    """Print a Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
#+END_SRC

Call by value

#+BEGIN_SRC python :python python3 :results output
def f(n):
    print("In function:   ", n)
    n = 3
    print("In function:   ", n)

myVar = 5
f(myVar)
print("After function:", myVar)
#+END_SRC

But passes references

#+BEGIN_SRC python :python python3 :results output
def f(aList):
    print("In function:   ", aList)
    aList[1] = 5
    print("In function:   ", aList)

myList = [1, 2, 3]
f(myList)
print("After function:", myList)
#+END_SRC

A function that doesn't return any value will return the value ~None~.

You can create a function which returns a value with the ~return~ keyword

#+BEGIN_SRC python :python python3 :results output
def fib2(n):  # return Fibonacci series up to n
    """Return a list containing the Fibonacci series up to n."""
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)    # see below
        a, b = b, a+b
    return result

f100 = fib2(100)
print(f100)
#+END_SRC

~return~ without arguments will return ~None~. If execution reaches the end of
the method it will also return ~None~

** Variable number of arguments
*** Default argument values

#+BEGIN_SRC python :python python3 :results output
def ask_ok(prompt, retries=100, reminder='Please try again!'):
    print("prompt:  ", prompt)
    print("retries: ", retries)
    print("reminder:", reminder)
    print()

ask_ok("Test", 5, "Last")
ask_ok("Test", 5)
ask_ok("Test")
ask_ok("Test", reminder="Last")
#+END_SRC

Note that the default value will only be evaluated once. Mutable objects may be
updated

#+BEGIN_SRC python :python python3 :results output
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
#+END_SRC

*** Keyword arguments

All keyword arguments must be placed after all positional arguments

#+BEGIN_SRC python :python python3 :results output
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")
    print()

# This method can be called in several different ways
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
#+END_SRC

*** Arbitrary Argument Lists

Can be preceded by zero or more normal arguments. Can also be followed by
keyword arguments. A variadic variable will be a tuple

#+BEGIN_SRC python :python python3 :results output
def report(header, *entries, sep='\n'):
    print(header)
    print('-' * len(header))
    print(sep.join(entries))
    print()

report("Food", "Bread", "Butter")
report("Food", "Bread", "Butter", sep=" ")
#+END_SRC

A special variadic element can also be defined with ~**~ which will be treated
as a dictionairy. The dictionairy will _always_ be in the same order as the
arguments passed

#+BEGIN_SRC python :python python3 :results output
def report(header, *entries, **dictentries):
    print(header)
    print('-' * len(header))
    print('\n'.join(entries))
    print('-' * len(header))
    for kw in dictentries:
        print(kw, ":", dictentries[kw])
    print()

report("Food", "Bread", "Butter", test1=1, test2=2)
report("Food", "Bread", "Butter", sep=" ")
#+END_SRC

*** Unpacking variables

Sometimes you have the arguments in a list and you need to provide them to a
function separately. Then you'll have to unpack them

#+BEGIN_SRC python :python python3 :results output
print(list(range(3, 6)))
args = [3, 6]
print(list(range(*args)))
#print(list(range(args))) # This will fail
#+END_SRC

Same thing when unpacking dictionairies. But you'll unpack it with the ~**~
operator

#+BEGIN_SRC python :python python3 :results output
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")

d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)
#+END_SRC

** Lambda Expressions

In the following example we uses a lambda to create a new function (currying?)

#+BEGIN_SRC python :python python3 :results output
def make_incrementor(n):
    return lambda x: x + n

f = make_incrementor(42)
print(f(0))
print(f(1))
#+END_SRC

You can also use lambdas when you need to provide a function to another
function. In this example we want to sort the list on the string (the second
entry in each tuple)

#+BEGIN_SRC python :python python3 :results output
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
print(pairs)
#+END_SRC

** Documentation string (doc string)

The first line in the documentation string should be short, concise summary of
the object’s purpose. If more documentation is needed the second line should be
blank. You can reach the doc string with the ~.__doc__~ call.

#+BEGIN_SRC python :python python3 :results output
def my_function():
    """Do nothing, but document it.

    No, really, it doesn't do anything.
    """
    pass

print(my_function.__doc__)
#+END_SRC

** Function annotations

Function annotations are optional and they can be used for whatever you feel.
Parameter annotations are defined by a colon after the parameter name, followed
by an expression evaluating to the value of the annotation. Return annotations
are defined by a literal ~->~, followed by an expression, between the parameter
list and the colon denoting the end of the def statement.

#+BEGIN_SRC python :python python3 :results output
def f(ham: str, eggs: str = 'eggs') -> str:
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham + ' and ' + eggs

print(f('spam'))
#+END_SRC

A more advanced example

#+BEGIN_SRC python :python python3 :results output
def validate(func, locals):
    for var, test in func.__annotations__.items():
        value = locals[var]
        msg = 'Var: {0}\tValue: {1}\tTest: {2.__name__}'.format(var, value, test)
        assert test(value), msg


def is_int(x):
    return isinstance(x, int)

def between(lo, hi):
    def _between(x):
            return lo <= x <= hi
    return _between

def f(x: between(3, 10), y: is_int = 1):
    validate(f, locals()) # locals return a dictionairy for the arguments
    print(x, y)


f(5)
f(5, 1)
#+END_SRC

You can also use them for documentation if you want. E.g. what kind of data you
expect or the types of the arguments.

* Data structures
** List comprehensions

Can be used to create new lists where each element is the result of some
operations applied to each member of another sequence or iterable, or to create
a subsequence of those elements that satisfy a certain condition.

#+BEGIN_SRC python :python python3 :results output
squares = []
for x in range(10):
    squares.append(x**2)

print(squares)
# A side effect of doing it this way
print(x)
#+END_SRC

This can be replaced with

#+BEGIN_SRC python :python python3 :results output
squares = list(map(lambda x: x**2, range(10)))
print(squares)
#+END_SRC

or (note that there are no side effects on this call)

#+BEGIN_SRC python :python python3 :results output
x = 3
squares = [x**2 for x in range(10)]
print(squares)
print(x)
#+END_SRC

You can add more ~for~ clauses and optional ~if~ clasuses to the comprehension.

#+BEGIN_SRC python :python python3 :results output
myVar = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
print(myVar)
#+END_SRC

You can use the variable multiple times

#+BEGIN_SRC python :python python3 :results output
myVar = [(x, x**2) for x in range(6)]
print(myVar)
#+END_SRC

Or flatten a matrix

#+BEGIN_SRC python :python python3 :results output
vec = [[1,2,3], [4,5,6], [7,8,9]]
myVar = [num for elem in vec for num in elem]
print(myVar)
#+END_SRC

You can also create a dictionairy with dict comprehension

#+BEGIN_SRC python :python python3 :results output
myDict = {x: x**2 for x in (2, 4, 6)}
print(myDict)
#+END_SRC

** Nested list comprehensions

The expression in a list comprehension can be another comprehension. The
following code will transpose the matrix

#+BEGIN_SRC python :python python3 :results output
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
transposed = [[row[i] for row in matrix] for i in range(4)]
print(transposed)
#+END_SRC

** Looping techniques

Looping over all key-value pairs in a dictionairy

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
for k, v in filled_dict.items():
    print ("Key:", k, "Value:", v)
#+END_SRC

If you just call it without ~items()~ it will only loop over the keys

#+BEGIN_SRC python :python python3 :results output
filled_dict = {"one": 1, "two": 2, "three": 3}
for k in filled_dict:
    print ("Key:", k)
#+END_SRC

Loop over a sequence and keep track of the index for each element

#+BEGIN_SRC python :python python3 :results output
for i, v in enumerate(['First', 'Second', 'Third']):
    print(i, v, "element")
#+END_SRC

To loop over multiple sequences at the same time you can use zip

#+BEGIN_SRC python :python python3 :results output
numbers = [1, 2, 3, 4]
squares = [1, 4, 9, 16]

for n, s in zip(numbers, squares):
    print("The square of", n, "is", s)
#+END_SRC

If you want to travese a sequence in reverse order

#+BEGIN_SRC python :python python3 :results output
for i in reversed([1, 2, 3, 4]):
    print(i)
#+END_SRC

* Modules

The module name is the file name without the ~.py~ file ending. The module name
can be fetched from the ~__name__~ variable.

I have already created a module called [[file:mymodule.py][mymodule]] in this directory. We can now
import it to our script with the ~import~ keyword. Now you can access the
module's functions by refering to the module name

#+BEGIN_SRC python :python python3 :results output
import mymodule as mymodule

mymodule.fib(1000)
myvar = mymodule.fib2(1000)
print(myvar)
print(mymodule.__name__)
#+END_SRC

You can also assign a function to a variable

#+BEGIN_SRC python :python python3 :results output
import mymodule

fib = mymodule.fib
fib(1000)
#+END_SRC

** More on modules

Each module has its own private symbol table, which is used as the global symbol
table by all functions defined in the module. There is no risk of naming
conflicts between modules. On the other hand, if you know what you are doing you
can touch a module’s global variables with the same notation used to refer to
its functions, ~modname.itemname~

There is a variant of the import statement that imports names from a module
directly into the importing module’s symbol table (no need to call a method
using the module name). With the following code you won't be able to refer to
the ~mymodule~ module

#+BEGIN_SRC python :python python3 :results output
from mymodule import fib, fib2

fib(1000)
#mymodule.fib(1000) # name 'mymodule' is not defined
#+END_SRC

You can also import all names a module defines (except those that begin with a
underscore)

#+BEGIN_SRC python :python python3 :results output
from mymodule import *

fib(1000)
myvar = fib2(1000)
print(myvar)
#+END_SRC

You can also "rename" a module when you import it

#+BEGIN_SRC python :python python3 :results output
import mymodule as fib

fib.fib(1000)
print(fib.__name__)
#+END_SRC

We can also use the ~as~ keyword together with ~from~

#+BEGIN_SRC python :python python3 :results output
from mymodule import fib as fibonacci

fibonacci(1000)
#+END_SRC

** Executing a module as a script

If the ~__name__~ variable is set to ~__main__~ it means that the current module
is the file which was invoked (e.g. from command line)

#+BEGIN_SRC python :python python3 :results output :preamble import sys; sys.argv = ["filename","50"]
from mymodule import fib
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
#+END_SRC

If this file is imported to another file now the code will not be called.
Otherwise the code will run. This is often used either to provide a convenient
user interface to a module, or for testing purposes (running the module as a
script executes a test suite).

** Module search path

When importing a module python will first search within the built-in modules,
otherwise it will look in for it in a list of directories given by the variable
~sys.path~. This is initialized to the directory containing the input script and
the path given by the ~PYTHONPATH~ environment variable and lastly the
installation-dependent default. The python program can alter the ~sys.path~
during execution using standard list operations.

** The ~dir~ function

The ~dir~ function is used to find out which names a module defines. It returns
a sorted list of strings. With no arguments you find the names the names you
have currently defined. Not the built-in functions and variables. To see those
you can run ~dir(builtins)~

#+BEGIN_SRC python :python python3 :results output
import mymodule, sys
print("mymodule\n", dir(mymodule), sep='')
print("sys\n", dir(sys), sep='')
print("noarg\n", dir(), sep='')
import builtins
print("builtins\n", dir(builtins), sep='')
#+END_SRC

** Packages

Packages are a way of structuring Python’s module namespace by using “dotted
module names”. Can be used so different authors of multi-module packages won't
have to worry about colliding module names. Here is a directoy structure

#+BEGIN_SRC
mypackage/            # The package
    __init__.py       # Initialize the package
    mysubpackage1/    # Subpackage
        __init__.py
        module11.py
        module12.py
    mysubpackage2/
        __init__.py
        module21.py
        module22.py
#+END_SRC

The ~__init__.py~ are required so python know that the directory contains
packages. It can be empty or contain initialization code for the package or
set the ~__all__~ variable.

You can now import a module by refering to the full name. You have to refer to
it's full name in the code as well

#+BEGIN_SRC python :python python3 :results output
import mypackage.mysubpackage1.module11

mypackage.mysubpackage1.module11.function(var)
#+END_SRC

You can also import the submodule with ~from package import module~. Then you
won't have to refer to the full name

#+BEGIN_SRC python :python python3 :results output
from mypackage.mysubpackage1 import module11

module11.function(var)
#+END_SRC

or

#+BEGIN_SRC python :python python3 :results output
from mypackage.mysubpackage1.module11 import function

function(var)
#+END_SRC

*** Import * from a package

If a package's ~__init__.py~ file defines a list called ~__all__~ it will import
all modules defined in that list when ~from package import *~ is encountered.
If the file ~mypackage/mysubpackage1/__init__.py~ contains

#+BEGIN_SRC python :python python3 :results output
__all__ = ["module11", "module12"]
#+END_SRC

those two modules will be imported when ~from mypackage.mysubpackage1 import *~
is encountered. If ~__all__~ is not defined it does not import any modules, it
only runs initialization code in ~__init__.py~

*** Module references inside package

You can use absolute referencing inside a package as described above or you can
use relative referencing. In the ~module11.py~ file you can write

#+BEGIN_SRC python :python python3 :results output
from . import module12
from .. import mysubpackage2
from ..mysubpackage2 import module21
#+END_SRC

Relative import can't be used in the main module of a program!

* Input/output

** Formatting

Python can convert values to strings in two ways, using ~str()~ (used for human
readable text) or ~repr()~ (for generating representations which can be read
by the interpreter). For many values both calls will result in the same string.
Here we used a string but any python object can be passed

#+BEGIN_SRC python :python python3 :results output
s = 'Hello, world.\n'
print("str(s): ", str(s))
print("repr(s):", repr(s))
#+END_SRC

You can justify a string using ~ljust()~, ~rjust()~ and ~center()~. Not that
none of these calls will truncate the value if it would be too long

#+BEGIN_SRC python :python python3 :results output
for x in range(1, 11):
    print(repr(x).rjust(2), repr(x*x).rjust(3), repr(x*x*x).rjust(4))
#+END_SRC

The ~zfill()~ will pad a numeric string with zeros to the left. It understands
plus and minus

#+BEGIN_SRC python :python python3 :results output
print('12'.zfill(5))
print('-3.14'.zfill(7))
print('3.14159265359'.zfill(5))
#+END_SRC

*** The ~str.format()~ function

The basic form looks like this

#+BEGIN_SRC python :python python3 :results output
print('{} and {}'.format('rock', 'roll'))
#+END_SRC

You can also add an index the format fields

#+BEGIN_SRC python :python python3 :results output
print('{0} and {1}'.format('rock', 'roll'))
print('{1} and {0}'.format('rock', 'roll'))
print('{0}, {1} and {0}'.format('rock', 'roll'))
#+END_SRC

or keywords

#+BEGIN_SRC python :python python3 :results output
print('{person} smells {smell}'.format(person='Sara', smell='wonderful'))
#+END_SRC

You're also allowed to mix these. You can also add a ~:~ after the field name
which gives you control how a value is formatted

#+BEGIN_SRC python :python python3 :results output
import math
print('The value of PI is approximately {0:.3f}.'.format(math.pi))
#+END_SRC

Passing an integer after ~:~ will force that field to be at least of that length

#+BEGIN_SRC python :python python3 :results output
table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
for name, phone in table.items():
    print('{0:10} ==> {1:10d}'.format(name, phone))
#+END_SRC

You can also pass a dictionairy

#+BEGIN_SRC python :python python3 :results output
table = {'firstkey' : 'firstvalue1', 'secondkey' : 'secondvalue1'}
table2 = {'firstkey' : 'firstvalue2', 'secondkey' : 'secondvalue2'}
print('First: {0[firstkey]}. Second: {1[secondkey]}'.format(table, table2))
#+END_SRC

Something similar could be done with the ~**~ operator

#+BEGIN_SRC python :python python3 :results output
table = {'firstkey' : 'firstvalue1', 'secondkey' : 'secondvalue1'}
print('First: {firstkey}. Second: {secondkey}'.format(**table))
#+END_SRC

Python also has support for printf style string formatting

#+BEGIN_SRC python :python python3 :results output
import math
print('The value of PI is approximately %5.3f.' % math.pi)
#+END_SRC

** Reading and writing files

The ~open()~ function returns a file object. It is commonly used with ~filename~
and ~mode~ arguments

#+BEGIN_SRC python :python python3 :results output
f = open('mymodule.py', 'r')
#+END_SRC

The mode can be any of these strings:

| Mode | Description                                |
|------+--------------------------------------------|
| 'r'  | Read only                                  |
| 'w'  | Write only (overwrite a file if it exists) |
| 'a'  | Append to the end of the file              |
| 'r+' | Read and write                             |

The ~mode~ argument is optional and is defaulted to ~'r'~. If you append a ~b~
to the ~mode~ argument (e.g. ~'rb'~) the file will be opened in binary mode and
the data is read and written in byte objects.

It's a good practice to open a file using the ~with~ keyword. It will close the
file when we exit the block (even if an exception is raised). This can also be
done using ~try-finally~. If you don't use any of these approaches you will have
to make sure you call the ~file.close()~ function yourself

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    read_data = f.read()
    print(read_data)
print("Is file closed?", f.closed)
#+END_SRC

*** Read

If you don't want to read the full file, the ~read()~ method also accepts a
~size~ argument which is the maximum number of data to be read. If EOF has been
reached ~read()~ will return an empty string (~''~)

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    read_data = f.read(15)
    print('First read: ', read_data)
    read_data = f.read(15)
    print('Second read:', read_data)
#+END_SRC

To read a full line you can use the ~readline()~ method. This method will also
read the newline character. It is only omitted on the last line if there is no
newline character. If an empty string is returned it means that we have reached
the end of the file

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    while True:
        read_data = f.readline()
        if read_data == '':
            break
        # The variable already contains a newline
        print(read_data, end='')
#+END_SRC

An easier way to achive the same result is to loop over the file object

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    for line in f:
        print(line, end='')
#+END_SRC

You can also read all lines into a list

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    linesList = list(f)
    print(linesList)
#+END_SRC

or

#+BEGIN_SRC python :python python3 :results output
with open('mymodule.py') as f:
    linesList = f.readlines()
    print(linesList)
#+END_SRC

*** Write

If you want to write to a file you can us the ~write()~ function which accepts a
string and returns the number of characters written

#+BEGIN_SRC python :python python3 :results output
with open('temp_output.txt', "w") as f:
    charsWritten = f.write('This is a test\n')
print('Chars written:', charsWritten)
#+END_SRC

The output is now written to [[file:temp_output.txt][temp_output.txt]]. Other types needs to be converted
to string or bytes object before writing them

#+BEGIN_SRC python :python python3 :results output
with open('temp_output.txt', "w") as f:
    value = ('the answer', 42)
    charsWritten = f.write(str(value))
print('Chars written:', charsWritten)
#+END_SRC

*** Search

~tell()~ return the current position represented as the number of bytes from the
beginning of the file for binary files and an non-modifiable object for text
files (only meant to be used to get back to the current position)

To change the current position you can use ~seek()~ which accepts two arguments
~offset~ and ~from_what~. ~from_what~ can be either

| ~from_what~ | Description                 |
|-------------+-----------------------------|
|           0 | Beginning of file (default) |
|           1 | Current file position       |
|           2 | End of file                 |

For text files only ~0~ is allowed. The only exception is to find the very end
of the file ~f.seek(0, 2)~. For text files the only valid offsets are those
which are returned from ~tell()~ and ~0~

** Input

#+BEGIN_SRC python :python python3 :results output
input("Please enter an integer: ")
#+END_SRC

* Scopes

Module attributes are writable. Writable attributes can also be deleted with the
~del~ keyword. I once again use [[file:mymodule.py][mymodule]] as my assisting module

#+BEGIN_SRC python :python python3 :results output
# Add example where we set a module attribute and call a function that prints it
import mymodule

mymodule.printMyVariable()
mymodule.myvariable = 15
mymodule.printMyVariable()

# The following lines will make it fail
#del mymodule.myvariable
#mymodule.printMyVariable()
#+END_SRC

There are at least three nested scopes whose namespaces are directly accessible:

- The innermost scope, which is searched first, contains the local names
- The scopes of any enclosing functions, which are searched starting with the
  nearest enclosing scope, contains non-local, but also non-global names
- The next-to-last scope contains the current module’s global names
- The outermost scope (searched last) is the namespace containing built-in names

If a name is declared ~global~, then all references and assignments go directly
to the middle scope containing the module’s global names. To rebind variables
found outside of the innermost scope, the ~nonlocal~ statement can be used; if
not declared ~nonlocal~, those variables are read-only (an attempt to write to
such a variable will simply create a new local variable in the innermost scope,
leaving the identically named outer variable unchanged).

All operations that introduce new names use the local scope: in particular,
~import~ statements and function definitions bind the module or function name
in the local scope.

Note that a variable which is declared ~nonlocal~ needs to refer to a
pre-existing variable in an enclosing scope. A variable which is declared as
~global~ can be newly introduced

#+BEGIN_SRC python :python python3 :results output
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
#+END_SRC

* Classes

Just like function definitions (~def~) the class definition needs to be executed
before they have any effect. Classes doesn't have to be defined on global level
but can be defined in e.g. ~if~ statements or functions

** Class object

A class object supports two kinds of operations: /attribute references/ and
/instantiation/.

*** Attribute references

Attribute references uses the syntax for all attribute references ~obj.name~
where name can be any of the names that were in the class's namespace when the
class was defined. The ~doc string~ is also allowed

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

print(MyClass.__doc__)
print(MyClass.i)
MyClass.i = 6
print(MyClass.i)
#+END_SRC

As you can see in the example above you can also assign values to the referenced
attributes

*** Instantiation

To create a new instance of a class you just treat the defined class as a
parameterless function

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

x = MyClass()
y = MyClass()

print(x.f())
print(x.i)
print(y.i)
x.i = 1
y.i = 2
print(x.i)
print(y.i)
print(MyClass.i)
#+END_SRC

The constructor above creates an empty object. We can also define our own
constructor by defining an ~__init__()~ method

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self):
        self.x = 4
        self.y = 5

    def printState(self):
        print("x:", self.x, "y:", self.y)

a = MyClass()
a.printState()
a.x = 10
a.printState()
#+END_SRC

A constuctor can also accept parameters

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def printState(self):
        print("x:", self.x, "y:", self.y)

a = MyClass(20, 30)
a.printState()
a.x = 10
a.printState()
#+END_SRC

** More about attribute references

There are two forms of attribute references: data attributes and methods.

Data attributes corresponds to instance variables. They don't have to be
declared but will be created when they are assigned a vales

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    pass

x = MyClass()

x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter
#+END_SRC

Beware that data attributes override method attributes with the same name when
assigning! The only way to avoid this is to use some kind of convention to
minimize the chance of conflicts

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def f(self):
        return 'hello world'

x = MyClass()

print(type(x.f))
print(x.f())

x.f = 50;

print(type(x.f))
print(x.f)
#+END_SRC

** Method Objects

It's not necessary to call a method directly when referencing a method. Instead
of ~x.f()~ you can get the method object which can be stored away and called
later by calling ~x.f~. E.g.

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def f(self):
        return 'hello world'

x = MyClass()
xf = x.f

for i in range(5):
    print(xf())
#+END_SRC

As you have noticed all methods defined in classes accepts a ~self~ parameter.
Python passes the instance object as the first object when referencing the
method. ~x.f()~ is actually equivalent to ~MyClass.f(x)~. So the example above
could be written as:

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def f(self):
        return 'hello world'

x = MyClass()
f = MyClass.f

for i in range(5):
    print(f(x))
#+END_SRC

Note that the name ~self~ is nothing else but a convention. You can choose
another name for it (but that's discouraged!).

** Class and instance variables

#+BEGIN_SRC python :python python3 :results output
class Dog:
    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

d = Dog('Fido')
e = Dog('Buddy')
print(d.kind)                  # shared by all dogs
print(e.kind)                  # shared by all dogs
Dog.kind = 'doggo'
print(d.kind)                  # shared by all dogs
print(e.kind)                  # shared by all dogs
print(d.name)                  # unique to d
print(e.name)                  # unique to e
#+END_SRC

Here's an example how you can accidentally treat a class variable as if it was
an instance variable

#+BEGIN_SRC python :python python3 :results output
class Dog:
    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

d = Dog('Fido')
e = Dog('Buddy')
d.add_trick('roll over')
e.add_trick('play dead')
print(d.tricks)                # unexpectedly shared by all dogs
#+END_SRC

The correct way to do it would be

#+BEGIN_SRC python :python python3 :results output
class Dog:
    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

d = Dog('Fido')
e = Dog('Buddy')
d.add_trick('roll over')
e.add_trick('play dead')
print(d.tricks)
print(e.tricks)
#+END_SRC

** Random remarks

It is not necessary that a class method itself is defined inside the class
definition. E.g.

#+BEGIN_SRC python :python python3 :results output
# Function defined outside the class
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1

    def g(self):
        return 'hello world'

    h = g

c = C()

print(c.f(1,4))
print(c.g())
print(c.h())
#+END_SRC

Also it's good to know that methods may call other methods by referencing
attributes of the ~self~ object

#+BEGIN_SRC python :python python3 :results output
class Bag:
    def __init__(self):
        self.data = []

    def add(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)

bag = Bag()
print(bag.data)
bag.add('thing')
print(bag.data)
bag.addtwice('stuff')
print(bag.data)
#+END_SRC

** Inheritence

You subclass another class by putting it in paranthesis

#+BEGIN_SRC python :python python3 :results output
class Animal:
    def noise(self):
        print('Noise')

    def run(self):
        print('Running')

class Dog(Animal):
    def noise(self):
        print('Bark')

animal = Animal()
dog = Dog()

animal.noise()
animal.run()
dog.noise()
dog.run()
Animal.noise(dog)
#+END_SRC

As you can see by running the example above a subclass inherits the methods from
its parent and can also override methods. If you still want to call the parent
class method definition it can be done like the last row:
~BaseClass.func(subClass_instance)~. ~BaseClass~ needs to be accessible of
course.

In this case the ~Animal~ class was defined in the same module but if was
defined in another module it could be sub classed with
~class Dog(modulename.Animal):~.

You can check inheritence with the methods ~isinstance~ (to check instance type)
and ~issubclass~ (to check class inheritence)

#+BEGIN_SRC python :python python3 :results output
class Animal:
    pass

class Dog(Animal):
    pass

animal = Animal()
dog = Dog()

print(isinstance(animal, Animal))
print(isinstance(animal, Dog))
print(isinstance(dog, Animal))
print(isinstance(dog, Dog))
print()
print(issubclass(Animal, Animal))
print(issubclass(Animal, Dog))
print(issubclass(Dog, Animal))
print(issubclass(Dog, Dog))
#+END_SRC

It also looks like as if a subclass inherits the initializers (and it can be
overridden). E.g.

#+BEGIN_SRC python :python python3 :results output
class Animal:
    def __init__(self):
        print('Creating Animal')

class Dog(Animal):
    pass

class Cat(Animal):
    def __init__(self):
        print('Creating Cat')

animal = Animal()
dog = Dog()
cat = Cat()
#+END_SRC

*** Multiple Inheritence

You can also have multiple parents in Python

#+BEGIN_SRC python :python python3 :results output
class Animal:
    pass

class Quadruped:
    pass

class Dog(Animal, Quadruped):
    pass

dog = Dog()
#+END_SRC

For most purposes, in the simplest cases, you can think of the search for
attributes inherited from a parent class as depth-first, left-to-right, not
searching twice in the same class where there is an overlap in the hierarchy.
Thus, if an attribute is not found in ~Dog~, it is searched for in ~Animal~,
then (recursively) in the base classes of ~Animal~, and if it was not found
there, it was searched for in ~Quadruped~, and so on. This is not really the
truth as the method resolution order changes dynamically to support cooperative
calls to ~super()~. This is known as /call-next-method/.

** Private Variables

In python there are no private variables. The convention is that if you prefix
the variable, method or function with an underscore it should be treated as non-
public (and may change without notice).

To avoid name clashes with subclasses there is something called /name mangling/.
An identifier which is prefixed with at least two underscores and at most one
trailing underscore is will be prefixed with ~_classname~. E.g. ~__myvar~ will
be replaced with ~_MyClass__myvar~ in the class ~MyClass~. This can only be done
inside classes.

This is helpful for letting subclasses override methods without breaking
intraclass method calls. Compare the examples below

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self, var):
        self.printGreeting()

    def printGreeting(self):
        print('Hi')

class MySubclass(MyClass):
    def printGreeting(self):
        print('Howdy')

myClass = MyClass(1)
mySubclass = MySubclass(1)
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    def __init__(self, var):
        self.__printGreeting()

    def printGreeting(self):
        print('Hi')

    __printGreeting = printGreeting   # private copy of original printGreeting() method

class MySubclass(MyClass):
    def printGreeting(self):
        print('Howdy')

myClass = MyClass(1)
mySubclass = MySubclass(1)
#+END_SRC

** Struct like classes

You can define an empty class and store data on that object (similar to C
structs)

#+BEGIN_SRC python :python python3 :results output
class MyClass:
    pass

a = MyClass()
a.x = 1
a.y = 2

b = MyClass()
b.x = 3
b.y = 4
print(a.x)
print(a.y)
print(b.x)
print(b.y)
#+END_SRC

** Iterators

Most container classes (collections such as tuples, dictionairies, lists, etc.)
can be looped over using the ~for~ statement

#+BEGIN_SRC python :python python3 :results output
for element in [1, 2, 3]:
    print(element)
print()
for element in (1, 2, 3):
    print(element)
print()
for key in {'one':1, 'two':2}:
    print(key)
print()
for char in "123":
    print(char)
print()
for line in open("mymodule.py"):
    print(line, end='')
#+END_SRC

To support this the underlying class must provide a method called ~__iter__()~
which should return an iterator. The iterator should provide a method called
~__next__()~ which will access each element one at a time. When there are no
more elements the ~__next__()~ should throw a ~StopIteration~ exception. E.g.

The
~__next__()~ method can also be called using ~next()~. E.g.

#+BEGIN_SRC python :python python3 :results output
s = 'abc'
iterator = s.__iter__()
print(iterator.__next__())
print(iterator.__next__())
print(iterator.__next__())
#print(iterator.__next__()) #This line will throw a StopIteration exception
#+END_SRC

You can also call these methods using the built functions ~iter()~ and ~next()~

#+BEGIN_SRC python :python python3 :results output
s = 'abc'
iterator = iter(s)
print(next(iterator))
print(next(iterator))
print(next(iterator))
#print(next(iterator)) #This line will throw a StopIteration exception
#+END_SRC

In the example below the class provides both ~__iter__()~ and ~__next__()~. Thus
can the ~__iter__()~ method return itself

#+BEGIN_SRC python :python python3 :results output
class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

for char in Reverse('Spam'):
   print(char)
#+END_SRC

** Generators

Generators can be used for creating iterators. You write them like regular
functions but they use the ~yield~ statement whenever they want to return data.
Each time ~__next__()~ is called the generator will continue where it left off.
They will also automatically raise a ~StopIteration~ exception when the
generator terminates. E.g.

#+BEGIN_SRC python :python python3 :results output
def reverse(data):
    for index in range(len(data)-1, -1, -1): # Remember that the endpoint is not
                                             # generated (why we use -1)
        yield data[index]

for char in reverse('golf'):
    print(char)
#+END_SRC

An iterator can be used for everything that a generator can be used for but
generators will automatically generate ~__next__()~ and ~__iter__()~ methods.

*** Generator expressions

Some simple generators can be coded as expressions using a syntax similar to
list comprehensions but with parentheses instead of square brackets. Generator
expressions are more compact but less versatile than full generator definitions
and tend to be more memory friendly than equivalent list comprehensions.

TODO: Why should we ever use a list comprehension?

#+BEGIN_SRC python :python python3 :results output
print(sum(i*i for i in range(10)))
print()

xvec = [10, 20, 30]
yvec = [7, 5, 3]
print(sum(x*y for x,y in zip(xvec, yvec)))
print()

from math import pi, sin
# Is this really a generator expression?
sine_table = {x: sin(x*pi/180) for x in range(0, 91)}
print(sine_table)
print()

data = 'golf'
print(list(data[i] for i in range(len(data)-1, -1, -1)))
#+END_SRC

* Errors and Exception
** Handling exceptions

The example below will throw a ~ValueError~ (as ~x~ is not an interger).

#+BEGIN_SRC python :python python3 :results output
x = 'x'
i = int(x)
print('Done')
#+END_SRC

We can catch the exception using the ~try~ clause

#+BEGIN_SRC python :python python3 :results output
x = 'x'
try:
    i = int(x)
except ValueError:
    print('Exception caught')
print('Done')
#+END_SRC

You can use multiple ~except~ clauses

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

for cls in [A, B]:
    try:
        raise cls
    except A:
        print('Exception caught: A')
    except B:
        print('Exception caught: B')
#+END_SRC

You can also catch several different exceptions using one ~except~ clause

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

for cls in [A, B]:
    try:
        raise cls
    except (A, B):
        print('Exception caught')
#+END_SRC

You can also assign the caught exception in a variable using

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

for cls in [A, B]:
    try:
        raise cls
    except (A, B) as e:
        print('Exception caught:', type(e))
#+END_SRC

You can also add a wild card ~except~ clause in the end which will catch
everything which hasn't been caught

#+BEGIN_SRC python :python python3 :results output
class A(Exception):
    pass

class B(Exception):
    pass

class C(Exception):
    pass

for cls in [A, B, C]:
    try:
        raise cls
    except (A, B) as e:
        print('Exception caught:', type(e))
    except:
        print('Unknown exception caught')
#+END_SRC

You can also raise the exception again after you have handled it

#+BEGIN_SRC python :python python3 :results output
try:
    1/0
except ZeroDivisionError as e:
    print('Exception caught')
    raise # The exception is raised again
    #raise e # In this case it looks like this line is added to the stack trace
#+END_SRC

You can also add an ~else~ clause to the ~try.. except~ statement that will only
be run if everything goes

#+BEGIN_SRC python :python python3 :results output
try:
    1/0
except:
    print('1: Exception caught')
else:
    print('1: Exception not caught')

try:
    0/1
except:
    print('2: Exception caught')
else:
    print('2: Exception not caught')
#+END_SRC

An exception can also have associated attributes. The arguments are stored in a
data attribute called ~args~. The ~__str__()~ method is defined so you can print
the arguments directly

#+BEGIN_SRC python :python python3 :results output
try:
    raise Exception('spam', 'eggs')
except Exception as inst:
    print(type(inst))    # the exception instance
    print(inst.args)     # arguments stored in .args
    print(inst)          # __str__ allows args to be printed directly,
                         # but may be overridden in exception subclasses
    x, y = inst.args     # unpack args
    print('x =', x)
    print('y =', y)
#+END_SRC

** Raising exceptions

You can raise an exception by using the ~raise~ statement. You can call this
using an instance of an exception type (a class that derives ~Exception~) or by
passing a exception class itself. If you pass the class it will be implicitly
instantiated by calling the zero argument constructor

#+BEGIN_SRC python :python python3 :results output
raise ValueError
# is a shorthand for
raise ValueError()
#+END_SRC

As mentioned above, if you want to see if an exception was raised but don't
intend to handle it you can raise it with no argument in the ~except~ clause

#+BEGIN_SRC python :python python3 :results output
try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
#+END_SRC

** Define your own exception

You create your own exception by sub-classing the ~Exception~ class (directly
or indirectly). Exception classes can do anything another class can do but
should be kept simple. When creating modules which can raise several kinds of
errors a good practive is to create a base class for the exceptions defined in
that module. A convention is also to define names that end with /error/

#+BEGIN_SRC python :python python3 :results output
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    """Raised when an operation attempts a state transition that's not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    """

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
#+END_SRC

** Clean up using ~finally~

The ~finally~ clause will always run when leaving the try statement. If there
was an uncaught exception of the exception was raised in an ~except~ clause or
the ~else~ clause then the exception will be raised again after the ~finally~
clause is completed.

#+BEGIN_SRC python :python python3 :results output
def divide(x, y):
    try:
        result = x / y
    except ZeroDivisionError:
        print("division by zero!")
    else:
        print("result is", result)
    finally:
        print("executing finally clause")

divide(2, 1)
divide(2, 0)
#divide("2", "1")
#+END_SRC

The ~finally~ clause will also be executed when the ~statement~ is left via e.g.
~break~, ~continue~ or ~return~

** Predefined clean-up actions

The following example will try to open a file and print its content to the
screen. The problem here is taht the file is not closed:

#+BEGIN_SRC python :python python3 :results output
for line in open("mymodule.py"):
    print(line, end="")
#+END_SRC

You can use the ~with~ statement to objects which provides predefined clean-up
actions. This ensures that the clean-up is always done even if an exception
occurs

#+BEGIN_SRC python :python python3 :results output
with open("mymodule.py") as f:
    for line in f:
        print(line, end="")
#+END_SRC

** Links

[[https://docs.python.org/3/library/exceptions.html][Exceptions]]

* Other
** Regular expressions

#+BEGIN_SRC python :python python3 :results output
import re

print(re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest'))
print(re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat'))
#+END_SRC

When simple substitutions are done you can use the ~replace~ method instead

#+BEGIN_SRC python :python python3 :results output
print('tea for too'.replace('too', 'two'))
#+END_SRC

** Execute scripts in linux

You can execute python scripts like other shell scripts by putting the line

#+BEGIN_SRC
#!/usr/bin/env python3
#+END_SRC

in the header. E.g.

#+BEGIN_SRC python :python python3 :results output
#!/usr/bin/env python3

print("Hello world!")
#+END_SRC

* Example programs
** Read command line arguments

#+BEGIN_SRC python :python python3 :results output :preamble import sys; sys.argv = ["1","2","a"]
# In the header of this block we have redefined sys.argv
import sys

print(len(sys.argv))
for arg in sys.argv:
    print(arg)
#+END_SRC

#+BEGIN_SRC python :python python3 :results output
import sys;
sys.stdout.write('Warning, log file not found starting a new one\n')
sys.stderr.write('Warning, log file not found starting a new one\n')

#+END_SRC

* ~pip~

You can use ~pip~ to install, upgrade or remove packages. By default ~pip~ will
install packages from the Python Package Index ([[https://pypi.org]]).

You can run ~pip~ in the Python repl or directly in the terminal by

#+BEGIN_SRC bash :results output
python3 -m pip search astronomy
#+END_SRC

You can install the latest version of a package by specifying the package name

#+BEGIN_SRC bash :results output
python3 -m pip install <package-name>
# E.g. python3 -m pip install novas
#+END_SRC

You can also install a specific version of a package by giving the package name
followed by ~==~ and the version of the package you're interested in

#+BEGIN_SRC bash :results output
python3 -m pip install <package-name>==<package-version>
# E.g. python3 -m pip install requests==2.6.0
#+END_SRC

If you want a different version of an already defined package you can just rerun
the command above with the other version. If you want to get the latest version
you can run

#+BEGIN_SRC bash :results output
python3 -m pip install --upgrade <package-name>
# E.g. python3 -m pip install --upgrade pip
#+END_SRC

To remove a package you can use the ~uninstall~ command followed by one or more
packages you wish to uninstall

#+BEGIN_SRC bash :results output
python3 -m pip uninstall <package>
# E.g. python3 -m pip uninstall novas
#+END_SRC

You can also display information about a package with the show command (must be
installed?)

#+BEGIN_SRC bash :results output
python3 -m pip show fros
#+END_SRC

To list the currently installed package on the machine (or in the current
[[https://docs.python.org/3/tutorial/venv.html][virtual environment]])

#+BEGIN_SRC bash :results output
python3 -m pip list
#+END_SRC

The ~freeze~ command will produce a similar list but the output will be
formatted the same way as ~pip install~ expects it

#+BEGIN_SRC bash :results output
python3 -m pip freeze
#+END_SRC

A common convention is to put the list in a ~requirements.txt~ file which you
ship your application with. A user can then install all the necessary packages
with the ~install -r~ command

#+BEGIN_SRC bash :results output
# Have not tested this code. Can it handle files outside repl?
python3 -m pip install -r requirements.txt
#+END_SRC

* Things that maybe isn't included in the tutorial

- Inner functions
- ~with~ keyword
- Formatted string literals

** Methods

- ~super()~
- ~getattr()~
- ~setattr()~
- ~delattr()~


* Links

- [[https://docs.python.org/3/library/index.html][The Python Standard Library]]
- [[https://docs.python.org/3/][Python documentation]]
- [[https://docs.python.org/3/reference/index.html#reference-index][The Python Language Reference]]
- [[https://pypi.org/][Python Package Index]]
- [[https://www.python.org/]]
- [[https://docs.python.org/3/library/functions.html][Built-in functions]]
