[[https://hub.docker.com]]

[[https://jonnylangefeld.github.io/learning/Docker/How%252Bto%252BDocker.html]]

[[https://docs.docker.com/engine/reference/builder/]]

* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#docker][Docker]]
  - [[#check-info-about-your-docker-installation][Check info about your docker installation]]
  - [[#run-a-container][Run a container]]
  - [[#list-containers][List containers]]
  - [[#stop-a-docker-container][Stop a docker container]]
  - [[#delete-a-container][Delete a container]]
  - [[#read-the-output-of-a-container-running-in-detached-mode][Read the output of a container running in detached mode]]
  - [[#images][Images]]
  - [[#run-a-ubuntu-container][Run a ubuntu container]]
  - [[#volumes][Volumes]]
- [[#dockerfile][Dockerfile]]
  - [[#copy-file-in-docker-container][Copy file in docker container]]
  - [[#run-a-jar-file-in-a-docker-image][Run a jar file in a docker image]]
  - [[#run-cmd-and-entrypoint-commands][~RUN~, ~CMD~ and ~ENTRYPOINT~ commands]]
  - [[#expose-command][~EXPOSE~ command]]
  - [[#volume-command][~VOLUME~ command]]
  - [[#user-command][~USER~ command]]
  - [[#healthcheck-command][~HEALTHCHECK~ command]]
  - [[#other-commands][Other commands]]
  - [[#more-advanced-example-with-python-installed][More advanced example with python installed]]
  - [[#tags][Tags]]
- [[#docker-compose][Docker compose]]
#+END_QUOTE

* Docker
** Check info about your docker installation

Show version

#+BEGIN_SRC
docker --version
#+END_SRC

Show more info about docker on the current maching

#+BEGIN_SRC
docker info
#+END_SRC

Show more information about the docker version

#+BEGIN_SRC
docker version
#+END_SRC

Show help about docker commands

#+BEGIN_SRC
docker --help
#+END_SRC

Some of the commands are not to be used anylonger. E.g. ~docker rmi~ is now
~docker image rm~. If you want to hide all legacy commands you can run

#+BEGIN_SRC
DOCKER_HIDE_LEGACY_COMMANDS=true docker --help
#+END_SRC

** Run a container
*** Run hello world

#+BEGIN_SRC bash
docker container run hello-world
#+END_SRC

Will return

#+BEGIN_SRC
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://cloud.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/
#+END_SRC

After this the container is terminated

*** A more advanced example

In this example we will run the ~jboss/wildfly~. For now it's interesting
because it's interesting because it will expose port ~8080~ and we can navigate
to a webpage.

#+BEGIN_SRC bash
docker container run -p 8080:8080 -it --name web jboss/wildfly
#+END_SRC

Then go to [[http://localhost:8080/]]

| Option                        | Description                                                                                                          |
|-------------------------------+----------------------------------------------------------------------------------------------------------------------|
| ~-it~                         | Run in interactive mode                                                                                              |
| ~-d~                          | Run in detached mode                                                                                                 |
| ~--name name~                 | Give the container a the name ~name~ instead of a random one                                                         |
| ~-P~                          | Expose the container port on random ports on the host system. use ~docker container ls~ to see which port was chosen |
| ~-p host_port:container_port~ | Instead of chosing a random port you can chose one yourself                                                          |

#+BEGIN_SRC bash
docker container run -P -d --name web2 jboss/wildfly
#+END_SRC

This time the container runs in a detached mode (the command returns
immediately). To see which port the container is exposing

#+BEGIN_SRC bash
docker container ls
#+END_SRC

My output is

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES
21093c981261        jboss/wildfly       "/opt/jboss/wildfly/…"   10 seconds ago      Up 8 seconds        0.0.0.0:32768->8080/tcp   web2
#+END_SRC

so if I connect to port ~32768~ on localhost it will be routed to my container's port ~8080~.

*** Overriding the container default command

You can also override the command starting in the container (in this case
starting wildfly) by providing your own command after the image name. E.g.

#+BEGIN_SRC bash
docker container run -it --name web3 jboss/wildfly bash # Run in interactive mode since we now only start bash
#+END_SRC

Now we can freely navigate inside the containers file system. If you would
expose port ~8080~ of the container you would still not see anything on
[[http://localhost:8080/]] since wildfly hasn't started

*** Attach a volume

#+BEGIN_SRC bash
docker container run -d --name web4 -p 8080:8080 -v `pwd`/webapp.war:/opt/jboss/wildfly/standalone/deployments/webapp.war jboss/wildfly
#+END_SRC

In this case we have made a file available for the container

| Option                                | Description                                                                                              |
|---------------------------------------+----------------------------------------------------------------------------------------------------------|
| ~-v host_location:container_location~ | Will make the file/dir at ~host_location~ on the host available at ~container_location~ in the container |

In this case wildfly will find our ~.war~ file and deploy it. To verify that the
~.war~ file is deployed you can run

#+BEGIN_SRC bash
curl http://localhost:8080/webapp/resources/persons
#+END_SRC

Remove all containers. For now we can run

#+BEGIN_SRC bash
docker container rm -f $(docker container ls -a -q)
#+END_SRC

** List containers

#+BEGIN_SRC bash
docker container ls
#+END_SRC

returns all running containers. If you run the [[*Run hello world][hello world]] example again you
will only see

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
#+END_SRC

The container is not running anylonger so nothing is printed. To also see exited
containers you will have to run

#+BEGIN_SRC bash
docker container ls -a
#+END_SRC

Will now return

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
3b383b36c992        hello-world         "/hello"            3 seconds ago       Exited (0) 1 second ago                       bold_feynman
#+END_SRC

** Stop a docker container

#+BEGIN_SRC bash
docker container stop <container>/<container_id>
#+END_SRC

*** Example

Run

#+BEGIN_SRC bash
docker container run -p 8080:8080 -d --name web jboss/wildfly
#+END_SRC

We already know that the name will be ~web~ but we can still find the id by
running

#+BEGIN_SRC bash
docker container ls
#+END_SRC

which returns

#+BEGIN_SRC
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
e39fc3ea0675        jboss/wildfly       "/opt/jboss/wildfly/…"   52 seconds ago      Up 50 seconds       0.0.0.0:8080->8080/tcp   web
#+END_SRC

We can now stop the container with

#+BEGIN_SRC bash
docker container stop web
# or
docker container stop e39fc3ea0675
#+END_SRC

You can now verify that the container has stopped with

#+BEGIN_SRC bash
docker container ls -a
#+END_SRC

** Delete a container

Just because a container is stopped doesn't mean that it has been removed. To
remove it you can run

#+BEGIN_SRC bash
docker container rm <container>/<container_id>
# or
docker container rm -f <container>/<container_id> # If you also want to be able to remove running containers
#+END_SRC

*** Example

#+BEGIN_SRC
$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES
e39fc3ea0675        jboss/wildfly       "/opt/jboss/wildfly/…"   2 minutes ago       Exited (0) 2 seconds ago                        web

$ docker container rm web
web

$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
#+END_SRC

*** Automatically remove a container after it stops

You can run a container with the ~--rm~ flag to remove it after it terminates.

#+BEGIN_SRC
$ docker container run -d --rm hello-world # Run the container in detached mode
6af1260e00c48224dc3c90601fbc1ac01bc62698c805c0faa6e290ee91e50c28

$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
#+END_SRC

*** Remove all exited containers

#+BEGIN_SRC bash
docker container rm $(docker container ls -a -f status=exited -q)
#+END_SRC

Other things to remove is described by [[https://www.digitalocean.com/community/tutorials/how-to-remove-docker-images-containers-and-volumes][this]] article.

** Read the output of a container running in detached mode

#+BEGIN_SRC bash
docker container logs <container>/<container_id>
#+END_SRC

Some useful options

| Option     | Description                                          |
|------------+------------------------------------------------------|
| ~-f~       | Follow log output                                    |
| ~--tail n~ | Show the ~n~ last lines in the log. Default is 'all' |
| ~-t~       | Show timestamps                                      |

*** Example

#+BEGIN_SRC
$ docker container run -d --name web jboss/wildfly
6dbd79e2d894abc81afba0777fa2ffae0744540a575515962818fdeb7819e77c

$ docker container logs web --tail 3
2020-04-01T20:58:16.009495544Z 20:58:16,009 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0060: Http management interface listening on http://127.0.0.1:9990/management
2020-04-01T20:58:16.009598742Z 20:58:16,009 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0051: Admin console listening on http://127.0.0.1:9990
2020-04-01T20:58:16.009762919Z 20:58:16,009 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly Full 18.0.1.Final (WildFly Core 10.0.3.Final) started in 3099ms - Started 315 of 577 services (369 services are lazy, passive or on-demand)
#+END_SRC

** Images
*** View images available for offline use

#+BEGIN_SRC bash
docker image ls
#+END_SRC

will now return

#+BEGIN_SRC
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
jboss/wildfly       latest              e6f71554a543        4 months ago        757MB
ubuntu              latest              775349758637        5 months ago        64.2MB
hello-world         latest              fce289e99eb9        15 months ago       1.84kB
#+END_SRC

*** Remove images

In order to free up some disk space you can remove an image with the command

#+BEGIN_SRC bash
docker image rm <image_name>
#+END_SRC

e.g.

#+BEGIN_SRC bash
docker image rm hello-world
#+END_SRC

** Run a ubuntu container

#+BEGIN_SRC bash
docker run -it --name my-linux-container ubuntu bash
#+END_SRC

The first time docker will pull the ubuntu image from the official docker hub.
Any command run in the container will only live there for this session. If you
create a file (~touch myfile~) it will only exist until the container exits (the
~exit~ command).

Try running ~docker ps -a~ from another terminal and you will see that you have
a container running.

If you exit the container and then start it again you will see that it starts up
very fast. This time we don't have to download the image

** Volumes

You can also create a container that refers to some local files with the ~-v~
flag. The syntax is

#+BEGIN_SRC
-v [absolute path to local]:[absulute path inside container]
#+END_SRC

I don't know what happens when referring to a local relative path but I couldn't
see any data and no data was persisted. Maybe the path is relative to soemthing
else but the current directory?

A full example would be

#+BEGIN_SRC bash
docker run -it --rm -v $PWD/my-shared-dir:/my-data ubuntu bash
#+END_SRC

If ~my-shared-dir~ doesn't exist in your home directory it will automatically be
created. Open the continer and create a file in the ~my-data~ directory and you
will see that it is created in the ~my-shared-dir~ directory.

* Dockerfile

We can also create our own images. Until now we have only used images created by
others. If the image is not found locally it will search at the [[https://hub.docker.com/][official docker hub]].
We create our own images by writing a file called ~Dockerfile~. I have prepared
a file at [[file:01_my-ubuntu-image/Dockerfile][01_my-ubuntu-image/Dockerfile]].

#+INCLUDE: 01_my-ubuntu-image/Dockerfile src Dockerfile

Almost always you will base your image on another image. That is what the ~FROM~
keyword means. In our file we based it on the ~ubuntu~ image. After that you can
execute any linux command you want with the ~CMD~ keyword.

Navigate to the folder where the ~Dockerfile~ is created and run

#+BEGIN_SRC bash
docker image build -t my-ubuntu-image .
#+END_SRC

This command will create a new image with the name ~my-ubuntu-image~. The dot at
the end tells the command to use the current directory as the context (and look
for the ~Dockerfile~ here). It's advisable to only have what you need in the
context so the docker client doesn't send uneccessary data to the docker host.
If that is not possible you can have a ~.dockerignore~ file. So create a new
directory for each ~Dockerfile~ you create. You will now see your newly created
image when you run the ~docker image ls~ command.

Try running your container with

#+BEGIN_SRC bash
docker container run --rm my-ubuntu-image
#+END_SRC

The string ~Hello world~ is printed. That is because we used the ~CMD~ command.
When we are using the ~CMD~ command we will overwrite the command from the
parent image (which in this case was ~/bin/bash~).

You can see how the image was build using

#+BEGIN_SRC bash
docker image history my-ubuntu-image
#+END_SRC

** Copy file in docker container
*** ~COPY~ instruction

Copy new files or directories to the container filesystem

#+BEGIN_SRC bash
COPY host_file container_destination
#+END_SRC

It seems like as if ~host_file~ must be in the context (same directory or sub
directories of the ~Dockerfile~) when building the image.

I have created an example ~Dockerfile~ using ~COPY~ at [[file:03_copy_example/Dockerfile][03_copy_example/Dockerfile]].
Notice how this file doesn't have a ~CMD~ command. If none is given the ~CMD~
used in the parent will be used. If you have multiple ~CMD~ commands only the
last one will be used.

Build the image by navigating to ~03_copy_example~ and run

#+BEGIN_SRC bash
docker image build -t helloweb .
#+END_SRC

Then run the container and send a request to see that it works

#+BEGIN_SRC bash
docker container run -d -p 8080:8080 helloweb

curl http://localhost:8080/webapp/resources/persons
#+END_SRC

*** ~ADD~ instruction

Allows tar file auto-extraction in the image. E.g:
~Add app.tar.gz /opt/var/myapp~- Can download files from a remote URL but
recommended to use ~curl~ or ~wget~ instead.

Investigate when this should be used

** Run a jar file in a docker image

I prepared a directory called ~04_java_jar~ with a [[file:04_java_jar/Dockerfile][Dockerfile]] and a simple java
project that will produce a jar. Build the java project with

#+BEGIN_SRC bash

#+END_SRC

and then build the docker image and run it.

To include docker with maven you can look at [[https://github.com/fabric8io/docker-maven-plugin]].

** ~RUN~, ~CMD~ and ~ENTRYPOINT~ commands
*** ~RUN~ command

Runs a command in the container file system when building an image

#+BEGIN_SRC Dockerfile
RUN apt-get update && apt-get install -y git # Update your system
# or
RUN /opt/jboss/wildfly/bin/add-user.sh admin Admin#007 -silent # Other command
#+END_SRC

*** ~CMD~ command

Defaults for executing container; can be [[*Overriding the container default command][overridden from CLI]]. A container can
have multiple ~CMD~ commands but only the last will run. If no ~CMD~ command is
provided the ~CMD~ from the parent container will be used.

#+BEGIN_SRC Dockerfile
CMD ["/opt/jboss/wildfly/bin/standalone.sh", "-b", "0.0.0.0", "-bmanagement", "0.0.0.0"]
# or
CMD java -jar /deployments/myapp-1.0-SNAPSHOT.jar
#+END_SRC

*** ~ENTRYPOINT~ command

configures the container executable; can be overridden using ~--entrypoint~ from
CLI. The default value is ~/bin/sh -c~

#+BEGIN_SRC Dockerfile
ENTRYPOINT ["/entrypoint.sh"]
#+END_SRC

Investigate more what this is good for..

** ~EXPOSE~ command

Expose network ports on which the container is listening

#+BEGIN_SRC Dockerfile
EXPOSE 9990
#+END_SRC

Need to explicitly publish the host port when starting the container (using ~-p~
or ~-P~, see [[*A more advanced example][this previous]] section).

** ~VOLUME~ command

Creates a mount point with the specified name

#+BEGIN_SRC Dockerfile
VOLUME /opt/couchbase/var
#+END_SRC

Then you can mount a file or directory on the host system to that mount point

#+BEGIN_SRC bash
docker container run ... -v data:/opt/couchbase/var
#+END_SRC

** ~USER~ command

Set the user name or UID to use when running the image. Investigate more why
this is needed

** ~HEALTHCHECK~ command

Performs a healthcheck on the application inside the container (and not only the
container itself).

#+BEGIN_SRC Dockerfile
HEALTHCHECK --interval=5s --timeout=3s CMD curl --fail http://localhost:8091/pools || exit 1
#+END_SRC

This will run the command ~curl --fail http://localhost:8091/pools || exit 1~
(administrative interface of couchbase) every 5 seconds and if it fails or
doesn't respond within 3 seconds the container will be marked as unhealthy.

** Other commands

LABEL. ENV, WORKDIR, ARG, ONBUILD, STOPSIGNAL, SHELL

** More advanced example with python installed

Now we want to create a ubuntu container with python already installed. I have
created a ~Dockerfile~ for this at [[file:02_my-python-image/Dockerfile][02_my-python-image/Dockerfile]].

#+INCLUDE: 02_my-python-image/Dockerfile src Dockerfile

We dont use the ~CMD~ command in this ~Dockerfile~ which means that we inherit
the ~CMD~ command from the ~ubuntu~ image (~/bin/bash~). But we are using the
~RUN~ keyword which executes any linux command during the build of the
container. So:

- The ~CMD~ keyword is for what will run as soon as you start up the container
(could be any ~.sh~ script of course to make it more elaborated)
- The ~RUN~ keyword is if you want to install anything inside your container

Each row in the ~Dockerfile~ will create a cached container. This is helpful
if we need to rebuild our container. To not create unneccessary caches we should
put as many commands as possible on one row. That's why we run 3 commands on the
same line in the ~Dockerfile~ instead of just using 3 ~RUN~ commands (which is
also acceptable).

Navigate to the folder where the ~Dockerfile~ is created and run

#+BEGIN_SRC bash
docker build -t my-python-image .
#+END_SRC

Then run the container with the following command

#+BEGIN_SRC bash
docker run -it my-python-image
#+END_SRC

When you are inside the container you can verify that python is installed with

#+BEGIN_SRC bash
python3 --version
#+END_SRC

** Tags
* Docker compose
