* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#tour][Tour]]
  - [[#hello-world][Hello world]]
  - [[#packages-and-imports][Packages and imports]]
  - [[#exported-names][Exported names]]
  - [[#functions][Functions]]
  - [[#variables][Variables]]
  - [[#basic-types][Basic types]]
  - [[#loops][Loops]]
  - [[#if-statement][If statement]]
  - [[#switch-statement][Switch statement]]
  - [[#defer][Defer]]
  - [[#pointers][Pointers]]
  - [[#structs][Structs]]
  - [[#arrays][Arrays]]
  - [[#slices][Slices]]
  - [[#range][Range]]
  - [[#maps][Maps]]
  - [[#function-values][Function values]]
  - [[#function-closures][Function closures]]
  - [[#exercise-fibonacci-closure][Exercise: Fibonacci closure]]
- [[#other-sample-programs][Other sample programs]]
- [[#links][Links]]
- [[#questions][Questions]]
#+END_QUOTE

* Tour

To run [[https://tour.golang.org/][the official golang tour]] locally run:

#+BEGIN_SRC bash
go install golang.org/x/website/tour@latest

# The call above should have created a binary called 'tour' in the GOPATH bin directory.
# My GOPTH variable wasn't set and I could find it under $HOME/go/bin/tour
$HOME/go/bin/tour
#+END_SRC

** Hello world

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	fmt.Println("Hello, world")
}
#+END_SRC

** Packages and imports

Every Go program is made up of packages. Programs start running in package
~main~.

By convention, the package name is the same as the last element of the import
path. For instance, the ~math/rand~ package comprises files that begin with the
statement package ~rand~.


#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func main() {
	// If you don't enter a seed yourself it will be treated as if it was rand.Seed(1)
	rand.Seed(time.Now().UTC().UnixNano())
	fmt.Println("My favorite number is", rand.Intn(10))
}
#+END_SRC

In the example above the imports are grouped into a /factored/ import statement.
You can also write multiple import statements like:

#+BEGIN_SRC go
import "fmt"
import "time"
import "math/rand"
#+END_SRC

But it is good style to use the factored import statement.

** Exported names

A name is only exported if it begins with a capital letter. In a package, the
name ~Pizza~ would be exported while ~pasta~ wouldn't be exported.

So when importing a package you can only refer to the exported names.

So names with beginning with a capital letter are public while all other are
private.

** Functions

A function can take zero or more arguments. Unlike java the types of the
arguments are placed after the variable name, and the return type after the
arguments.

For more information about the declaration syntax:
https://blog.golang.org/declaration-syntax

#+BEGIN_SRC go :results output
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
#+END_SRC

If multiple consecutive arguments have the same type you can omit the type for
all variable but the last. The example above now looks like:

#+BEGIN_SRC go :results output
package main

import "fmt"

func add(x, y int) int { // <-- Look here
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
#+END_SRC

Like python a function can return multiple results:

#+BEGIN_SRC go :results output
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
#+END_SRC

Go supports naming the return values. Then you define them as variables at the
top of the function.

A ~return~ statement without arguments returns the named return values. This is
known as a "naked" return.

Naked return statements should be used only in short functions.

If you provide an argument to the return statement it looks like as if the named
return values are ignored.

#+BEGIN_SRC go :results output
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
	//return 1, 2
}

func main() {
	fmt.Println(split(17))
}
#+END_SRC

** Variables

The ~var~ statement declares a list of variables; as in function argument lists,
the type is last.

A ~var~ statement can be at package or function level. In the example below it
looks like as if booleans are initialized to ~false~ and ints to ~0~.

#+BEGIN_SRC go :results output
package main

import "fmt"

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
#+END_SRC

You can initilize them manually during declaration as well. If an initializer is
present, the type can be omitted; the variable will take the type of the
initializer.

#+BEGIN_SRC go :results output
package main

import "fmt"

// Declaration with type
var i, j int = 1, 2

func main() {
	// Declaration without type
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
#+END_SRC

Go also supports /short variable declarations/ inside functions. You can then
use ~:=~ in place of a ~var~ declaration with implicit type. Note that this
can't be used outside a function!

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, "no!"

	fmt.Println(i, j, k, c, python, java)
}
#+END_SRC

** Basic types

| Type         | Alias  | Comment                                                                   |
|--------------+--------+---------------------------------------------------------------------------|
| ~bool~       |        |                                                                           |
| ~string~     |        |                                                                           |
| ~int~        |        | Usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems |
| ~int8~       |        |                                                                           |
| ~int16~      |        |                                                                           |
| ~int32~      | ~rune~ | ~rune~ represents a Unicode code point.                                   |
| ~int64~      |        |                                                                           |
| ~uint~       |        | Usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems |
| ~uint8~      | ~byte~ |                                                                           |
| ~uint16~     |        |                                                                           |
| ~uint32~     |        |                                                                           |
| ~uint64~     |        |                                                                           |
| ~uintptr~    |        | Usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems |
| ~float32~    |        |                                                                           |
| ~float64~    |        |                                                                           |
| ~complex64~  |        |                                                                           |
| ~complex128~ |        |                                                                           |

When you need an integer value you should use int unless you have a specific
reason to use a sized or unsigned integer type.

In the example below you can see how also variable declarations can be factored
like imports. You also see that you can print the type of a variable in the
~Printf~ statement.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
#+END_SRC

Variable declarations without an explicit initial value are given their ~zero~
value.

| Type          | Zero value |
|---------------+------------|
| Numeric types | ~0~        |
| ~bool~        | ~false~    |
| ~string~      | ~""~       |
| Pointers      | ~nil~      |
| Slices        | ~nil~      |
| Maps          | ~nil~      |

*** Type conversions

The expression ~T(v)~ converts the value ~v~ to the type ~T~.

Unlike in C, in Go assignment between items of different type requires an
explicit conversion. Try removing the ~float64~ or ~uint~ conversions in the
example and see what happens.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	fmt.Println(x, y, z)
}
#+END_SRC

*** Type inference

When declaring a variable without specifying an explicit type the variable's
type is inferred from the value on the right hand side.

This is easy when the right hand side is a variable with already a type but when
the right hand side contains an untyped numeric constant, the new variable may be
an ~int~, ~float64~, or ~complex128~ depending on the precision of the constant:

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	v0 := 42
	v1 := 3.142
	v2 := 0.867 + 0.5i
	// The following variable would fit in an uint64 but returns an error that it overflows int
	//v3 := 9223372036854775808
	//var v3 uint64 = 9223372036854775808
	fmt.Printf("v0 is of type %T\n", v0)
	fmt.Printf("v1 is of type %T\n", v1)
	fmt.Printf("v2 is of type %T\n", v2)
	//fmt.Printf("v3 is of type %T\n", v3)
}
#+END_SRC

*** Constants

Constants are declared like variables, but with the ~const~ keyword instead of
~var~ (and can't use the ~:=~ syntax). Constants can be character, string,
boolean, or numeric values (TODO: No structs?)

TODO: Constants starts with capital letter? What about exported names?

#+BEGIN_SRC go :results output
package main

import "fmt"

const Pi = 3.14

func main() {
	const Name = "World"
	fmt.Println("Hello", Name)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
#+END_SRC

Numeric constants are high-precision values. An untyped constant takes the type
needed by its context. It looks like as if the contant doesn't have a type until
it is used. In the example below you can try to print the type of ~Small~ and
~Big~. ~Small~ will return ~int~ (I guess it get's the type by the ~Printf~
functions) while ~Big~ will return an overflow error.

Constant declarations can be factored like variables and imports.

#+BEGIN_SRC go :results output
package main

import "fmt"

const (
	// Create a huge number by shifting a 1 bit left 100 places.
	// In other words, the binary number that is 1 followed by 100 zeroes.
	Big = 1 << 100
	// Shift it right again 99 places, so we end up with 1<<1, or 2.
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
	fmt.Printf("%T", Small)
	//fmt.Printf("%T", Big)
}
#+END_SRC

** Loops

In go the only looping construct that exists is the ~for~ loop.

You don't parentheses around the three components of the ~for~ statement and
the braces are always required.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
#+END_SRC

The init and post statements are optional (effectively making this a ~while~
loop):

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
#+END_SRC

If you do this you can drop the semicolons:

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
#+END_SRC

To loop something forever you can drop the loop condition completely:

#+BEGIN_SRC go
package main

import "fmt"

func main() {
	for {
		fmt.Println("Hello")
	}
}
#+END_SRC

** If statement

Like the ~for~ statement, the expression need not be surrounded by parentheses
but the braces are required.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
#+END_SRC

In go you can also have a /short statement/ to execute before the condition.
Variables declared by the statement are only in scope until the end of the ~if~.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
#+END_SRC

Variables declared inside an ~if~ short statement are also available inside any
of the ~else~ blocks.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
#+END_SRC

Calculate the square root of a number using [[https://en.wikipedia.org/wiki/Newton%27s_method][Newton's method]]:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func MySqrt(x float64) float64 {
	z := 1.0

	for i := 0; i < 10; i++ {
		z -= (z*z - x) / (2*z)
	}
	return z
}

func main() {
	number := 99.0
	fmt.Println(MySqrt(number))
	fmt.Println(math.Sqrt(number))
}

#+END_SRC

** Switch statement

Go's ~switch~ is like the one in Java except that Go only runs the selected
case, not all the cases that follow. In effect, the ~break~ statement that is
needed at the end of each case in those languages is provided automatically in
Go. Another important difference is that Go's ~switch~ cases need not be
constants, and the values involved need not be integers.

In the example below you can also see the use of a /short statement/ like in the
~if~ statement.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"runtime"
)

var linuxOs = "linux"

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case linuxOs: // A variable instead of a constant
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
}
#+END_SRC

As expected, cases are evaluated from top to bottom, stopping when a case
succeeds:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
#+END_SRC

You can also make match against the result of function call:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
)

func myFunc() int {
	return 2
}

func main() {
	myVar := 2
	switch myVar {
	case 0:
		fmt.Println("It's 0")
	case myFunc():
		fmt.Println("Function matched!")
	default:
		fmt.Println("Something else")
	}
}
#+END_SRC

If you don't provide a switch condition it is the same as ~switch true~. This
can be used as a clean way to write long if-then-else chains:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
#+END_SRC

** Defer

A ~defer~ statement defers the execution of a function until the surrounding
function returns.

The deferred call's arguments are evaluated immediately, but the function call
is not executed until the surrounding function returns.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}

#+END_SRC

Deferred function calls are pushed onto a stack. When a function returns, its
deferred calls are executed in last-in-first-out order.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
#+END_SRC

TODO: When can this be used?

** Pointers

The type ~*T~ is a pointer to a ~T~ value. Its zero value is ~nil~.

#+BEGIN_SRC go
var p *int // Pointer to an int
#+END_SRC

The ~&~ operator generates a pointer to its operand

#+BEGIN_SRC go
i := 42 // i is an int
p = &i // p is a pointer to the memory address that holds the value of i
#+END_SRC

The ~*~ operator denotes the pointer's underlying value.

#+BEGIN_SRC go
fmt.Println(*p) // read i through the pointer p
*p = 21         // set i through the pointer p
#+END_SRC

This is known as "dereferencing" or "indirecting".

Unlike C, Go has no pointer arithmetic.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	*p = 21         // set i through the pointer
	fmt.Println(i)  // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(j) // see the new value of j
}
#+END_SRC

** Structs

A ~struct~ is a collection of fields:

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
#+END_SRC

The fields of a struct can be accessed using a ~.~:

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
	fmt.Println(v)
}
#+END_SRC

Struct fields can be accessed through a struct pointer. In C you would use the
~->~ operator but in go you just use ~.~ again. So instead of writing ~(*p).X~
you can just use ~p.X~:

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}
#+END_SRC

When instantiating a struct you don't have to provide all the values. You can
list just a subset of fields by using the ~FieldName: value~ syntax. (And the
order of named fields is irrelevant.)

The special prefix ~&~ returns a pointer to the struct value.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)

func main() {
	fmt.Println(v1, p, v2, v3)
}
#+END_SRC

** Arrays

The type ~[n]T~ is an array of ~n~ values of type ~T~. The expression

#+BEGIN_SRC go
var a [10]int
#+END_SRC

declares a variable a as an array of ten integers. An array's length is part of
its type, so arrays cannot be resized.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Println(primes)
}
#+END_SRC

** Slices

An array has a fixed size. A slice, on the other hand, is a dynamically-sized,
flexible view into the elements of an array. In practice, slices are much more
common than arrays.

The type ~[]T~ is a slice with elements of type ~T~.

A slice is formed by specifying two indices, a low and high bound, separated by
a colon:

#+BEGIN_SRC go :results output
a[low : high]
#+END_SRC

This selects a half-open range which includes the first element, but excludes
the last one.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}

	var s []int = primes[1:4]
	fmt.Println(s)
}
#+END_SRC

A slice does not store any data, it just describes a section of an underlying
array. Changing the elements of a slice modifies the corresponding elements of
its underlying array. Other slices that share the same underlying array will see
those changes.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	names := [4]string{
		"John",
		"Paul",
		"George",
		"Ringo",
	}
	fmt.Println(names)

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b)

	b[0] = "XXX"
	fmt.Println(a, b)
	fmt.Println(names)
}
#+END_SRC

When slicing, you may omit the high or low bounds to use their defaults instead.

The default is zero for the low bound and the length of the slice for the high bound.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)

	s = s[:2]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)

	s = s[:]
	fmt.Println(s)
}
#+END_SRC

*** Slice literals

A slice literal is like an array literal without the length. This is an array literal:

#+BEGIN_SRC go :results output
[3]bool{true, true, false}
#+END_SRC

And this creates the same array as above, then builds a slice that references it:

#+BEGIN_SRC go :results output
[]bool{true, true, false}
#+END_SRC

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	q := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(q)

	r := []bool{true, false, true, true, false, true}
	fmt.Println(r)

	s := []struct {
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}
	fmt.Println(s)
}
#+END_SRC

TODO: When do I want to use a slice literal instead of an array literal?

*** Slice length and capacity

A slice has both a /length/ and a /capacity/.

- The length of a slice is the number of elements it contains.
- The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.

The length and capacity of a slice s can be obtained using the expressions
~len(s)~ and ~cap(s)~.

You can extend a slice's length by re-slicing it, provided it has sufficient
capacity. Changing beyond its capacity you get a runtime error.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

*** Nil slices

The zero value of a slice is ~nil~.

A nil slice has a length and capacity of 0 and has no underlying array.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var s []int
	fmt.Println(s, len(s), cap(s))
	if s == nil {
		fmt.Println("nil!")
	}
}
#+END_SRC

*** Dynamically sized slices

Slices can be created with the built-in ~make~ function; this is how you create
dynamically-sized arrays. The ~make~ function allocates a zeroed array and
returns a slice that refers to that array:

#+BEGIN_SRC go :results output
a := make([]int, 5)  // len(a)=5
#+END_SRC

To specify a capacity, pass a third argument to make:

#+BEGIN_SRC go :results output
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
#+END_SRC

Longer example

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)

	b := make([]int, 0, 5)
	printSlice("b", b)

	c := b[:2]
	printSlice("c", c)

	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
#+END_SRC

*** Slices of slices

Slices can contain any type, including other slices.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"strings"
)

func main() {
	// Create a tic-tac-toe board.
	board := [][]string{
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
	}

	// The players take turns.
	board[0][0] = "X"
	board[2][2] = "O"
	board[1][2] = "X"
	board[1][0] = "O"
	board[0][2] = "X"

	for i := 0; i < len(board); i++ {
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}
}
#+END_SRC

*** Appending to a slice

It is common to append new elements to a slice, and so Go provides a built-in
~append~ function.

#+BEGIN_SRC go
func append(s []T, elems ...T) []T
#+END_SRC

The first parameter ~s~ of append is a slice of type ~T~, and the rest are ~T~
values to append to the slice.

The resulting value of append is a slice containing all the elements of the
original slice plus the provided values.

If the backing array of s is too small to fit all the given values a bigger
array will be allocated. The returned slice will point to the newly allocated
array. When this happens, the updates to the slice will no longer be backed by
the old array.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var s []int
	printSlice(s)

	// append works on nil slices.
	s = append(s, 0)
	printSlice(s)

	// The slice grows as needed.
	s = append(s, 1)
	printSlice(s)

	// We can add more than one element at a time.
	s = append(s, 2, 3, 4)
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

** Range

The ~range~ form of the ~for~ loop iterates over a slice or map. When ranging
over a slice, two values are returned for each iteration. The first is the
index, and the second is a copy of the element at that index.

#+BEGIN_SRC go :results output
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
		fmt.Printf("2**%d = %d\n", i, v)
	}
}
#+END_SRC

If you for some reason don't care about the index or the element you can
replace the variable with a ~_~. E.g.

#+BEGIN_SRC go :results output
for i, _ := range pow
for _, value := range pow

// If you only want the index you can completely omit the second variable
for i := range pow
#+END_SRC

Example:

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1 << uint(i) // == 2**i
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
#+END_SRC

** Maps

The zero value of a map is ~nil~. A ~nil~ map has no keys, nor can keys be
added.

The ~make~ function returns a map of the given type, initialized and ready for
use.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
#+END_SRC

*** Map literals

Map literals are like struct literals, but the keys are required.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
#+END_SRC

If the top-level type is just a type name, you can omit it from the elements of
the literal.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
#+END_SRC

*** Mutating maps

Insert or update an element in map ~m~:

#+BEGIN_SRC go :results output
m[key] = elem
#+END_SRC

Retrieve an element:

#+BEGIN_SRC go :results output
elem = m[key]
#+END_SRC

Delete an element:

#+BEGIN_SRC go :results output
delete(m, key)
#+END_SRC

Test that a key is present with a two-value assignment:

#+BEGIN_SRC go :results output
elem, ok = m[key]
#+END_SRC

If ~key~ is in ~m~, ~ok~ is ~true~. If not, ~ok~ is ~false~. If ~key~ is not in
the map, then ~elem~ is the zero value for the map's element type.

*Note:* If elem or ok have not yet been declared you could use a short declaration form:

#+BEGIN_SRC go :results output
elem, ok := m[key]
#+END_SRC

Longer example

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Answer"] = 42
	fmt.Println("The value:", m["Answer"])

	m["Answer"] = 48
	fmt.Println("The value:", m["Answer"])

	delete(m, "Answer")
	fmt.Println("The value:", m["Answer"])

	v, ok := m["Answer"]
	fmt.Println("The value:", v, "Present?", ok)
}
#+END_SRC

** Function values

Functions can be used as both function arguments and return values.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}
	fmt.Println(hypot(5, 12))

	fmt.Println(compute(hypot))
	fmt.Println(compute(math.Pow))
}
#+END_SRC

** Function closures

Go functions may be closures. A closure is a function value that references
variables from outside its body. The function may access and assign to the
referenced variables; in this sense the function is "bound" to the variables.

For example, the ~adder~ function returns a closure. Each closure is bound to
its own ~sum~ variable.

#+BEGIN_SRC go :results output
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
#+END_SRC

** Exercise: Fibonacci closure

#+BEGIN_SRC go :results output
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
	a := 0
	b := 1

	return func() int {
		t := a
		a, b = b, a + b
		return t
	}
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
#+END_SRC

* Other sample programs

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
}
#+END_SRC

* Links

- https://blog.golang.org/defer-panic-and-recover
- https://blog.golang.org/slices-intro
- https://pkg.go.dev/std
- https://golang.org/ref/spec#Composite_literals (https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go)

* Questions

- Equality. Floats and strings
- Exception handling?
- For loops: break and continue
