* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#work-around-to-execute-haskell-programs-in-org-mode][Work around to execute haskell programs in org mode]]
- [[#basics][Basics]]
  - [[#basic-arithmetic][Basic arithmetic]]
  - [[#basic-logic-operators][Basic logic operators]]
  - [[#calling-functions][Calling functions]]
  - [[#defining-functions][Defining functions]]
  - [[#the-if-statement][The ~if~ statement]]
  - [[#lists][Lists]]
  - [[#tuples][Tuples]]
- [[#types][Types]]
  - [[#type-keywords][Type keywords]]
  - [[#type-variables][Type variables]]
  - [[#type-classes][Type classes]]
- [[#syntax-in-functions][Syntax in functions]]
  - [[#pattern-matching][Pattern matching]]
  - [[#guards][Guards]]
  - [[#the-where-keyword][The ~where~ keyword]]
  - [[#the-let-keyword][The ~let~ keyword]]
  - [[#case-expressions][Case expressions]]
- [[#some-recursion-examples][Some recursion examples]]
  - [[#maximum][Maximum]]
  - [[#replicate][Replicate]]
  - [[#take][Take]]
  - [[#reverse][Reverse]]
  - [[#repeat][Repeat]]
  - [[#zip][Zip]]
  - [[#elem][Elem]]
  - [[#quick-sort][Quick sort]]
- [[#higher-order-functions][Higher order functions]]
  - [[#partially-applied-functions][Partially applied functions]]
  - [[#functions-as-parameters][Functions as parameters]]
  - [[#the-map-and-filter-funtions][The ~map~ and ~filter~ funtions]]
  - [[#lambdas][Lambdas]]
  - [[#folds][Folds]]
  - [[#function-application-with-the--function][Function application with the ~$~ function]]
  - [[#function-composition][Function composition]]
- [[#modules][Modules]]
  - [[#creating-own-modules][Creating own modules]]
  - [[#some-links][Some links]]
- [[#links][Links]]
#+END_QUOTE

* Work around to execute haskell programs in org mode

Executable code but syntax highlighting is set to python

#+BEGIN_SRC  python :python runghc :results output
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

Correct syntax highlighting but not executable

#+BEGIN_SRC  haskell
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

To toggle between these two modes you can run the ~toggleedit~ script. Note that
the two code blocks above have an extra space before the language name so that
they will not be affected by the script. The code block below will be affected
though

#+BEGIN_SRC haskell
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

* Basics
** Basic arithmetic

#+BEGIN_SRC haskell
main = do
  -- Addition
  print (2 + 2)
  -- Subtraction
  print (5 - 2)
  -- Multiplication
  print (5 * 5)
  -- Division (not integer division)
  print (5 / 2)
  -- Integer division
  print (div 5 2)
  -- Modulo
  print (mod 2 (-3))
  print (rem 2 (-3))
  -- Change precedence with parentheses
  print (2 + 2 * 2)
  print ((2 + 2) * 2)
#+END_SRC

When working with negative number, always enclose them in parentheses. The
example below won't work

#+BEGIN_SRC haskell
main = do
  print (5 * -3)
#+END_SRC

While the following will

#+BEGIN_SRC haskell
main = do
  print (5 * (-3))
#+END_SRC

** Basic logic operators

#+BEGIN_SRC haskell
main = do
  -- And
  print (True && True)
  print (True && False)
  -- Or
  print (True || False)
  print (False || False)
  -- Not
  print (not (True && False))
  print (not True)
#+END_SRC

Testing equality

#+BEGIN_SRC haskell
main = do
  -- Equality
  print (9 == 9)
  print (8 == 9)
  print ("hello" == "hello")
  -- Inequality
  print (9 /= 9)
  print (8 /= 9)
#+END_SRC

~==~ and ~/=~ will only work if the two elements can be compared. The following
will now work

#+BEGIN_SRC haskell
main = do
  print (4 /= "hello")
#+END_SRC

But sometimes objects of different types can be compared. E.g. integers and
floats. In the following example the integer will be converted to a float

#+BEGIN_SRC haskell
main = do
  print (4.0 == 4)
#+END_SRC

Comparing number

#+BEGIN_SRC haskell
main = do
  print (4 < 5)
  print (5 < 4)
  print (4 > 5)
  print (5 > 4)
  print (4 <= 5)
  print (5 <= 5)
  print (4 >= 5)
  print (5 >= 5)
#+END_SRC

** Calling functions

In haskell no parantheses should be used when providing the arguments to a
function. You just separate all arguments with a space. In the following
examples we still use parantheses for the ~print~ function. Otherwise ~succ 8~
would be treated a two arguments to the ~print~ function instead of a function
call itself

#+BEGIN_SRC haskell
main = do
  print (succ 8)
#+END_SRC

Multiple arguments

#+BEGIN_SRC haskell
main = do
  print (min 8 15)
  print (max 6.4 2)
#+END_SRC

A function call has the highest precedence so you don't need to put parantheses
around it

#+BEGIN_SRC haskell
main = do
  print (succ 9 + max 5 4 + 1)
  print ((succ 9) + (max 5 4) + 1)
  print (succ 8 * 2)
  print (succ (8 * 2))
#+END_SRC

You can make a function /infix/ by putting backticks around the function name

#+BEGIN_SRC haskell
main = do
  print (div 11 3)
  print (11 `div` 3)
#+END_SRC

If a function is comprised only of special characters, it's considered an infix
function by default. If we want to pass it to another function or call it as a
prefix function, we have to surround it in parentheses.

#+BEGIN_SRC haskell
main = do
  print ((==) 11 3)
  print ((==) 3 3)
#+END_SRC

** Defining functions

The following code defines a function that will double the input value

#+BEGIN_SRC haskell
doubleMe x = x + x

main = do
  print (doubleMe 5)
#+END_SRC

The order the functions are defined doesn't matter

#+BEGIN_SRC haskell
main = do
  print (doubleMe 5)

doubleMe x = x + x
#+END_SRC

Note that the ~doubleMe~ function doesn't specify a type so any type where the
~+~ operator can be applied can be used

#+BEGIN_SRC haskell
doubleMe x = x + x

main = do
  print (doubleMe 5)
  print (doubleMe 8.3)
#+END_SRC

Let us define 2 functions that double 2 input values and sums them together

#+BEGIN_SRC haskell
doubleMe x = x + x

doubleUs x y = 2 * x  + 2 * y
doubleUs2 x y = doubleMe x  + doubleMe y

main = do
  print (doubleUs 3 4)
  print (doubleUs2 3 4)
#+END_SRC

And let us define a function with no arguments

#+BEGIN_SRC haskell
numberOne = 1

main = do
  print (numberOne)
#+END_SRC

*** Naming

A function can't start with a capital letter and ~'~ is a valid character to
use. It is often used to denote a strict version of a function (one that isn't
lazy) or a slightly modified version of a function or a variable

** The ~if~ statement

Unlike other languages the ~else~ part is mandatory in Haskell. The ~if~
statement is an expression in Haskell as it has a return value. Below we are
writing the ~if~ statement on multiple lines but we can write it all on the same
line if we wanted to

#+BEGIN_SRC haskell
doubleOddNumber x = if x `mod` 2 == 0
                      then x
                      else x * 2

main = do
  print (doubleOddNumber 6)
  print (doubleOddNumber 5)
  print (doubleOddNumber (-4))
  print (doubleOddNumber (-7))
#+END_SRC

Since the ~if~ statement have a return value we can easily add 1 to the result

#+BEGIN_SRC haskell
doubleOddNumberAndAddOne x = (if x `mod` 2 == 0
                                then x
                                else x * 2) + 1

main = do
  print (doubleOddNumberAndAddOne 6)
  print (doubleOddNumberAndAddOne 5)
  print (doubleOddNumberAndAddOne (-4))
  print (doubleOddNumberAndAddOne (-7))
#+END_SRC

** Lists

In Haskell lists stores data of the same type so we can't have a list which both
store integers and characters. The ~let~ keyword is used in Haskell to define a
name

#+BEGIN_SRC haskell
main = do
  let myNumberList = [1,2,4,8,16,32]
  print myNumberList
  let myCharList = ['C','h','a','r','s']
  print myCharList
  let myStringList = ["My","String", "List"]
  print myStringList
#+END_SRC

As you see from the output of ~myCharList~ above, a string is a list of chars

#+BEGIN_SRC haskell
main = do
  print ("Chars" == ['C','h','a','r','s'])
#+END_SRC

Since strings are list we can use list functions on them

*** Concatenate lists

Concatenation is done with the ~++~ operator. Note that it can also be used on
strings which are nothing but a list of characters

#+BEGIN_SRC haskell
main = do
  print ([1,2,3,4] ++ [5,6,7,8])
  print ("Hello" ++ " " ++ "World")
  print (['H','a','s'] ++ ['k','e','l','l'])
#+END_SRC

Note that when you concatenate two lists, Haskell will internally walk through
all elements on the left hand side of the ~++~. This may affect performance for
big left hand side lists. Note that putting something at the beginning of a list
using the cons operator (~:~) is instantaneous

#+BEGIN_SRC haskell
main = do
  print (1:[2,3,4])
  print ('H':"ello World")
#+END_SRC

Note that ~++~ accepts two lists as arguments while ~:~ accepts an element and a
list. ~[1,2,3]~ is actually just syntactic sugar for ~1:2:3:[]~ (~[]~ is the
empty list).

*** Get an element in a list

To get an element at a specific index in the list we use the ~!!~ operator. The
index starts at 0.

#+BEGIN_SRC haskell
main = do
  let myIntegerList = [1,2,4,8,16,32]
  print (myIntegerList !! 1)
  print (myIntegerList !! 4)
#+END_SRC

*** Lists of lists

A list can contain of other lists. As before each element in a list needs to be
of the same type which means that all lists in a list of lists needs to contain
the same type of element, e.g. integers. The lists can be of different lengths.

#+BEGIN_SRC haskell
main = do
  let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
  print b
  print (b ++ [[3,2,1]])
  print ([3,2,1]:b)
  print (b !! 1)
#+END_SRC

*** Comparing lists

Lists can be compared with ~<~, ~<=~, ~>~ and ~>=~ if the elements the list
contains can be compared with these operators. The elements in the lists are
compared in order and if the elements on a index is equal the next pairs will
be compared

#+BEGIN_SRC haskell
main = do
  print ([3,2,1] > [2,1,0])
  print ([3,2,1] > [2,10,100])
  print ([3,4,2] > [3,4]) -- [3,4,2] is considered bigger as it has an extra element
  print ([3,4] > [3,4,2])
  print ([3,4,2] > [2,4])
  print ([3,4,2] == [3,4,2])
#+END_SRC

*** Other functions

~head~ returns the first element in a list

#+BEGIN_SRC haskell
main = do
  print (head [3,2,1])
#+END_SRC

~tail~ returns everything but the head

#+BEGIN_SRC haskell
main = do
  print (tail [4,3,2,1,0])
#+END_SRC

~last~ returns the last element in a list

#+BEGIN_SRC haskell
main = do
  print (last [4,3,2,1,0])
#+END_SRC

~init~ returns everything but the last element

#+BEGIN_SRC haskell
main = do
  print (init [4,3,2,1,0])
#+END_SRC

~length~ returns the length of a list

#+BEGIN_SRC haskell
main = do
  print (length [4,3,2,1,0])
#+END_SRC

~null~ checks if a list is empty. Returns ~True~ if empty. To be used instead of
checking for equality with ~[]~

#+BEGIN_SRC haskell
main = do
  print (null [4,3,2,1,0])
  print (null [])
#+END_SRC

~reverse~ reverses a list

#+BEGIN_SRC haskell
main = do
  print (reverse [4,3,2,1,0])
#+END_SRC

~take~ returns the first ~x~ elements from a list. Can be used on infinite
sequences

#+BEGIN_SRC haskell
main = do
  print (take 3 [4,3,2,1,0])
  print (take 8 [4,3,2,1,0])
  print (take 0 [4,3,2,1,0])
#+END_SRC

~drop~ is the opposite of ~take~. We return everything but the first ~x~
elements

#+BEGIN_SRC haskell
main = do
  print (drop 3 [4,3,2,1,0])
  print (drop 8 [4,3,2,1,0])
  print (drop 0 [4,3,2,1,0])
#+END_SRC

~maximum~ and ~minimum~ returns the largest or smallest element if the elements
can be compared

#+BEGIN_SRC haskell
main = do
  print (maximum [4,3,20,-4,1,0])
  print (minimum [4,3,20,-4,1,0])
#+END_SRC

~sum~ and ~product~ returns the sum or product of a list of numbers

#+BEGIN_SRC haskell
main = do
  print (sum [1,2,3,4])
  print (product [1,2,3,4])
#+END_SRC

~elem~ checks if an element is present in a list

#+BEGIN_SRC haskell
main = do
  print (2 `elem` [1,2,3,4])
  print (5 `elem` [1,2,3,4])
#+END_SRC

*** Texas ranges

If you want to create a list with all numbers ranging from 1 to 50 you can
create the list and provide each number individually. Or you can just write
~[1..50]~. You can do something similar with characters

#+BEGIN_SRC haskell
main = do
  print ([1..50])
  print (['a'..'z'])
  print (['A'..'Z'])
  print (['A'..'z'])
#+END_SRC

You can also define a step. The difference between the first and second element
in the range will be the step size

#+BEGIN_SRC haskell
main = do
  print ([1,4..50])
  print ([10,20..100])
#+END_SRC

You can also have a negative step size

#+BEGIN_SRC haskell
main = do
  print ([20,19..4])
  print ([100,90..0])
#+END_SRC

Because the way floats are handled in the computer it's bad idea to use floats
with ranges

#+BEGIN_SRC haskell
main = do
  print ([0.1, 0.3 .. 1])
#+END_SRC

You don't have to specify an upper limit. This will create an infinite lists but
since Haskell is lazy it will only generate as much as is needed

#+BEGIN_SRC haskell
main = do
  print (take 24 [13,26..])
#+END_SRC

To repeat a list an infinite amount of times you can use the ~cycle~ function

#+BEGIN_SRC haskell
main = do
  print (take 24 (cycle [1,2,3,4]))
  print (take 24 (cycle "Batman"))
#+END_SRC

To repeat an element an infinite numbers of time you can use the ~repeat~
function

#+BEGIN_SRC haskell
main = do
  print (take 24 (repeat 'A'))
  -- Or just use replicate for the same results
  print (replicate 24 'A')
#+END_SRC

*** List comprehensions

With list comprehensions we can transform every value in a list by applying a
function to it. Below we will multiply every value in a list with itself

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10]])
#+END_SRC

We can also filter the result. Say that we are only interested in the power if
two greater than 50

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10], x*x > 50])
#+END_SRC

We can include multiple predicates for the filtering and the element will only
be included in the resulting list if all of them evaluates to true. Let's add
the predicate that the result should be smaller than 90

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10], x*x > 50, x*x < 90])
#+END_SRC

We can also draw values from multiple lists where all combinations from the
input lists will be created. Below we will create tuples for each result

#+BEGIN_SRC haskell
main = do
  print ([(x,y) | x <- [1..4], y <- [3..5]])
#+END_SRC

We can also use predicates when drawing values from multiple lists. Below we
will only output the pairs whos sum is even

#+BEGIN_SRC haskell
main = do
  print ([(x,y) | x <- [1..4], y <- [3..5], even (x + y)])
#+END_SRC

We can now define our own version of ~length~

#+BEGIN_SRC haskell
length' xs = sum [1 | _ <- xs]

main = do
  print (length' [1..10])
#+END_SRC

The ~_~ in the code block above means that we don't care about the value that
would be put in that variable if we gave it a name

We can also nest list comprehensions. The code block below let us remove all odd
values from the containing lists without flattening it

#+BEGIN_SRC haskell
main = do
  let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
  print ([[ x | x <- xs, even x ] | xs <- xxs])
#+END_SRC

** Tuples

Tuples are like lists of fixed length and may mix types. If you change the
length or containing types the type of the tuple will change. Tuples are wrapped
with parantheses.

The following code will run fine. You have a list of integer pairs:

#+BEGIN_SRC haskell
main = do
  print ([(1,2),(8,11),(4,5)])
#+END_SRC

But the following wont work as we have mixed integer pairs with an integer
triple:

#+BEGIN_SRC haskell
main = do
  print ([(1,2),(8,5,11),(4,5)])
#+END_SRC

If we would have replaced the lists of tuples with lists of lists both examples
above would have worked.

We have two functions that can be used to operate on pairs: ~fst~ and ~snd~
which are used to get the first and second value respectively

#+BEGIN_SRC haskell
main = do
  print (fst (1, "one"))
  print (snd (1, "one"))
#+END_SRC

Those functions only work on pairs. The following code won't work

#+BEGIN_SRC haskell
main = do
  print (fst (1, "one", "ett"))
  print (snd (1, "one", "ett"))
#+END_SRC

Haskell also has a function called ~zip~ which takes two lists and zips them
together by joining the matching elements together until the shortest list is
depleted. The result will be a list of tuples.

#+BEGIN_SRC haskell
main = do
  print (zip [1,2,3,4,5] [5,5,5,5,5])
  print (zip [1..] ["apple", "orange", "cherry", "mango"])
#+END_SRC

To reverse the effect you can call the ~unzip~ function

#+BEGIN_SRC haskell
main = do
  print (unzip [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")])
#+END_SRC

An example how tuples can be used is shown below. The function calculates all
right triangles with sides less than or equal to 10 and a perimeter exactly
equal to 24

#+BEGIN_SRC haskell
rightTriangles = [(a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]

main = do
  print (rightTriangles)
#+END_SRC

* Types

Haskell has a static type system but unlike Java Haskell has type inference. If
we write a number, we don't have to tell Haskell it's a number. It can infer
that on its own, so we don't have to explicitly write out the types of our
functions and expressions to get things done.

#+BEGIN_SRC haskell
import Data.Typeable

main = do
  print (typeOf 'a')
  print (typeOf True)
  print (typeOf "Hello")
  print (typeOf (True, 'a'))
  print (typeOf (4 == 5))
#+END_SRC

Functions also have types and we can choose to give them an explicit type
declaration. This is considered good practice except when writing short
functions.

#+BEGIN_SRC haskell
import Data.Typeable

removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

main = do
  print (typeOf removeNonUppercase)
#+END_SRC

The type above means that it accepts a strings as parameter and returns a
string. We can use the ~String~ keyword as well instead of ~[Char]~.

#+BEGIN_SRC haskell
import Data.Typeable

-- Try removing the type declaration and you will see that the compiler can infer the type anyway
removeNonUppercase :: String -> String
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

main = do
  print (typeOf removeNonUppercase)
#+END_SRC

If we have a method accepting three argumente you can write like this:

#+BEGIN_SRC haskell
import Data.Typeable

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

main = do
  print (typeOf addThree)
  --let addTwoTo4 = addThree 4
  --print (addTwoTo4 2 4)
#+END_SRC

** Type keywords

| Type      | Description                                                                                      |
|-----------+--------------------------------------------------------------------------------------------------|
| ~Int~     | Integer. ~Int~ is bounded. Check ~minBound :: Int~ and ~maxBound :: Int~ for boundaries          |
| ~Integer~ | Also integer but is not bounded and can represent very big numbers. Not as efficient as ~Int~    |
| ~Float~   | Single precision float                                                                           |
| ~Double~  | Double precision float                                                                           |
| ~Bool~    | Boolean and only has two values: ~True~ and ~False~                                              |
| ~Char~    | Character. Represented by a character in single quotes (e.g. ~'g'~). A list of chars is a string |
| ~(a,b,c)~ | Tuple. Note that there also is an empty tuple ~()~                                               |
| ~[a]~     | List                                                                                             |

** Type variables

Functions that have type variables are polymorphic functions, i.e. a function
may accept variables of different types and/or return variables of different
types. Type variables resembles generics in other languages. The ~head~ function
is an example of a function which have type variables

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  head :: [a] -> a
:t head
#+END_SRC

From the result of the above code block you can see that ~head~ accepts a list
of any type and results in an element of the type the list contained

A function can also contain multiple type variable, e.g. ~fst~ and ~snd~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  fst :: (a, b) -> a
:t fst
#+END_SRC

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  snd :: (a, b) -> b
:t snd
#+END_SRC

Just because ~a~ and ~b~ are different type variables doesn't mean that they
must be of different types. But all occurences of e.g. ~a~ in a type will be the
same type.

** Type classes

If a type is part of a type class it means that it supports the behaviour that
the type class describes. You can think of them as interfaces in Java. We can
look at the type signature of the ~==~ function

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  (==) :: Eq a => a -> a -> Bool
:t (==)
#+END_SRC

Everything before the ~=>~ is called a class contstraint. The type signature
above translates to ~==~ takes two values of the same type which must be a
member of the ~Eq~ class and returns a ~Bool~.

Some basic type classes:

*** The ~Eq~ type class

For equality testing. The members of this type class must implement ~==~ and
~/=~

*** The ~Ord~ type class

For types that have an ordering. The members of this type class must implement
~<~, ~>~, ~<=~, ~>=~. They must also be members of the ~Eq~ type class

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  (>) :: Ord a => a -> a -> Bool
:t (>)
#+END_SRC

*** The ~Show~ type class

Can be presented as strings. The most used function that deals with the ~Show~
typeclass is the function ~show~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  show :: Show a => a -> String
:t show
#+END_SRC

*** The ~Read~ type class

Can be created from a string using the ~read~ function.

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  read :: Read a => String -> a
:t read
#+END_SRC

Examples:

#+BEGIN_SRC haskell
main = do
  print (read "True" || False)
  print (read "8.2" + 3.8)
  print (read "5" - 2)
  print (read "[1,2,3,4]" ++ [3])
#+END_SRC

But what happens if we just run:

#+BEGIN_SRC haskell
main = do
  let readValue = read "4"
  print readValue
#+END_SRC

The compiler can't infer what kind of result we wanted from the ~read~ function
anylonger. If we used the variable as a ~Bool~ then the compiler would assume
that the variable is a ~Bool~ and if we use it as an ~Int~ the compiler would
assume that the variable is an ~Int~. See what happens when we add an ~Int~ to
the result

#+BEGIN_SRC haskell
main = do
  let readValue = read "4"
  print (readValue + 4)
#+END_SRC

To overcome this problem we can use *type annotations*. Type annotations are a
way of explicitly saying what the type of an expression should be. We do that by
adding ~::~~ at the end of the expression and then specifying a type

#+BEGIN_SRC haskell
main = do
  let readValue = read "4" :: Int
  print readValue
#+END_SRC

Can also be used on other classes

#+BEGIN_SRC haskell
main = do
  print (read "5" :: Int)
  print (read "5" :: Float)
  print ((read "5" :: Float) * 4)
  print (read "[1,2,3,4]" :: [Int])
  print (read "(3, 'a')" :: (Int, Char))
#+END_SRC

Most expressions are such that the compiler can infer what their type is by
itself. To see what the type is, Haskell would have to actually evaluate the
result of the ~read~ function but since Haskell is a statically typed language,
it has to know all the types before the code is compiled

*** The ~Enum~ type class

Are sequentially ordered types. They can be used in list ranges and have defined
successors and predecesors, which you can get with the ~succ~ and ~pred~
functions.

#+BEGIN_SRC haskell
main = do
  print (['a'..'e'])
  print (succ 'B')
  print (pred 'B')
#+END_SRC

*** The ~Bounded~ type class

Have an upper and lower bound and should provide the ~minBound~ and ~maxBound~
functions. By investigating the type signatures of these methods you can see
that they act like polymorphic constants.

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  minBound :: Bounded a => a
:t minBound
#+END_SRC

Examples:

#+BEGIN_SRC haskell
main = do
  print (minBound :: Int)
  print (maxBound :: Int)
  print (minBound :: Char)
  print (maxBound :: Char)
#+END_SRC

Tuples which only contains ~Bounded~ classes are also part of the ~Bounded~ type
class

*** The ~Num~ type class

Is a numeric type class. All members can act like numbers

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  20 :: Num a => a
:t 20
#+END_SRC

So ~20~ is part of ~Num~ and may act like any type that's a member of ~Num~.

#+BEGIN_SRC haskell
main = do
  print (20 :: Int)
  print (20 :: Integer)
  print (20 :: Float)
  print (20 :: Double)
#+END_SRC

If we inspect the type signature of ~*~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  (*) :: Num a => a -> a -> a
:t (*)
#+END_SRC

we see that the ~*~ function accepts two arguments of the same type which
explains why the following code won't work (~Int~ and ~Integer~ are not the same
class!)

#+BEGIN_SRC haskell
main = do
  print ((5 :: Int) * (6 :: Integer))
#+END_SRC

while the following will (~5~ is a ~Num~ and may be represented by an ~Integer~)

#+BEGIN_SRC haskell
main = do
  print (5 * (6 :: Integer))
#+END_SRC

To be a member of ~Num~ the type also needs to be a member of ~Eq~ and ~Show~

*** The ~Floating~ type class

Includes only floating point numbers. ~Float~ and ~Double~ are members of this
type class

*** The ~Integral~ type class

Includes only integral (whole) numbers. ~Int~ and ~Integer~ are members of this
type class.

A useful function to deal with numbers are ~fromIntegral~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  fromIntegral :: (Integral a, Num b) => a -> b
:t fromIntegral
#+END_SRC

This function accepts an ~Integral~ and returns a ~Num~. It's useful when you
have an ~Integral~ and want it to also work with floats point types. The
~length~ function returns an ~Int~ which makes it hard to add a ~Float~ to it
afterwards. Then it's nice to convert the ~Int~ to a ~Num~ first.

Also note that ~fromIntegral~ have several class constraints which is a valid
thing to do.

* Syntax in functions
** Pattern matching

Te patterns are checked from top to bottom. Whenever a match is found the
corresponding function body will be executed. The type signature is not needed
but I include it for clarity

#+BEGIN_SRC haskell
hiddenNumber :: (Integral a) => a -> String
hiddenNumber 2 = "Close"
hiddenNumber 3 = "Found number 3!"
hiddenNumber x = "Try again!"

main = do
  print (hiddenNumber 2)
  print (hiddenNumber 1)
  print (hiddenNumber 3)
#+END_SRC

A pattern doesn't have to be exhaustive or include a "catch-all" pattern. The
code snippet below will complain about a non-exhaustive pattern as there is no
behaviour defined for the ~d~ input

#+BEGIN_SRC haskell
badUpperCase :: Char -> Char
badUpperCase 'a' = 'A'
badUpperCase 'b' = 'B'
badUpperCase 'c' = 'C'

main = do
  print (badUpperCase 'a')
  print (badUpperCase 'c')
  print (badUpperCase 'd')
#+END_SRC

Another example that uses both pattern matching and recursion

#+BEGIN_SRC haskell
factorial :: (Integral a) => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)

main = do
  print (factorial 0)
  print (factorial 1)
  print (factorial 2)
  print (factorial 3)
  print (factorial 4)
  print (factorial 20)
#+END_SRC

Pattern matching can also be used to unpack tuples

#+BEGIN_SRC haskell
-- Without unpacking
addVectors1 :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors1 a b = (fst a + fst b, snd a + snd b)

-- With unpacking
addVectors2 :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors2 (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

main = do
  print (addVectors1 (1,2) (3,4))
  print (addVectors2 (1,2) (3,4))
#+END_SRC

If there are variables in the pattern that we are not interested in we can use
~_~. Below we have defined own implementations of ~fst~ and ~snd~.

#+BEGIN_SRC haskell
fst' :: (a, b) -> a
fst' (x, _) = x

snd' :: (a, b) -> b
snd' (_, x) = x

main = do
  print (fst' (10, 20))
  print (snd' (10, 20))
#+END_SRC

Pattern matching can also be used in list comprehensions

#+BEGIN_SRC haskell
main = do
  let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
  print [a+b | (a,b) <- xs]
#+END_SRC

We can also match with different lengths on lists

#+BEGIN_SRC haskell
listStatus :: (Show a) => [a] -> String
listStatus [] = "The list is empty"
listStatus (x:[]) = "The list has one element: " ++ show x
listStatus (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y
listStatus (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y

main = do
  print (listStatus "Ab") -- Strings are lists
  print (listStatus [1,2,3,4,5])
#+END_SRC

Recursion with lists

#+BEGIN_SRC haskell
sum' :: (Num a) => [a] -> a
sum' [] = 0
sum' (x:xs) = x + sum' xs

main = do
  print (sum' [1..100])
#+END_SRC

Sometimes we want to refer to whole match pattern. We could write

#+BEGIN_SRC haskell
firstLetter :: String -> String
firstLetter "" = error "The string cannot be empty"
firstLetter (x:xs) = "The first letter of " ++ x:xs ++ " is " ++ [x]

main = do
  print (firstLetter "hello")
#+END_SRC

But we can use something called /patterns/ if we want to refer to the whole
matched pattern. You do that by giving the whole pattern a name followed by ~@~
and then the pattern as usual

#+BEGIN_SRC haskell
firstLetter :: String -> String
firstLetter "" = error "The string cannot be empty"
firstLetter all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]

main = do
  print (firstLetter "hello")
#+END_SRC

** Guards

Instead of matching on fixed patterns we can use guards to match on conditions

#+BEGIN_SRC haskell
bmiString :: (RealFloat a) => a -> String
bmiString bmi
    | bmi <= 18.5 = "Underweight"
    | bmi <= 25.0 = "Normal"
    | bmi <= 30.0 = "Overweight"
    | otherwise   = "Obese"

main = do
  print (bmiString 15)
  print (bmiString 32)
  print (bmiString 20)
  print (bmiString 27.5)
#+END_SRC

Haskell will evaluate the first guard that evaluates to ~True~. The ~otherwise~
keyword is used for catch-all and evaluates always to ~True~. If all the guards
of a function evaluate to ~False~ (and we haven't provided an ~otherwise~
catch-all guard), evaluation falls through to the next pattern.

All guards can also be defined on the same line but the readability is not as
nice then

#+BEGIN_SRC haskell
max1' :: (Ord a) => a -> a -> a
max1' a b | a > b = a | otherwise = b

max2' :: (Ord a) => a -> a -> a
max2' a b
    | a > b     = a
    | otherwise = b

main = do
  print (max1' 1 2)
  print (max2' 1 2)
#+END_SRC

** The ~where~ keyword

We can change our example from the [[*Guards][guards]] section above to accept wight and
height instead

#+BEGIN_SRC haskell
bmiString :: (RealFloat a) => a -> a -> String
bmiString weight height
    | weight / height ^ 2 <= 18.5 = "Underweight"
    | weight / height ^ 2 <= 25.0 = "Normal"
    | weight / height ^ 2 <= 30.0 = "Overweight"
    | otherwise                   = "Obese"

main = do
  print (bmiString 90 1.87)
#+END_SRC

We have a lot of repeated code (which is also executed for every guard we
test!). We can redefine the code above with the ~where~ clause

#+BEGIN_SRC haskell
bmiString :: (RealFloat a) => a -> a -> String
bmiString weight height
    | bmi <= 18.5 = "Underweight"
    | bmi <= 25.0 = "Normal"
    | bmi <= 30.0 = "Overweight"
    | otherwise   = "Obese"
    where bmi = weight / height ^ 2

main = do
  print (bmiString 90 1.87)
#+END_SRC

Now the ~bmi~ variable is only calculated once and the code looks much better

We can also use pattern matching in the ~where~ clause. Below is a silly example

#+BEGIN_SRC haskell
initials :: String -> String -> String
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
    where (f:_) = firstname
          (l:_) = lastname

main = do
  print (initials "John" "Smith")
#+END_SRC

Functions can also be defined in the ~where~ clause. Say we want to calculate
the bmi for a list of weigth-height tuples

#+BEGIN_SRC haskell
calcBmis :: (RealFloat a) => [(a, a)] -> [a]
calcBmis xs = [bmi w h | (w, h) <- xs]
    where bmi weight height = weight / height ^ 2

main = do
  print (calcBmis [(90, 1.87), (65, 1.72), (100, 1.90)])
#+END_SRC

~where~ bindings can also be nested. It's a common idiom to make a function and
define some helper function in its ~where~ clause and then to give those
functions helper functions as well, each with its own ~where~ clause.

** The ~let~ keyword

The ~let~ keyword can be used to define very local variables and has the form
~let <bindings> in <expression>~. E.g.

#+BEGIN_SRC haskell
cylinder :: (RealFloat a) => a -> a -> a
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^2
    in  sideArea + 2 * topArea

main = do
  print (cylinder 5 10)
#+END_SRC

The expression above could have been replaced with a ~where~ binding. The
difference is that ~let~ bindings are expression (and returns a value) while
the ~where~ binding is not. Just like the ~if~ statement we can use it almost
anywhere

#+BEGIN_SRC haskell
main = do
  print [if 5 > 3 then "Woo" else "Boo", if 'a' > 'b' then "Foo" else "Bar"]
  print (4 * (if 10 > 5 then 10 else 0) + 2)
  print (4 * (let a = 9 in a + 1) + 2)
  print [let square x = x * x in (square 5, square 3, square 2)]
#+END_SRC

If we want to bind multiple variables inline we can separate them with
semicolons (it's optional to put a semicolon after the last binding)

#+BEGIN_SRC haskell
main = do
  print (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
#+END_SRC

You can pattern match with ~let~ bindings

#+BEGIN_SRC haskell
main = do
  print ((let (a,b,c) = (1,2,3) in a+b+c) * 100)
#+END_SRC

You can also use ~let~ bindings inside list comprehensions (here it looks like
the ~in~ keyword is omitted). We include a ~let~ inside a list comprehension
much like we would a predicate, only it doesn't filter the list, it only binds
to names. The names defined in a ~let~ inside a list comprehension are visible
to the output function and all predicates and sections that come after of the
binding. The following code block will only output the BMI of people with a BMI
over 25

#+BEGIN_SRC haskell
calcBmis :: (RealFloat a) => [(a, a)] -> [a]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]

main = do
  print (calcBmis [(90, 1.87), (65, 1.72), (100, 1.90)])
#+END_SRC

The ~in~ keyword is omitted in list comprehensions becuase the visibility scope
is already defined here. However, we could use a ~let in binding~ in a predicate
and the names defined would only be visible to that predicate.

~let~ bindings can't be used across guards and that's why the ~where~ binding is
handy sometime (which can be used across guards)

** Case expressions

Pattern matching on parameters is function definitions is just syntictic sugar
for case expressions. With case expressions we can pattern match almost
anywhere. Case expressions are as the name implies, expressions.

Compare the two interchangable functions below

#+BEGIN_SRC haskell
head0 :: [a] -> a
head0 [] = error "No head for empty lists!"
head0 (x:_) = x

head1 :: [a] -> a
head1 xs = case xs of [] -> error "No head for empty lists!"
                      (x:_) -> x

main = do
  print (head0 "Hi")
  print (head1 "Hi")
  print (head0 [5,3,1])
  print (head1 [5,3,1])
#+END_SRC

The syntax for case expressions looks like this

#+BEGIN_SRC  haskell
case expression of pattern -> result
                   pattern -> result
                   pattern -> result
                   ...
#+END_SRC

The patterns doesn't have to be exhaustive. If it falls through the whole case
expression and no suitable pattern is found, a runtime error occurs.

Another example

#+BEGIN_SRC haskell
describeList :: [a] -> String
describeList xs = "The list is " ++ case xs of [] -> "empty."
                                               [x] -> "a singleton list."
                                               xs -> "a longer list."

main = do
  print (describeList [3])
  print (describeList [])
#+END_SRC

Which could also be written as

#+BEGIN_SRC haskell
describeList :: [a] -> String
describeList xs = "The list is " ++ what xs
    where what [] = "empty."
          what [x] = "a singleton list."
          what xs = "a longer list."

main = do
  print (describeList [3])
  print (describeList [])
#+END_SRC

* Some recursion examples

Recursion is important to Haskell because unlike imperative languages, you do
computations in Haskell by declaring what something is instead of declaring how
you get it. That's why there are no while loops or for loops in Haskell and
instead we many times have to use recursion to declare what something is.

** Maximum

#+BEGIN_SRC haskell
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs)
    | x > maxTail = x
    | otherwise = maxTail
    where maxTail = maximum' xs

main = do
  print (maximum' [4,5,1,8,2])
#+END_SRC

** Replicate

#+BEGIN_SRC haskell
replicate' :: (Num i, Ord i) => i -> a -> [a]
replicate' n x
    | n <= 0    = []
    | otherwise = x:replicate' (n-1) x

main = do
  print (replicate' 5 'F')
#+END_SRC

** Take

#+BEGIN_SRC haskell
take' :: (Num i, Ord i) => i -> [a] -> [a]
take' n _
    | n <= 0   = []
take' _ []     = []
take' n (x:xs) = x : take' (n-1) xs

main = do
  print (take 5 (repeat 'F'))
#+END_SRC

** Reverse

#+BEGIN_SRC haskell
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]

main = do
  print (reverse' "Hello World")
#+END_SRC

** Repeat

#+BEGIN_SRC haskell
repeat' :: a -> [a]
repeat' x = x:repeat' x

main = do
  print (take 24 (repeat 'F'))
#+END_SRC

** Zip

#+BEGIN_SRC haskell
zip' :: [a] -> [b] -> [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys

main = do
  print (zip' [1,2,3] [4,5])
#+END_SRC

** Elem

#+BEGIN_SRC haskell
elem' :: (Eq a) => a -> [a] -> Bool
elem' a [] = False
elem' a (x:xs)
    | a == x    = True
    | otherwise = a `elem'` xs

main = do
  print (5 `elem` [1,2,3,4])
  print (2 `elem` [1,2,3,4])
#+END_SRC

** Quick sort

#+BEGIN_SRC haskell
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerSorted = quicksort [a | a <- xs, a <= x]
        biggerSorted = quicksort [a | a <- xs, a > x]
    in  smallerSorted ++ [x] ++ biggerSorted

main = do
  print (quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9])
  print (quicksort "the quick brown fox jumps over the lazy dog")
#+END_SRC

* Higher order functions

Haskell functions can take functions as parameters and return functions as
return values. A function that does either of those is called a higher order
function.

** Partially applied functions

Funtions in Haskell actually only accepts one parameter. Whenever a function
accepts more than one parameter it is because Haskell first applies the first
parameter which in turn returns a new function that may accept a new parameter.

The type of max can be written as

#+BEGIN_SRC  haskell
max :: (Ord a) => a -> a -> a
-- or
max :: (Ord a) => a -> (a -> a)
#+END_SRC

As you can see, ~->~ is right-associative. So we can call the ~max~ function
like this (we first apply the first parameter which returns a new function where
we apply the second parameter)

#+BEGIN_SRC haskell
main = do
  print ((max 5) 4)
  print ((max 8) 9)
#+END_SRC

We can also use partially applied functions to define new functions

#+BEGIN_SRC  haskell
let max3 = max 3
:t max
#+END_SRC

or in a program (note that the ~Num~ class constraint is added to the function
signature because 3 is a ~Num~)

#+BEGIN_SRC haskell
max3 :: (Num a, Ord a) => a -> a
max3 = max 3

main = do
  print (max3 5)
  print (max3 2)
#+END_SRC

We can also have partially applied infix functions by surrounding it with
parameters and just writing one of the parameters

#+BEGIN_SRC haskell
divideByTen :: (Floating a) => a -> a
divideByTen = (/10)

divideTenWith :: (Floating a) => a -> a
divideTenWith = (10/)

main = do
  print (divideByTen 100)
  print (divideTenWith 100)
#+END_SRC

or

#+BEGIN_SRC haskell
isUpperAlphanum :: Char -> Bool
isUpperAlphanum = (`elem` ['A'..'Z'])

main = do
  print (isUpperAlphanum '2')
  print (isUpperAlphanum 'a')
  print (isUpperAlphanum 'G')
#+END_SRC

** Functions as parameters

The previous section showed how functions can return functions. In this section
we can see that functions also can be arguments to other functions. To show that
a parameter is a function we will have to surround it's type signature with
parentheses. The following function will apply a given function two times to
another given parameter

#+BEGIN_SRC haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

main = do
  print (applyTwice (+ 3) 10)
  print (applyTwice (++ " HAHA") "HEY")
  print (applyTwice ("HAHA " ++) "HEY")
  print (applyTwice (3:) [1])
#+END_SRC

Some standard functions redefined

#+BEGIN_SRC haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys

main = do
  print (zipWith' (+) [4,2,5,6] [2,6,2,3])
  print (zipWith' max [6,3,2,1] [7,3,1,5])
  print (zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"])
  print (zipWith' (*) (replicate 5 2) [1..])
  print (zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]])
#+END_SRC

The ~flip~ function can be defined as below

#+BEGIN_SRC haskell
flip' :: (a -> b -> c) -> (b -> a -> c)
flip' f = g
    where g x y = f y x

main = do
  print (flip' zip [1,2,3,4,5] "hello")
  print (zipWith (flip' div) [2,2..] [10,8,6,4,2])
#+END_SRC

But because the way currying (with partial application) we can simplify it as
below

#+BEGIN_SRC haskell
flip' :: (a -> b -> c) -> b -> a -> c
flip' f y x = f x y

main = do
  print (flip' zip [1,2,3,4,5] "hello")
  print (zipWith (flip' div) [2,2..] [10,8,6,4,2])
#+END_SRC

** The ~map~ and ~filter~ funtions

~map~ is defined as

#+BEGIN_SRC haskell
map' :: (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x:xs) = f x : map f xs

main = do
  print (map (+3) [1,5,3,1,6])
  print (map (++ "!") ["BIFF", "BANG", "POW"])
  print (map (replicate 3) [3..6])
  print (map (map (^2)) [[1,2],[3,4,5,6],[7,8]])
  print (map fst [(1,2),(3,5),(6,3),(2,6),(2,5)])
#+END_SRC

~filter~ is defined as

#+BEGIN_SRC haskell
filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' p (x:xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs

main = do
  print (filter (>3) [1,5,3,2,1,6,4,3,2,1])
  print (filter (==3) [1,2,3,4,5])
  print (filter even [1..10])
  print (let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]])
  print (filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent")
  print (filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same")
#+END_SRC

Both ~map~ and ~filter~ can be replaced with list comprehensions and it all
depends on readability in each case which one to use. The [[*Quick sort][quicksort function]]
we defined earlier can now be written in a more readable way.

#+BEGIN_SRC haskell
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerSorted = quicksort (filter (<=x) xs)
        biggerSorted = quicksort (filter (>x) xs)
    in  smallerSorted ++ [x] ++ biggerSorted

main = do
  print (quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9])
  print (quicksort "the quick brown fox jumps over the lazy dog")
#+END_SRC

Some examples where we use ~filter~ and ~map~. To find the largest number under
100000 that's divisible by 3829

#+BEGIN_SRC haskell
main = print (head (filter p [100000,99999..]))
    where p x = x `mod` 3829 == 0
#+END_SRC

Find the sum of all odd squares that are smaller than 10000

#+BEGIN_SRC haskell
main = print (sum (takeWhile (<10000) (filter odd (map (^2) [1..]))))
#+END_SRC

We could define the exact same thing using list comprehensions (if we want to,
it's about preference)

#+BEGIN_SRC haskell
main = print (sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)]))
#+END_SRC

We can also use ~map~ to create a list of partially applied functions. Below we
use map to create a list which looks like ~[(0*),(1*),(2*),(3*),(4*),(5*)...~

#+BEGIN_SRC haskell
main = do
  print (let listOfFuns = map (*) [0..] in (listOfFuns !! 4) 5)
#+END_SRC

** Lambdas

Lambdas are anonymous funtions (and are defined where they are used). To define
a lambda we write ~\~ followed by the parameters (separated by spaces), then
~->~ followed by the function body. Usually a lambda is surrounded with
parentheses so it doesn't extend to the end of the line. The example below could
have

#+BEGIN_SRC haskell
main = do
  print (filter (\x -> odd x || x > 20 ) [1..25])
#+END_SRC

Don't use lambdas to replace partial application. This code snippet

#+BEGIN_SRC haskell
main = print (map (\x -> x + 3) [1,6,3,2])
#+END_SRC

can be written as (which is preferrable)

#+BEGIN_SRC haskell
main = print (map (+3) [1,6,3,2])
#+END_SRC

Like normal functions, lambdas can accept multiple parameters

#+BEGIN_SRC haskell
main = print (zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5])
#+END_SRC

and accept pattern matching. We can't define multiple patterns so if the pattern
doesn't match in a lambda a runtime error occurs.

#+BEGIN_SRC haskell
main = print (map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)])
#+END_SRC

If a function is meant to be partially applied it is preferrable if the function
returns a lambda to show this

#+BEGIN_SRC haskell
flip' :: (a -> b -> c) -> b -> a -> c
flip' f x y = f y x
#+END_SRC

Should be written like this

#+BEGIN_SRC haskell
flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \x y -> f y x
#+END_SRC

The most common use case with flip is calling it with just the function
parameter and then passing the resulting function on to a map or a filter.

** Folds

*** The ~foldl~ function

The signature of ~foldl~ is

#+BEGIN_SRC  haskell
foldl :: (a -> b -> a) -> a -> [b] -> a
#+END_SRC

and works like this

#+BEGIN_SRC
foldl op acc [1, 2, 3, 4]
((((acc `op` 1) `op` 2) `op` 3) `op` 4)

foldl (-) 0 [1,2,3,4]
((((0 - 1) - 2) - 3) - 4) = -10
#+END_SRC

e.g.

#+BEGIN_SRC haskell
main = print (foldl (-) 0 [1,2,3,4])
#+END_SRC

Here's ~sum~ reimplemented

#+BEGIN_SRC haskell
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
-- or even
-- sum' = foldl (+) 0

main = print (sum' [3,5,2,1])
#+END_SRC

There's also a ~foldl1~ function that works like ~foldl~ but which doesn't
expect a explicit starting value but will take the first value in the list as
starting value. Will not work with empty lists

*** The ~foldr~ funtion

The signature of ~foldr~ is

#+BEGIN_SRC  haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
#+END_SRC

and works like this

#+BEGIN_SRC
foldr op acc [1,2,3,4]
(1 `op` (2 `op` (3 `op` (4 `op` acc))))

foldr (-) 0 [1,2,3,4]
(1 - (2 - (3 - (4 - 0)))) = -2
#+END_SRC

e.g.

#+BEGIN_SRC haskell
main = print (foldr (-) 0 [1,2,3,4])
#+END_SRC

Here's ~map~ reimplemented

#+BEGIN_SRC haskell
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs

main = print (map' (+3) [1,2,3])
#+END_SRC

A major difference between ~foldl~ and ~foldr~ is that ~foldr~ will run on
infinite lists. If you take an infinite list at some point and you fold it up
from the right, you'll eventually reach the beginning of the list. However, if
you take an infinite list at a point and you try to fold it up from the left,
you'll never reach an end!

The following will work

#+BEGIN_SRC haskell
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs

main = print (take 5 (map' (+3) [1..]))
#+END_SRC

and this will run forever

#+BEGIN_SRC  haskell
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs

main = print (take 5 (map' (+3) [1..]))
#+END_SRC

There's also a ~foldr1~ function that works like ~foldr~ but which doesn't
expect a explicit starting value but will take the last value in the list as
starting value. Will not work with empty lists

*** Some fold examples

Note that all the functions below are not optimal but just to show how folds
works

#+BEGIN_SRC haskell
maximum' :: (Ord a) => [a] -> a
maximum' = foldr1 (\x acc -> if x > acc then x else acc)

reverse' :: [a] -> [a]
reverse' = foldl (\acc x -> x : acc) []

product' :: (Num a) => [a] -> a
product' = foldr1 (*)

filter' :: (a -> Bool) -> [a] -> [a]
filter' p = foldr (\x acc -> if p x then x : acc else acc) []

head' :: [a] -> a
head' = foldr1 (\x _ -> x)

last' :: [a] -> a
last' = foldl1 (\_ x -> x)
#+END_SRC

*** The ~scanl~ and ~scanr~ functions

Works like ~foldl~ and ~foldr~ but report every intermediate value in the form
of a list. There also exist ~scanl1~ and ~scanr1~ functions which works as
~foldl1~ and ~foldr1~.

When using ~scanl~ the final result will be the last element of the resulting
list while scanr will place the result as the first element in the list

#+BEGIN_SRC haskell
main = do
  print (scanl (+) 0 [3,5,2,1])
  print (scanr (+) 0 [3,5,2,1])
  print (scanl (flip (:)) [] [3,2,1])
#+END_SRC

How many elements does it take for the sum of the roots of all natural numbers
to exceed 1000?

#+BEGIN_SRC haskell
sqrtSums :: Int
sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1

main = do
  print (sqrtSums)
  print (sum (map sqrt [1..131]))
  print (sum (map sqrt [1..130]))
#+END_SRC

** Function application with the ~$~ function

It's defined as

#+BEGIN_SRC  haskell
($) :: (a -> b) -> a -> b
f $ x = f x
#+END_SRC

The difference between this function application and normal function application
is that normal function application has high precedence while ~$~ has low
precedence. Also regular function application is left-associative (~f a b c~ is
the same as ~(((f a) b) c)~) while ~$~ is right-associative.

The ~$~ function can be seen as an opening parantheses and a closing parantheses
at the end of the line. When a ~$~ is encountered, the expression on its right
is applied as the parameter to the function on its left

#+BEGIN_SRC haskell
main = print (sum (map sqrt [1..130]))
#+END_SRC

can be written as

#+BEGIN_SRC haskell
main = print (sum $ map sqrt [1..130])
#+END_SRC

and this snippet

#+BEGIN_SRC haskell
main = print (sum (filter (> 10) (map (*2) [2..10])))
#+END_SRC

can be written as

#+BEGIN_SRC haskell
main = print $ sum $ filter (> 10) $ map (*2) [2..10]
#+END_SRC

But we can also use ~$~ for just function application. With ~$~ we can map
function application over a list of functions. In the example below we call the
four function with the parameter 3

#+BEGIN_SRC haskell
main = print (map ($ 3) [(4+), (10*), (^2), sqrt])
#+END_SRC

** Function composition

In mathematics, function composition is defined like ~(fg)(x) = f(g(x))~. So
function composition will call the function ~g~ with the parameter ~x~ and pass
the result to the function ~f~. In Haskell we do function composition with the
~.~ function which is defined like

#+BEGIN_SRC haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
#+END_SRC

So the expression ~negate . (* 3)~ returns a function which takes a number,
multiplies it with 3 and the negates it. We could use lambdas but in many cases
function composition is clearer and more concise. Compare:

#+BEGIN_SRC haskell
main = do
  print (map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24])
  print (map (negate . abs) [5,-3,-6,7,-3,2,-19,24])
#+END_SRC

Function composition is right associative (~f (g (z x))~ is equal to
~(f . g . z) x~), so:

#+BEGIN_SRC haskell
main = do
  print (map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]])
  print (map (negate . sum . tail) [[1..5],[3..6],[1..7]])
#+END_SRC

If a function accepts multiple parameters we will have to partially apply it
until it only accepts one parameter. E.g.

#+BEGIN_SRC haskell
main = do
  print (sum (replicate 5 (max 6.7 8.9)))
  print ((sum . replicate 5 . max 6.7) 8.9)
  print (sum . replicate 5 . max 6.7 $ 8.9)
#+END_SRC

We can also use function composition when we want to use currying to get rid of
a parameter on both sides

#+BEGIN_SRC haskell
fn0 x = ceiling (negate (tan (cos (max 50 x))))
fn1 x = (ceiling . negate . tan . cos . max 50) x
fn2 = ceiling . negate . tan . cos . max 50

main = do
  print (fn0 67)
  print (fn1 67)
  print (fn2 67)
#+END_SRC

A more advanced example

#+BEGIN_SRC haskell
oddSquareSum :: Integer
oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))

main = print (oddSquareSum)
#+END_SRC

Can be written as

#+BEGIN_SRC haskell
oddSquareSum :: Integer
oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]

main = print (oddSquareSum)
#+END_SRC

But it's not very readable so the following is probably preferrable

#+BEGIN_SRC haskell
oddSquareSum :: Integer
oddSquareSum =
    let oddSquares = filter odd $ map (^2) [1..]
        belowLimit = takeWhile (<10000) oddSquares
    in  sum belowLimit

main = print (oddSquareSum)
#+END_SRC

* Modules

The syntax for importing modules in a Haskell program is ~import <module name>~.
The import statements should be placed at the top of the file. Most functions,
types and type classes we have worked with so far are part of the ~Prelude~
module which is imported by default.

We can import the ~Data.List~ module which introduces useful functions to work
with lists. We will define a function that returns the number of unique elements
in a list.

#+BEGIN_SRC haskell
import Data.List

numUniques :: (Eq a) => [a] -> Int
numUniques = length . nub

main = print (numUniques "abcav")
#+END_SRC

All functions thet ~Data.List~ exports became available in the global namespace,
which means that we can call them wherever in the current file. The ~nub~
function is defined in ~Data.List~ and filters all duplicate elements.

We don't have to import everything from a module. If we only want to import the
~nub~ and ~sort~ functions from ~Data.List~ we can use the following syntax.

#+BEGIN_SRC haskell
import Data.List (nub, sort)
#+END_SRC

Sometimes we want to import everything except a few functions (maybe we have
defined a function with the same name already). If we want to import everything
except ~nub~ you write

#+BEGIN_SRC haskell
import Data.List hiding (nub)
#+END_SRC

We can also solve name clashes with qualified imports

#+BEGIN_SRC haskell
import qualified Data.Map
#+END_SRC

In order to call the ~filter~ function of ~Data.Map~ you use ~Data.Map.filter~
while a call to ~filter~ will refer to the one defined in ~Prelude~. We can also
rename the qualified import to something shorter with

#+BEGIN_SRC haskell
import qualified Data.Map as M
#+END_SRC

Now instead of calling ~Data.Map.filter~ you can use just ~M.filter~.

** Creating own modules

We have a defined our own module ~Geometry~ in the file [[file:Geometry.hs][Geometry.hs]]. In the
beginning of the module we have defined the module name which should be the same
as the file name (without ~.hs~). Then we specify the functions that the module
should export followed by the function definitions. To use the module, import it
as you usually would do. ~Geometry.hs~ needs to be in the same folder.

#+BEGIN_SRC haskell
import Geometry

main = do
  print (cubeVolume 5)
  print (sphereVolume 5)
#+END_SRC

We can also put the modules in a hierarchical structure. We can now create a
module ~Geo~ which have three submodules: ~Sphere~, ~Cuboid~ and ~Cube~. Create
a directory called ~Geo~ and then a file for each submodule, like below:

- [[file:Geo/Sphere.hs][Geo/Sphere.hs]]
- [[file:Geo/Cuboid.hs][Geo/Cuboid.hs]]
- [[file:Geo/Cube.hs][Geo/Cube.hs]] (note that this sub module have imported the ~Geo/Cuboid~ module)

If we want to import all these modules we will have to do qualified imports
since each module have their own definitions of ~area~ and volume

#+BEGIN_SRC haskell
import qualified Geo.Sphere as Sphere
import qualified Geo.Cuboid as Cuboid
import qualified Geo.Cube as Cube

main = do
  print (Cube.volume 5)
  print (Sphere.volume 5)
#+END_SRC

** Some links

Link to see which modules are in the standard library
- [[https://downloads.haskell.org/~ghc/latest/docs/html/libraries/]]

To search for functions or to find out where they're located
- [[https://hoogle.haskell.org/]]

About ~Data.List~
- [[http://learnyouahaskell.com/modules#data-list]]

About ~Data.Char~
- [[http://learnyouahaskell.com/modules#data-char]]

About ~Data.Map~
- [[http://learnyouahaskell.com/modules#data-map]]

About ~Data.Set~
- [[http://learnyouahaskell.com/modules#data-set]]

* Links

- [[https://hackage.haskell.org/package/CheatSheet-1.11/src/CheatSheet.pdf]]
- [[http://learnyouahaskell.com/chapters]]
- [[https://www.haskell.org/hoogle/]]
- [[http://book.realworldhaskell.org/]]
