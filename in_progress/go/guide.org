* Table of Contents :TOC_2:QUOTE:
#+BEGIN_QUOTE
- [[#tour][Tour]]
  - [[#hello-world][Hello world]]
  - [[#packages-and-imports][Packages and imports]]
  - [[#exported-names][Exported names]]
  - [[#functions][Functions]]
  - [[#variables][Variables]]
  - [[#basic-types][Basic types]]
  - [[#loops][Loops]]
  - [[#if-statement][If statement]]
  - [[#switch-statement][Switch statement]]
  - [[#defer][Defer]]
  - [[#pointers][Pointers]]
  - [[#structs][Structs]]
  - [[#arrays][Arrays]]
  - [[#slices][Slices]]
  - [[#range][Range]]
  - [[#maps][Maps]]
  - [[#function-values][Function values]]
  - [[#function-closures][Function closures]]
  - [[#exercise-fibonacci-closure][Exercise: Fibonacci closure]]
  - [[#methods][Methods]]
  - [[#interfaces][Interfaces]]
  - [[#errors][Errors]]
  - [[#readers][Readers]]
  - [[#concurrency][Concurrency]]
- [[#projects-modules-and-packages][Projects, modules and packages]]
- [[#the-go-command][The ~go~ command]]
- [[#other][Other]]
  - [[#empty-struct][Empty struct]]
  - [[#implement-a-set-with-map-and-empty-struct][Implement a set with map and empty struct]]
  - [[#usage-of-pointers-for-arrays-slices-and-maps-in-functionmethod-calls][Usage of pointers for arrays, slices and maps in function/method calls]]
  - [[#tail-recursion][Tail recursion]]
  - [[#variadic-functions][Variadic functions]]
  - [[#enums][Enums]]
- [[#naming-conventions][Naming conventions]]
- [[#links][Links]]
- [[#pitfalls][Pitfalls]]
  - [[#overuse-of-declaration-][Overuse of declaration (~:=~)]]
  - [[#pointers-to-objects-in-a-slice][Pointers to objects in a slice]]
- [[#questions][Questions]]
#+END_QUOTE

* Tour

To run [[https://tour.golang.org/][the official golang tour]] locally run:

#+BEGIN_SRC bash
go install golang.org/x/website/tour@latest

# The call above should have created a binary called 'tour' in the GOPATH bin directory.
# My GOPTH variable wasn't set and I could find it under $HOME/go/bin/tour
$HOME/go/bin/tour
#+END_SRC

** Hello world

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	fmt.Println("Hello, world")
}
#+END_SRC

** Packages and imports

Every Go program is made up of packages. Programs start running in package
~main~.

By convention, the package name is the same as the last element of the import
path. For instance, the ~math/rand~ package comprises files that begin with the
statement package ~rand~.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func main() {
	// If you don't enter a seed yourself it will be treated as if it was rand.Seed(1)
	rand.Seed(time.Now().UTC().UnixNano())
	fmt.Println("My favorite number is", rand.Intn(10))
}
#+END_SRC

In the example above the imports are grouped into a /factored/ import statement.
You can also write multiple import statements like:

#+BEGIN_SRC go
import "fmt"
import "time"
import "math/rand"
#+END_SRC

But it is good style to use the factored import statement.

** Exported names

A name is only exported if it begins with a capital letter. In a package, the
name ~Pizza~ would be exported while ~pasta~ wouldn't be exported.

So when importing a package you can only refer to the exported names.

So names with beginning with a capital letter are public while all other are
private.

** Functions

A function can take zero or more arguments. Unlike java the types of the
arguments are placed after the variable name, and the return type after the
arguments.

For more information about the declaration syntax:
https://blog.golang.org/declaration-syntax

#+BEGIN_SRC go :results output
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
#+END_SRC

If multiple consecutive arguments have the same type you can omit the type for
all variable but the last. The example above now looks like:

#+BEGIN_SRC go :results output
package main

import "fmt"

func add(x, y int) int { // <-- Look here
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
#+END_SRC

Like python a function can return multiple results:

#+BEGIN_SRC go :results output
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
#+END_SRC

Go supports naming the return values. Then you define them as variables at the
top of the function. Note that they are defined here. You don't use ~var~ or
~:=~ to define them later.

A ~return~ statement without arguments returns the named return values. This is
known as a "naked" return.

Naked return statements should be used only in short functions.

If you provide an argument to the return statement it looks like as if the named
return values are ignored.

#+BEGIN_SRC go :results output
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
	//return 1, 2
}

func main() {
	fmt.Println(split(17))
}
#+END_SRC

See this example which defines a higher order function and defines a slice as a
return value at the top of the function:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"strings"
)

// Note that ret is already a defined slice when the function starts
func filter(ss []string, test func(string) bool) (ret []string) {
    for _, s := range ss {
        if test(s) {
            ret = append(ret, s)
        }
    }
    return
}

func main() {
	ss := []string{"foo_1", "asdf", "loooooooong", "nfoo_1", "foo_2"}
	// Define a helper function
	mytest := func(s string) bool { return !strings.HasPrefix(s, "foo_") && len(s) <= 7 }
	s2 := filter(ss, mytest)

	fmt.Println(s2)
}
#+END_SRC

** Variables

The ~var~ statement declares a list of variables; as in function argument lists,
the type is last.

A ~var~ statement can be at package or function level. In the example below it
looks like as if booleans are initialized to ~false~ and ints to ~0~.

#+BEGIN_SRC go :results output
package main

import "fmt"

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
#+END_SRC

You can initilize them manually during declaration as well. If an initializer is
present, the type can be omitted; the variable will take the type of the
initializer.

#+BEGIN_SRC go :results output
package main

import "fmt"

// Declaration with type
var i, j int = 1, 2

func main() {
	// Declaration without type
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
#+END_SRC

Go also supports /short variable declarations/ inside functions. You can then
use ~:=~ in place of a ~var~ declaration with implicit type. Note that this
can't be used outside a function!

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, "no!"

	fmt.Println(i, j, k, c, python, java)
}
#+END_SRC

** Basic types

| Type         | Alias  | Comment                                                                   |
|--------------+--------+---------------------------------------------------------------------------|
| ~bool~       |        |                                                                           |
| ~string~     |        |                                                                           |
| ~int~        |        | Usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems |
| ~int8~       |        |                                                                           |
| ~int16~      |        |                                                                           |
| ~int32~      | ~rune~ | ~rune~ represents a Unicode code point.                                   |
| ~int64~      |        |                                                                           |
| ~uint~       |        | Usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems |
| ~uint8~      | ~byte~ |                                                                           |
| ~uint16~     |        |                                                                           |
| ~uint32~     |        |                                                                           |
| ~uint64~     |        |                                                                           |
| ~uintptr~    |        | Usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems |
| ~float32~    |        |                                                                           |
| ~float64~    |        |                                                                           |
| ~complex64~  |        |                                                                           |
| ~complex128~ |        |                                                                           |

When you need an integer value you should use int unless you have a specific
reason to use a sized or unsigned integer type.

In the example below you can see how also variable declarations can be factored
like imports. You also see that you can print the type of a variable in the
~Printf~ statement.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
#+END_SRC

Variable declarations without an explicit initial value are given their ~zero~
value.

| Type          | Zero value |
|---------------+------------|
| Numeric types | ~0~        |
| ~bool~        | ~false~    |
| ~string~      | ~""~       |
| Pointers      | ~nil~      |
| Slices        | ~nil~      |
| Maps          | ~nil~      |

*** Type conversions

The expression ~T(v)~ converts the value ~v~ to the type ~T~.

Unlike in C, in Go assignment between items of different type requires an
explicit conversion. Try removing the ~float64~ or ~uint~ conversions in the
example and see what happens.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	fmt.Println(x, y, z)
}
#+END_SRC

*** Type inference

When declaring a variable without specifying an explicit type the variable's
type is inferred from the value on the right hand side.

This is easy when the right hand side is a variable with already a type but when
the right hand side contains an untyped numeric constant, the new variable may be
an ~int~, ~float64~, or ~complex128~ depending on the precision of the constant:

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	v0 := 42
	v1 := 3.142
	v2 := 0.867 + 0.5i
	// The following variable would fit in an uint64 but returns an error that it overflows int
	//v3 := 9223372036854775808
	//var v3 uint64 = 9223372036854775808
	fmt.Printf("v0 is of type %T\n", v0)
	fmt.Printf("v1 is of type %T\n", v1)
	fmt.Printf("v2 is of type %T\n", v2)
	//fmt.Printf("v3 is of type %T\n", v3)
}
#+END_SRC

*** Constants

Constants are declared like variables, but with the ~const~ keyword instead of
~var~ (and can't use the ~:=~ syntax). Constants can be character, string,
boolean, or numeric values (TODO: No structs?)

TODO: Constants starts with capital letter? What about exported names?

#+BEGIN_SRC go :results output
package main

import "fmt"

const Pi = 3.14

func main() {
	const Name = "World"
	fmt.Println("Hello", Name)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
#+END_SRC

Numeric constants are high-precision values. An untyped constant takes the type
needed by its context. It looks like as if the contant doesn't have a type until
it is used. In the example below you can try to print the type of ~Small~ and
~Big~. ~Small~ will return ~int~ (I guess it get's the type by the ~Printf~
functions) while ~Big~ will return an overflow error.

Constant declarations can be factored like variables and imports.

#+BEGIN_SRC go :results output
package main

import "fmt"

const (
	// Create a huge number by shifting a 1 bit left 100 places.
	// In other words, the binary number that is 1 followed by 100 zeroes.
	Big = 1 << 100
	// Shift it right again 99 places, so we end up with 1<<1, or 2.
	Small = Big >> 99
)

func needInt(x int) int {
	fmt.Printf("%T\n", x)
	return x*10 + 1
}
func needFloat(x float64) float64 {
	fmt.Printf("%T\n", x)
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
	fmt.Printf("%T", Small)
	//fmt.Printf("%T", Big)
}
#+END_SRC

*** Strings

There are two different ways to represent string literals

**** Raw strings

Raw strings are enclosed in back-ticks ~`~. Here, ~\t~ and ~\n~ has no special
meaning, they are considered as backslash with ~t~ and backslash with ~n~. If
you need to include backslashes, double quotes or newlines in your string, use a
raw string literal.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := `Go\tJava\nPython`
	fmt.Println(s)
}
#+END_SRC

**** Interpreted string

Interpreted strings are enclosed in quotes ~"~. Hence ~\t~ would be interpreted
 as tab and ~\n~ as new line.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := "Go\tJava\nPython"
	fmt.Println(s)
}
#+END_SRC

** Loops

In go the only looping construct that exists is the ~for~ loop.

You don't parentheses around the three components of the ~for~ statement and
the braces are always required.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
#+END_SRC

The init and post statements are optional (effectively making this a ~while~
loop):

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
#+END_SRC

If you do this you can drop the semicolons:

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
#+END_SRC

To loop something forever you can drop the loop condition completely:

#+BEGIN_SRC go
package main

import "fmt"

func main() {
	for {
		fmt.Println("Hello")
	}
}
#+END_SRC

*** ~break~ and ~continue~

~break~ and ~continue~ works as you would expect:

#+BEGIN_SRC go
package main

import "fmt"

func main() {
	i := 0
	for {
		i++
		if i > 10 {
			break
		} else if i % 2 == 0 {
			continue
		}
		fmt.Println(i)
	}
}
#+END_SRC

** If statement

Like the ~for~ statement, the expression need not be surrounded by parentheses
but the braces are required.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
#+END_SRC

In go you can also have a /short statement/ to execute before the condition.
Variables declared by the statement are only in scope until the end of the ~if~.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
#+END_SRC

Variables declared inside an ~if~ short statement are also available inside any
of the ~else~ blocks.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
#+END_SRC

Calculate the square root of a number using [[https://en.wikipedia.org/wiki/Newton%27s_method][Newton's method]]:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func MySqrt(x float64) float64 {
	z := 1.0

	for i := 0; i < 10; i++ {
		z -= (z*z - x) / (2*z)
	}
	return z
}

func main() {
	number := 99.0
	fmt.Println(MySqrt(number))
	fmt.Println(math.Sqrt(number))
}

#+END_SRC

** Switch statement

Go's ~switch~ is like the one in Java except that Go only runs the selected
case, not all the cases that follow. In effect, the ~break~ statement that is
needed at the end of each case in those languages is provided automatically in
Go. Another important difference is that Go's ~switch~ cases need not be
constants, and the values involved need not be integers.

In the example below you can also see the use of a /short statement/ like in the
~if~ statement.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"runtime"
)

var linuxOs = "linux"

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case linuxOs: // A variable instead of a constant
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
}
#+END_SRC

As expected, cases are evaluated from top to bottom, stopping when a case
succeeds:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
#+END_SRC

You can also make match against the result of function call:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
)

func myFunc() int {
	return 2
}

func main() {
	myVar := 2
	switch myVar {
	case 0:
		fmt.Println("It's 0")
	case myFunc():
		fmt.Println("Function matched!")
	default:
		fmt.Println("Something else")
	}
}
#+END_SRC

If you don't provide a switch condition it is the same as ~switch true~. This
can be used as a clean way to write long if-then-else chains:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
#+END_SRC

*** ~fallthrough~

If you want to execute ~case~ statement that follows when the current ~case~
code is executed you can use the ~fallthrough~ keyword. It may be used only as
the final non-empty statement in such a clause and cannot be used in the final
~case~.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
)

func switchWFallthrough(v int) {
	switch v {
	case 1:
		fmt.Println("one")
		fallthrough
	case 2:
		fmt.Println("two")
		fallthrough
  default:
		fmt.Println("Other")
	}
}

func switchWoFallthrough(v int) {
	switch v {
	case 1:
		fmt.Println("one")
	case 2:
		fmt.Println("two")
  default:
		fmt.Println("Other")
	}
}

func main() {
	fmt.Println("With fallthrough")
	switchWFallthrough(1)
	fmt.Println("\nWithout fallthrough")
	switchWoFallthrough(1)
}
#+END_SRC

** Defer

A ~defer~ statement defers the execution of a function until the surrounding
function returns.

The deferred call's arguments are evaluated immediately, but the function call
is not executed until the surrounding function returns.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}

#+END_SRC

Deferred function calls are pushed onto a stack. When a function returns, its
deferred calls are executed in last-in-first-out order.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
#+END_SRC

TODO: When can this be used?

** Pointers

The type ~*T~ is a pointer to a ~T~ value. Its zero value is ~nil~.

#+BEGIN_SRC go
var p *int // Pointer to an int
#+END_SRC

The ~&~ operator generates a pointer to its operand

#+BEGIN_SRC go
i := 42 // i is an int
p = &i // p is a pointer to the memory address that holds the value of i
#+END_SRC

The ~*~ operator denotes the pointer's underlying value.

#+BEGIN_SRC go
fmt.Println(*p) // read i through the pointer p
*p = 21         // set i through the pointer p
#+END_SRC

This is known as "dereferencing" or "indirecting".

Unlike C, Go has no pointer arithmetic.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	*p = 21         // set i through the pointer
	fmt.Println(i)  // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(j) // see the new value of j
}
#+END_SRC

** Structs

A ~struct~ is a collection of fields:

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
#+END_SRC

The fields of a struct can be accessed using a ~.~:

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
	fmt.Println(v)
}
#+END_SRC

Struct fields can be accessed through a struct pointer. In C you would use the
~->~ operator but in go you just use ~.~ again. So instead of writing ~(*p).X~
you can just use ~p.X~:

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
	// You can dereference the pointer as well
	// of course but the result is the same
	(*p).Y = 1e5
	fmt.Println(v)
}
#+END_SRC

When instantiating a struct you don't have to provide all the values. You can
list just a subset of fields by using the ~FieldName: value~ syntax. (And the
order of named fields is irrelevant.)

The special prefix ~&~ returns a pointer to the struct value.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
	//illegal  = Vertex{1} // You can't create with too few unnamed values
)

func main() {
	fmt.Println(v1, p, v2, v3)
}
#+END_SRC

** Arrays

The type ~[n]T~ is an array of ~n~ values of type ~T~. The expression

#+BEGIN_SRC go
var a [10]int
#+END_SRC

declares a variable a as an array of ten integers. An array's length is part of
its type, so arrays cannot be resized.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Println(primes)
}
#+END_SRC

** Slices

An array has a fixed size. A slice, on the other hand, is a dynamically-sized,
flexible view into the elements of an array. In practice, slices are much more
common than arrays.

The type ~[]T~ is a slice with elements of type ~T~.

A slice is formed by specifying two indices, a low and high bound, separated by
a colon:

#+BEGIN_SRC go :results output
a[low : high]
#+END_SRC

This selects a half-open range which includes the first element, but excludes
the last one.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}

	var s []int = primes[1:4]
	fmt.Println(s)
}
#+END_SRC

A slice does not store any data, it just describes a section of an underlying
array. Changing the elements of a slice modifies the corresponding elements of
its underlying array. Other slices that share the same underlying array will see
those changes.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	names := [4]string{
		"John",
		"Paul",
		"George",
		"Ringo",
	}
	fmt.Println(names)

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b)

	b[0] = "XXX"
	fmt.Println(a, b)
	fmt.Println(names)
}
#+END_SRC

When slicing, you may omit the high or low bounds to use their defaults instead.

The default is zero for the low bound and the length of the slice for the high bound.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)

	s = s[:2]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)

	s = s[:]
	fmt.Println(s)
}
#+END_SRC

*** Slice literals

A slice literal is like an array literal without the length. This is an array literal:

#+BEGIN_SRC go :results output
[3]bool{true, true, false}
#+END_SRC

And this creates the same array as above, then builds a slice that references it:

#+BEGIN_SRC go :results output
[]bool{true, true, false}
#+END_SRC

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	q := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(q)

	r := []bool{true, false, true, true, false, true}
	fmt.Println(r)

	s := []struct {
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}
	fmt.Println(s)
}
#+END_SRC

*** Slice length and capacity

A slice has both a /length/ and a /capacity/.

- The length of a slice is the number of elements it contains.
- The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.

The length and capacity of a slice s can be obtained using the expressions
~len(s)~ and ~cap(s)~.

You can extend a slice's length by re-slicing it, provided it has sufficient
capacity. Changing beyond its capacity you get a runtime error.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

*** Nil slices

The zero value of a slice is ~nil~.

A nil slice has a length and capacity of 0 and has no underlying array.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var s []int
	fmt.Println(s, len(s), cap(s))
	if s == nil {
		fmt.Println("nil!")
	}
}
#+END_SRC

*** Dynamically sized slices

Slices can be created with the built-in ~make~ function; this is how you create
dynamically-sized arrays. The ~make~ function allocates a zeroed array and
returns a slice that refers to that array:

#+BEGIN_SRC go :results output
a := make([]int, 5)  // len(a)=5
#+END_SRC

To specify a capacity, pass a third argument to make:

#+BEGIN_SRC go :results output
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
#+END_SRC

Longer example

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)

	b := make([]int, 0, 5)
	printSlice("b", b)

	c := b[:2]
	printSlice("c", c)

	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
#+END_SRC

*** Slices of slices

Slices can contain any type, including other slices.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"strings"
)

func main() {
	// Create a tic-tac-toe board.
	board := [][]string{
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
	}

	// The players take turns.
	board[0][0] = "X"
	board[2][2] = "O"
	board[1][2] = "X"
	board[1][0] = "O"
	board[0][2] = "X"

	for i := 0; i < len(board); i++ {
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}
}
#+END_SRC

*** Appending to a slice

It is common to append new elements to a slice, and so Go provides a built-in
~append~ function.

#+BEGIN_SRC go
func append(s []T, elems ...T) []T
#+END_SRC

The first parameter ~s~ of append is a slice of type ~T~, and the rest are ~T~
values to append to the slice.

The resulting value of append is a slice containing all the elements of the
original slice plus the provided values.

If the backing array of ~s~ is too small to fit all the given values a bigger
array will be allocated. The returned slice will point to the newly allocated
array. When this happens, the updates to the slice will no longer be backed by
the old array.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var s []int
	printSlice(s)

	// append works on nil slices.
	s = append(s, 0)
	printSlice(s)

	// The slice grows as needed.
	s = append(s, 1)
	printSlice(s)

	// We can add more than one element at a time.
	s = append(s, 2, 3, 4)
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

*** Slice a slice beyond it's length

You can create a slice from a slice which is longer than the original slice if
the underlying array has capacity for it.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	originalArray := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

	s := originalArray[0:2] // Backed by original array
	printSlice(s)

	for cap(s) > 2 { // As long as we have capacity to extend beyond our length
		s = s[1:3]
		printSlice(s)
	}
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

** Range

The ~range~ form of the ~for~ loop iterates over a slice or map. When ranging
over a slice, two values are returned for each iteration. The first is the
index, and the second is a copy of the element at that index.

#+BEGIN_SRC go :results output
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
		fmt.Printf("2**%d = %d\n", i, v)
	}
}
#+END_SRC

If you for some reason don't care about the index or the element you can
replace the variable with a ~_~. E.g.

#+BEGIN_SRC go :results output
for i, _ := range pow
for _, value := range pow

// If you only want the index you can completely omit the second variable
for i := range pow
#+END_SRC

Example:

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1 << uint(i) // == 2**i
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
#+END_SRC

** Maps

The zero value of a map is ~nil~. A ~nil~ map has no keys, nor can keys be
added.

The ~make~ function returns a map of the given type, initialized and ready for
use.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
#+END_SRC

*** Map literals

Map literals are like struct literals, but the keys are required.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
#+END_SRC

If the top-level type is just a type name, you can omit it from the elements of
the literal.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
#+END_SRC

*** Mutating maps

Insert or update an element in map ~m~:

#+BEGIN_SRC go :results output
m[key] = elem
#+END_SRC

Retrieve an element:

#+BEGIN_SRC go :results output
elem = m[key]
#+END_SRC

Delete an element:

#+BEGIN_SRC go :results output
delete(m, key)
#+END_SRC

Test that a key is present with a two-value assignment:

#+BEGIN_SRC go :results output
elem, ok = m[key]
#+END_SRC

If ~key~ is in ~m~, ~ok~ is ~true~. If not, ~ok~ is ~false~. If ~key~ is not in
the map, then ~elem~ is the zero value for the map's element type.

*Note:* If elem or ok have not yet been declared you could use a short declaration form:

#+BEGIN_SRC go :results output
elem, ok := m[key]
#+END_SRC

Longer example

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Answer"] = 42
	fmt.Println("The value:", m["Answer"])

	m["Answer"] = 48
	fmt.Println("The value:", m["Answer"])

	delete(m, "Answer")
	fmt.Println("The value:", m["Answer"])

	v, ok := m["Answer"]
	fmt.Println("The value:", v, "Present?", ok)
}
#+END_SRC

*** Allowed Key types in a Map

The map key can be any type that is comparable. Some of the comparable types as
defined by go specification are:

- boolean
- numeric
- string
- pointer
- channel
- interface types
- structs – if all it’s field type is comparable
- array – if the type of value of array element is comparable

Some of the types which are not comparable as per go specification and which
cannot be used as a key in a map are:

- Slice
- Map
- Function

See https://go.dev/ref/spec#Comparison_operators

** Function values

Functions can be used as both function arguments and return values.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}
	fmt.Println(hypot(5, 12))

	fmt.Println(compute(hypot))
	fmt.Println(compute(math.Pow))
}
#+END_SRC

** Function closures

Go functions may be closures. A closure is a function value that references
variables from outside its body. The function may access and assign to the
referenced variables; in this sense the function is "bound" to the variables.

For example, the ~adder~ function returns a closure. Each closure is bound to
its own ~sum~ variable.

#+BEGIN_SRC go :results output
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
#+END_SRC

** Exercise: Fibonacci closure

#+BEGIN_SRC go :results output
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
	a := 0
	b := 1

	return func() int {
		t := a
		a, b = b, a + b
		return t
	}
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
#+END_SRC

** Methods

Go does not have classes. However, you can define methods on types. A method is
a function with a special /receiver/ argument. The receiver appears in its own
argument list between the ~func~ keyword and the method name. In the example
below, the ~Abs~ method has a receiver of type ~Vertex~ named ~v~.

I guess this is the equivalent of ~self~ in Python.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
}
#+END_SRC

A method is just a function with a receiver argument. Here's Abs written as a
regular function with no change in functionality.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(Abs(v))
}
#+END_SRC

You can declare a method on non-struct types, too. In this example we see a
numeric type ~MyFloat~ with an ~Abs~ method.

You can only declare a method with a receiver whose type is defined in the same
package as the method. You cannot declare a method with a receiver whose type is
defined in another package (which includes the built-in types such as ~int~).

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f)
	fmt.Println(f.Abs())
}
#+END_SRC

*** Pointer receivers

You can declare methods with pointer receivers. This means the receiver type has
the literal syntax ~*T~ for some type ~T~. (Also, ~T~ cannot itself be a pointer
such as ~*int~.)

For example, the ~Scale~ method below is defined on ~*Vertex~. Methods with
pointer receivers can modify the value to which the receiver points (as ~Scale~
does here). Since methods often need to modify their receiver, pointer receivers
are more common than value receivers.

Try removing the ~*~ from the declaration of the ~Scale~ function on and observe
how the program's behavior changes.

With a value receiver, the Scale method operates on a copy of the original
Vertex value. (This is the same behavior as for any other function argument.)
The Scale method must have a pointer receiver to change the Vertex value
declared in the main function.


#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	// Note how the memory address is different here. Go is passing arguments as value
	fmt.Printf("In Abs:\n  Type: %T\n  Memory address: %p\n  value: %v\n", v, &v, v)
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {
	fmt.Printf("In Scale:\n  Type: %T\n  Memory address: %p\n  value: %v\n", v, v, *v)
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	fmt.Printf("In Main:\n  Type: %T\n  Memory address: %p\n  value: %v\n", v, &v, v)
	v.Scale(10)
	fmt.Println(v.Abs())
}
#+END_SRC

*** Methods and pointer indirection

_Functions_ with a pointer argument must take a pointer:

#+BEGIN_SRC go :results output
var v Vertex

func ScaleFunc(v *Vertex, f float64) {
	// Body
}

ScaleFunc(v, 5)  // Compile error!
ScaleFunc(&v, 5) // OK
#+END_SRC

while _methods_ with pointer receivers take either a value or a pointer as the
receiver when they are called:

#+BEGIN_SRC go :results output
var v Vertex

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
#+END_SRC

For the statement ~v.Scale(5)~, even though ~v~ is a value and not a pointer,
the method with the pointer receiver is called automatically. That is, as a
convenience, Go interprets the statement ~v.Scale(5)~ as ~(&v).Scale(5)~ since
the Scale method has a pointer receiver.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(2)
	ScaleFunc(&v, 10)

	p := &Vertex{4, 3}
	p.Scale(3)
	ScaleFunc(p, 8)

	fmt.Println(v, p)
}
#+END_SRC

The equivalent thing happens in the reverse direction. _Functions_ that take a
value argument must take a value of that specific type:

#+BEGIN_SRC go :results output
var v Vertex
fmt.Println(AbsFunc(v))  // OK
fmt.Println(AbsFunc(&v)) // Compile error!
#+END_SRC

while _methods_ with value receivers take either a value or a pointer as the
receiver when they are called:

#+BEGIN_SRC go :results output
var v Vertex
fmt.Println(v.Abs()) // OK
p := &v
fmt.Println(p.Abs()) // OK
#+END_SRC

In this case, the method call ~p.Abs()~ is interpreted as ~(*p).Abs()~.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func AbsFunc(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
	fmt.Println(AbsFunc(v))

	p := &Vertex{4, 3}
	fmt.Println(p.Abs())
	fmt.Println(AbsFunc(*p))
}
#+END_SRC

In short, _methods_ converts between pointers and values automatically while
_functions_ doesn't.

There are two reasons to use a pointer receiver.

- So that the method can modify the value that its receiver points to.
- To avoid copying the value on each method call. This can be more efficient if
  the receiver is a large struct, for example.

In this example, both ~Scale~ and ~Abs~ are with receiver type ~*Vertex~, even
though the ~Abs~ method needn't modify its receiver.

In general, all methods on a given type should have either value or pointer
receivers, but not a mixture of both.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4}
	fmt.Printf("Before scaling: %+v, Abs: %v\n", v, v.Abs())
	v.Scale(5)
	fmt.Printf("After scaling: %+v, Abs: %v\n", v, v.Abs())
}
#+END_SRC

** Interfaces

An /interface/ type is defined as a set of method signatures. A value of
an interface type can hold any value that implements those methods.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat implements Abser
	a = &v // a *Vertex implements Abser

	// In the following line, v is a Vertex (not *Vertex)
	// and does NOT implement Abser.
	a = v

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
#+END_SRC

A type implements an interface by implementing its methods. There is no explicit
declaration of intent, no ~implements~ keyword.

#+BEGIN_SRC go :results output
package main

import "fmt"

type I interface {
	M()
}

type T struct {
	S string
}

// This method means type T implements the interface I,
// but we don't need to explicitly declare that it does so.
func (t T) M() {
	fmt.Println(t.S)
}

func main() {
	var i I = T{"hello"}
	i.M()
}
#+END_SRC

Under the hood, interface values can be thought of as a tuple of a value and a
concrete type. Calling a method on an interface value executes the method of the
same name on its underlying type.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"math"
)

type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	fmt.Println(t.S)
}

type F float64

func (f F) M() {
	fmt.Println(f)
}

func main() {
	var i I

	i = &T{"Hello"}
	describe(i)
	i.M()

	i = F(math.Pi)
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
#+END_SRC

If the concrete value inside the interface itself is ~nil~, the method will be
called with a nil receiver. In some languages this would trigger a null pointer
exception, but in Go it is common to write methods that gracefully handle being
called with a nil receiver (as with the method ~M~ in the example below.)

Note that an interface value that holds a ~nil~ concrete value is itself non-nil.

#+BEGIN_SRC go :results output
package main

import "fmt"

type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	if t == nil {
		fmt.Println("<nil>")
		return
	}
	fmt.Println(t.S)
}

func main() {
	var i I

	var t *T
	i = t
	describe(i)
	i.M()

	i = &T{"hello"}
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
#+END_SRC

A nil interface value holds neither value nor concrete type. Calling a method on
a nil interface is a run-time error because there is no type inside the
interface tuple to indicate which /concrete/ method to call.

#+BEGIN_SRC go :results output
package main

import "fmt"

type I interface {
	M()
}

func main() {
	var i I
	describe(i)
	//i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
#+END_SRC

*** Empty interface

The interface type that specifies zero methods is known as the
/empty interface/:

#+BEGIN_SRC go :results output
interface{}
#+END_SRC

An empty interface may hold values of any type. (Every type implements at least
zero methods). Empty interfaces are used by code that handles values of unknown
type. For example, ~fmt.Print~ takes any number of arguments of type
~interface{}~.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var i interface{}
	describe(i)

	i = 42
	describe(i)

	i = "hello"
	describe(i)
}

func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}
#+END_SRC

*** Type assertions

A /type assertion/ provides access to an interface value's underlying concrete
value.

#+BEGIN_SRC go
t := i.(T)
#+END_SRC

This statement asserts that the interface value ~i~ holds the concrete type ~T~
and assigns the underlying ~T~ value to the variable ~t~.

If ~i~ does not hold a ~T~, the statement will trigger a panic.

To test whether an interface value holds a specific type, a type assertion can
return two values: the underlying value and a boolean value that reports whether
the assertion succeeded.

#+BEGIN_SRC go :results output
t, ok := i.(T)
#+END_SRC

If ~i~ holds a ~T~, then ~t~ will be the underlying value and ~ok~ will be
~true~. If not, ~ok~ will be ~false~ and ~t~ will be the zero value of type ~T~,
and no panic occurs. Note the similarity between this syntax and that of reading
from a map.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	var i interface{} = "hello"

	s := i.(string)
	fmt.Println(s)

	s, ok := i.(string)
	fmt.Println(s, ok)

	f, ok := i.(float64)
	fmt.Println(f, ok)

	//f = i.(float64) // panic
}
#+END_SRC

If you want to test an interface value against multiple concrete classes you can
use a /type switch/.

A type switch is a construct that permits several type assertions in series. A
type switch is like a regular switch statement, but the cases in a type switch
specify types (not values), and those values are compared against the type of
the value held by the given interface value.

#+BEGIN_SRC go :results output
switch v := i.(type) {
case T:
    // here v has type T
case S:
    // here v has type S
default:
    // no match; here v has the same type as i
}
#+END_SRC

The declaration in a type switch has the same syntax as a type assertion
~i.(T)~, but the specific type ~T~ is replaced with the keyword ~type~.

#+BEGIN_SRC go :results output
package main

import "fmt"

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
#+END_SRC

Casting between interfaces also works. Note below that it's ~*I~ that
implements the interfaces, not ~I~.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Incrementor interface {
	Increment()
}

type Decrementor interface {
	Decrement()
}

type Counter interface {
	// You can list other interfaces in an interface
	Incrementor
	Decrementor
}

type I int

func (i *I) Increment() {
	*i++
}

func (i *I) Decrement() {
	*i--
}

func do(i interface{}) {
	if s, ok := i.(Incrementor); ok {
		fmt.Println(s)
		s.Increment()
		fmt.Println(s)
	} else {
		fmt.Println("other value")
	}
}

func main() {
	var i I = 0
	var ip *I = &i
	do(ip)
	fmt.Println(i)
	do("hello")
	do(true)
}
#+END_SRC

*** Stringer interface

One of the most ubiquitous interfaces is ~Stringer~ defined by the ~fmt~ package.

#+BEGIN_SRC go
type Stringer interface {
    String() string
}
#+END_SRC

A ~Stringer~ is a type that can describe itself as a string. The ~fmt~ package
(and many others) look for this interface to print values.

#+BEGIN_SRC go :results output
package main

import "fmt"

type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}

func main() {
	a := Person{"Arthur Dent", 42}
	z := Person{"Zaphod Beeblebrox", 9001}
	fmt.Println(a, z)
}
#+END_SRC

**** Exercise: Stringers

#+BEGIN_SRC go :results output
package main

import "fmt"

type IPAddr [4]byte

func (a IPAddr) String() string {
	return fmt.Sprintf("%v.%v.%v.%v", a[0], a[1], a[2], a[3])
}

func main() {
	hosts := map[string]IPAddr{
		"loopback":  {127, 0, 0, 1},
		"googleDNS": {8, 8, 8, 8},
	}
	for name, ip := range hosts {
		fmt.Printf("%v: %v\n", name, ip)
	}
}
#+END_SRC

** Errors

Go programs express error state with ~error~ values instead of exceptions. The
~error~ type is a built-in interface similar to ~fmt.Stringer~:

#+BEGIN_SRC go
type error interface {
    Error() string
}
#+END_SRC

As with ~fmt.Stringer~, the fmt package looks for the ~error~ interface when
printing values. Functions often return an ~error~ value, and calling code
should handle errors by testing whether the error equals ~nil~.

#+BEGIN_SRC go
i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
    return
}
fmt.Println("Converted integer:", i)
#+END_SRC

A nil ~error~ denotes success; a non-nil ~error~ denotes failure.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
)

type MyError struct {
	When time.Time
	What string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() error {
	return &MyError{
		time.Now(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
#+END_SRC

*** Exercise: Errors

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
)

type ErrNegativeSqrt float64

func (e ErrNegativeSqrt) Error() string {
	// If you don't convert it to a float64 first, Sprintf will try to use the Error method to display the text causing an infinite loop
	return fmt.Sprintf("cannot Sqrt negative number: %v", float64(e))
}

func Sqrt(x float64) (float64, error) {
	if x < 0 {
		return 0, ErrNegativeSqrt(x)
	}

	z := 1.0

	for i := 0; i < 10; i++ {
		z -= (z*z - x) / (2*z)
	}
	return z, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
#+END_SRC

** Readers

The ~io~ package specifies the ~io.Reader~ interface, which represents the read
end of a stream of data. The Go standard library contains many implementations
of this interface, including files, network connections, compressors, ciphers,
and others.

The ~io.Reader~ interface has a ~Read~ method:

#+BEGIN_SRC go :results output
func (T) Read(b []byte) (n int, err error)
#+END_SRC

~Read~ populates the given byte slice with data and returns the number of bytes
populated and an error value. It returns an ~io.EOF~ error when the stream ends.

The example code creates a ~strings.Reader~ and consumes its output 8 bytes at a
time.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"io"
	"strings"
)

func main() {
	r := strings.NewReader("Hello, Reader!")

	b := make([]byte, 8)
	for {
		n, err := r.Read(b)
		fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
		fmt.Printf("b[:n] = %q\n", b[:n])
		if err == io.EOF {
			break
		}
	}
}
#+END_SRC

*** Exercise: Readers

Implement a ~Reader~ type that emits an infinite stream of the ASCII character
~'A'~.

#+BEGIN_SRC go :results output
package main

import "golang.org/x/tour/reader"

type MyReader struct{}

func (MyReader) Read(b []byte) (n int, err error) {
	for i := range b {
		b[i] = 'A'
	}
	return len(b), nil
}

func main() {
	reader.Validate(MyReader{})
}
#+END_SRC

*** Exercise: rot13Reader

#+BEGIN_SRC go :results output
package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

func (reader *rot13Reader) Read(b []byte) (n int, err error) {
	n, e := reader.r.Read(b)

	for i := 0; i < n; i++ {
		switch {
		case b[i]>='n': b[i]-=13
		case b[i]>='a': b[i]+=13
		case b[i]>='N': b[i]-=13
		case b[i]>='A': b[i]+=13
		}
	}

	return n,e
}

func main() {
	s := strings.NewReader("Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &r)
}
#+END_SRC

** Concurrency
*** Goroutines

A /goroutine/ is a lightweight thread managed by the Go runtime.

#+BEGIN_SRC go
go f(x, y, z)
#+END_SRC

starts a new goroutine running

#+BEGIN_SRC go
f(x, y, z)
#+END_SRC

The evaluation of ~x~, ~y~, and ~z~ happens in the current goroutine and the
execution of ~f~ happens in the new goroutine.

Goroutines run in the same address space, so access to shared memory must be
synchronized. The ~sync~ package provides useful primitives, although you won't
need them much in Go as there are other primitives.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}
#+END_SRC

*** Channels

Channels are a typed conduit through which you can send and receive values with
the channel operator, ~<-~.

#+BEGIN_SRC go
ch <- v    // Send v to channel ch.
v := <-ch  // Receive from ch, and
           // assign value to v.
#+END_SRC

The data flows in the direction of the arrow. Like maps and slices, channels
must be created before use:

#+BEGIN_SRC go
ch := make(chan int)
#+END_SRC

By default, sends and receives block until the other side is ready. This allows
goroutines to synchronize without explicit locks or condition variables.

The example code sums the numbers in a slice, distributing the work between two
goroutines. Once both goroutines have completed their computation, it calculates
the final result.

#+BEGIN_SRC go :results output
package main

import "fmt"

func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // send sum to c
}

func main() {
	s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(s[:len(s)/2], c)
	go sum(s[len(s)/2:], c)
	x, y := <-c, <-c // receive from c

	fmt.Println(x, y, x+y)
}
#+END_SRC

*** Buffered Channelse

Channels can be buffered. Provide the buffer length as the second argument to
make to initialize a buffered channel:

#+BEGIN_SRC go
ch := make(chan int, 100)
#+END_SRC

Sends to a buffered channel block only when the buffer is full. Receives block
when the buffer is empty.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	ch := make(chan int, 2)
	ch <- 1
	ch <- 2
	//ch <- 3 // This will cause a deadlock
	fmt.Println(<-ch)
	fmt.Println(<-ch)
}
#+END_SRC


A sender can ~close~ a channel to indicate that no more values will be sent.
Receivers can test whether a channel has been closed by assigning a second
parameter to the receive expression

#+BEGIN_SRC go
v, ok := <-ch
#+END_SRC

~ok~ is ~false~ if there are no more values to receive and the channel is
closed.

The loop ~for i := range c~ receives values from the channel repeatedly until it
is closed.

*Note:* Only the sender should close a channel, never the receiver. Sending on a
closed channel will cause a panic.

*Another note:* Channels aren't like files; you don't usually need to close
them. Closing is only necessary when the receiver must be told there are no more
values coming, such as to terminate a ~range~ loop.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		c <- x
		x, y = y, x+y
	}
	close(c)
}

func main() {
	c := make(chan int, 5)
	go fibonacci(cap(c) * 4 , c)
	for i := range c {
		fmt.Println(i)
	}
}
#+END_SRC

*** Select

The ~select~ statement lets a goroutine wait on multiple communication
operations. A ~select~ blocks until one of its cases can run, then it executes
that case. It chooses one at random if multiple are ready.

#+BEGIN_SRC go :results output
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x: // Waiting to write
			x, y = y, x+y
		case <-quit: // Waiting to read
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
#+END_SRC

The ~default~ case in a select is run if no other case is ready. Use a ~default~
case to try a send or receive without blocking:

#+BEGIN_SRC go
select {
case i := <-c:
    // use i
default:
    // receiving from c would block
}
#+END_SRC

Longer example:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"time"
)

func main() {
	tick := time.Tick(100 * time.Millisecond)
	boom := time.After(500 * time.Millisecond)
	for {
		select {
		case <-tick:
			fmt.Println("tick.")
		case <-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(50 * time.Millisecond)
		}
	}
}
#+END_SRC

*** Mutex

What if we just want to make sure only one goroutine can access a variable at a
time to avoid conflicts? This concept is called /mutual exclusion/, and the
conventional name for the data structure that provides it is /mutex/.

Go's standard library provides mutual exclusion with ~sync.Mutex~ and its two
methods:
- ~Lock~
- ~Unlock~

We can define a block of code to be executed in mutual exclusion by surrounding
it with a call to ~Lock~ and ~Unlock~ as shown on the ~Inc~ method below.

We can also use ~defer~ to ensure the mutex will be unlocked as in the ~Value~
method.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"sync"
	"time"
)

// SafeCounter is safe to use concurrently.
type SafeCounter struct {
	mu sync.Mutex
	v  map[string]int
}

// Inc increments the counter for the given key.
func (c *SafeCounter) Inc(key string) {
	c.mu.Lock()
	// Lock so only one goroutine at a time can access the map c.v.
	c.v[key]++
	c.mu.Unlock()
}

// Value returns the current value of the counter for the given key.
func (c *SafeCounter) Value(key string) int {
	c.mu.Lock()
	// Lock so only one goroutine at a time can access the map c.v.
	defer c.mu.Unlock()
	return c.v[key]
}

func main() {
	c := SafeCounter{v: make(map[string]int)}
	for i := 0; i < 1000; i++ {
		go c.Inc("somekey")
	}

	time.Sleep(time.Second)
	fmt.Println(c.Value("somekey"))
}
#+END_SRC

*** Exercise: Web crawler

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"sync"
)

type Fetcher interface {
	// Fetch returns the body of URL and
	// a slice of URLs found on that page.
	Fetch(url string) (body string, urls []string, err error)
}

type VisitTracker struct {
	t   map[string]struct{} /* An empty struct uses no memory and we only care
	                           about if a value is set or not in the map */
	mux sync.Mutex
}

var vt VisitTracker = VisitTracker{t: make(map[string]struct{})}

func (s VisitTracker) checkvisited(url string) bool {
	s.mux.Lock()
	defer s.mux.Unlock()
	_, ok := s.t[url]
	if ok == false {
		s.t[url] = struct{}{} // Initialize an empty anonymous struct
		return false
	}
	return true

}

func crawlHelper(url string, depth int, fetcher Fetcher, wg *sync.WaitGroup) {
	defer wg.Done()
	if depth <= 0 {
		return
	}
	if vt.checkvisited(url) {
		return
	}
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("found: %s %q\n", url, body)
	for _, u := range urls {
		wg.Add(1)
		go crawlHelper(u, depth-1, fetcher, wg)
	}
	return
}

// Crawl uses fetcher to recursively crawl
// pages starting with url, to a maximum of depth.
func Crawl(url string, depth int, fetcher Fetcher) {
	waitGroup := &sync.WaitGroup{}

	/* Looks like you have to add to the wait group before starting the
	   goroutine, otherwise the wait will return immedietly
	*/
	waitGroup.Add(1)

	go crawlHelper(url, depth, fetcher, waitGroup)

	waitGroup.Wait()
}

func main() {
	Crawl("https://golang.org/", 4, fetcher)
}

// fakeFetcher is Fetcher that returns canned results.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls []string
}

func (f fakeFetcher) Fetch(url string) (string, []string, error) {
	if res, ok := f[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("not found: %s", url)
}

// fetcher is a populated fakeFetcher.
var fetcher = fakeFetcher{
	"https://golang.org/": &fakeResult{
		"The Go Programming Language",
		[]string{
			"https://golang.org/pkg/",
			"https://golang.org/cmd/",
		},
	},
	"https://golang.org/pkg/": &fakeResult{
		"Packages",
		[]string{
			"https://golang.org/",
			"https://golang.org/cmd/",
			"https://golang.org/pkg/fmt/",
			"https://golang.org/pkg/os/",
		},
	},
	"https://golang.org/pkg/fmt/": &fakeResult{
		"Package fmt",
		[]string{
			"https://golang.org/",
			"https://golang.org/pkg/",
		},
	},
	"https://golang.org/pkg/os/": &fakeResult{
		"Package os",
		[]string{
			"https://golang.org/",
			"https://golang.org/pkg/",
		},
	},
}
#+END_SRC

* Projects, modules and packages

* The ~go~ command

* Other
** Empty struct

An empty struct consumes no space.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var s struct{}
	fmt.Println(unsafe.Sizeof(s))
}
#+END_SRC

It can hold the value ~struct{}{}~.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var s struct{} = struct{}{}
	fmt.Println(unsafe.Sizeof(s))
}
#+END_SRC

You can of course put it in a separate type

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"unsafe"
)

type Empty struct{}

func main() {
	var s Empty = Empty{}
	fmt.Println(unsafe.Sizeof(s))
}
#+END_SRC

As of writing this I can think of two reasons to use an empty struct:

1. To implment a set using a map
2. Create a ~chan struct{}~ for signaling between go routines

** Implement a set with map and empty struct

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
)

type Set map[interface{}]struct{}

func (s Set) Add(elem interface{}) {
	s[elem] = struct{}{}
}

func (s Set) Delete(elem interface{}) {
	delete(s, elem)
}

func (s Set) Size() int {
	return len(s)
}

func (s Set) Exists(elem interface{}) bool {
	_, exists := s[elem]
	return exists
}

func (s Set) PrintContent() {
	for elem := range s { // Each key in the map
		fmt.Print(elem, ", ") // I know it's ugly but I don't care
	}
	fmt.Println()
}

func main() {
	set := make(Set)
	set.Add(2)
	set.Add("Hello")
	set.PrintContent()
	fmt.Println(set.Size())
	fmt.Println(set.Exists(3))
	fmt.Println(set.Exists(2))
	set.Delete(2)
	set.PrintContent()
	fmt.Println(set.Size())
	fmt.Println(set.Exists(3))
	fmt.Println(set.Exists(2))
}
#+END_SRC

** Usage of pointers for arrays, slices and maps in function/method calls
*** Arrays

#+BEGIN_SRC go :results output
package main

import "fmt"

func mutatorWoPointer(input [3]int) {
	input[0] = 8
}

func mutatorWPointer(input *[3]int) {
	input[0] = 8
}

func main() {
	a0 := [...]int{1, 2, 3}
	a1 := [...]int{1, 2, 3}
	fmt.Println("a0:", a0) // a0: [1 2 3]
	fmt.Println("a1:", a1) // a1: [1 2 3]
	mutatorWoPointer(a0)
	mutatorWPointer(&a1)
	fmt.Println("a0:", a0) // a0: [1 2 3]
	fmt.Println("a1:", a1) // a1: [8 2 3]
}
#+END_SRC

The test above shows that if you don't use a pointer, the array will be copied
and the changes will not be visible in the original array when the function
returns.

*** Slice
**** Modify existing elements

#+BEGIN_SRC go :results output
package main

import "fmt"

func mutatorWoPointer(input []int) {
	input[0] = 8
}

func mutatorWPointer(input *[]int) {
	(*input)[0] = 8
}

func main() {
	a0 := []int{1, 2, 3}
	a1 := []int{1, 2, 3}
	fmt.Println("a0:", a0) // a0: [1 2 3]
	fmt.Println("a1:", a1) // a1: [1 2 3]
	mutatorWoPointer(a0)
	mutatorWPointer(&a1)
	fmt.Println("a0:", a0) // a0: [8 2 3]
	fmt.Println("a1:", a1) // a1: [8 2 3]
}
#+END_SRC

In this test we see that mutating existing elements seems to be fine using
pointers or not.

**** Add new elements

#+BEGIN_SRC go :results output
package main

import "fmt"

func printSlice(name string, s []int) {
	fmt.Printf("%s: len=%d cap=%d slice=%v full_underlying_array=%v\n", name, len(s), cap(s), s, s[:cap(s)])
}

func mutatorWoPointer(input []int) {
	input = append(input, 8)
}

func mutatorWPointer(input *[]int) {
	*input = append(*input, 8)
}

func main() {
	a0 := []int{1, 2, 3}
	a1 := []int{1, 2, 3}
	printSlice("a0", a0) // a0: len=3 cap=3 slice=[1 2 3] full_underlying_array=[1 2 3]
	printSlice("a1", a1) // a1: len=3 cap=3 slice=[1 2 3] full_underlying_array=[1 2 3]
	mutatorWoPointer(a0)
	mutatorWPointer(&a1)
	printSlice("a0", a0) // a0: len=3 cap=3 slice=[1 2 3] full_underlying_array=[1 2 3]
	printSlice("a1", a1) // a1: len=4 cap=6 slice=[1 2 3 8] full_underlying_array=[1 2 3 8 0 0]
	// Try add an element to a1 using no pointer (there is capacity for it)
	mutatorWoPointer(a1)
	printSlice("a1", a1) // a1: len=4 cap=6 slice=[1 2 3 8] full_underlying_array=[1 2 3 8 8 0]
	// The underlaying array was updated, but the length wasn't so the slice looks identical
	// Try add an element using a pointer to see that the array is not resized
	mutatorWPointer(&a1)
	printSlice("a1", a1) // a1: len=5 cap=6 slice=[1 2 3 8 8] full_underlying_array=[1 2 3 8 8 0]
}
#+END_SRC

Adding an element to a slice clearly needs to be done using a pointer. Even if
there is capacity in the underlying array.

*** Maps

#+BEGIN_SRC go :results output
package main

import "fmt"

func mutatorWoPointer(input map[int]string) {
	input[4] = "four"
}

func mutatorWPointer(input *map[int]string) {
	(*input)[4] = "four"
}

func main() {
	a0 := map[int]string{
		1: "one",
		2: "two",
		3: "three", // Looks like the trailing "," is needed
	}
	a1 := map[int]string{
		1: "one",
		2: "two",
		3: "three",
	}
	fmt.Println("a0:", a0) // a0: map[1:one 2:two 3:three]
	fmt.Println("a1:", a1) // a1: map[1:one 2:two 3:three]
	mutatorWoPointer(a0)
	mutatorWPointer(&a1)
	fmt.Println("a0:", a0) // a0: map[1:one 2:two 3:three 4:four]
	fmt.Println("a1:", a1) // a1: map[1:one 2:two 3:three 4:four]
}
#+END_SRC

From the above test it looks like both ways works fine.

** Tail recursion

Seems not to be supported: https://github.com/golang/go/issues/22624

Can maybe be implemented with a [[https://go.dev/ref/spec#Goto_statements][goto statement]]?

** Variadic functions

If the last parameter of a function has type ~...T~ it can be called with any
number of trailing arguments of type ~T~.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"strings"
)

func MyVariadicFunction(args ...string) {
	fmt.Println(strings.Join(args, " "))
}

func main() {
	MyVariadicFunction("Hello", "World", "!")
}
#+END_SRC

*** Convert a slice to an variadic argument

If you append ~...~ after the slice you can pass it to a variadic function.

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
	"strings"
)

func MyVariadicFunction(args ...string) {
	fmt.Println(strings.Join(args, " "))
}

func main() {
	var stringSlice []string = []string{"Hello", "World", "!"}
	MyVariadicFunction(stringSlice...)
}
#+END_SRC

*** Add all elements from one slice to another using ~append~

~append~ is a variadic function. Using this we can easily add all elements from
one slice to another:

#+BEGIN_SRC go :results output
package main

import (
	"fmt"
)

func main() {
	var slice0 []int = []int{1, 2, 3}
	var slice1 []int = []int{4, 5, 6}
	fmt.Println(slice0) // [1 2 3]
	fmt.Println(slice1) // [4 5 6]
	slice0 = append(slice0, slice1...)
	fmt.Println(slice0) // [1 2 3 4 5 6]
	fmt.Println(slice1) // [4 5 6]
}
#+END_SRC

** Enums

Enums like in Java doesn't exist in Go. You can define it like something below

#+BEGIN_SRC go :results output
// from https://www.sohamkamani.com/golang/enums/
package main

import (
	"fmt"
)

type Season int64

const (
	// since iota starts with 0, the first value
	// defined here will be the default (the zero value)
	// Now you can compare with Undefined to see if a
	// variable has been set or not
	Undefined Season = iota
	Summer
	Autumn
	Winter
	Spring
)

func (s Season) String() string {
	switch s {
	case Summer:
		return "summer"
	case Autumn:
		return "autumn"
	case Winter:
		return "winter"
	case Spring:
		return "spring"
	}
	return "unknown"
}


func main() {
	var season Season
	fmt.Println(season)
	fmt.Println(Summer)
	fmt.Println(Autumn)
	fmt.Println(Winter)
	fmt.Println(Spring)
}
#+END_SRC

*** What is ~iota~?

From https://go.dev/ref/spec#Iota:

Within a constant declaration, the predeclared identifier ~iota~ represents
successive untyped integer constants. Its value is the index of the respective
ConstSpec in that constant declaration, starting at zero. It can be used to
construct a set of related constants:

#+BEGIN_SRC go :noeval
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 << iota  // a == 1  (iota == 0)
	b = 1 << iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, unused)
	d = 1 << iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (untyped integer constant)
	v float64 = iota * 42  // v == 42.0  (float64 constant)
	w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0
const y = iota  // y == 0
#+END_SRC

By definition, multiple uses of ~iota~ in the same ConstSpec all have the same
value:

#+BEGIN_SRC go :noeval
const (
	bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                  //                        (iota == 2, unused)
	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)
)
#+END_SRC

This last example exploits the implicit repetition of the last non-empty
expression list. A cleaner example of implicit repetition would be:

#+BEGIN_SRC go :noeval
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // this constant is not exported
)
#+END_SRC

* Naming conventions

- A name must begin with a letter, and can have any number of additional letters
  and numbers.
- A function name cannot start with a number.
- A function name cannot contain spaces.
- If the functions with names that start with an uppercase letter will be
  exported to other packages. If the function name starts with a lowercase
  letter, it won't be exported to other packages, but you can call this function
  within the same package.
- If a name consists of multiple words, each word after the first should be
  capitalized like this: empName, EmpAddress, etc.
- Function names are case-sensitive (car, Car and CAR are three different
  variables).

* Links

- https://blog.golang.org/defer-panic-and-recover
- https://blog.golang.org/slices-intro
- https://pkg.go.dev/std
- https://golang.org/ref/spec#Composite_literals (https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go)

- https://go.dev/doc/tutorial/
- https://golang.org/doc/effective_go
- https://golang.org/doc/
- https://golangbot.com/learn-golang-series/
- https://gobyexample.com/
- https://www.educative.io/courses/mastering-concurrency-in-go?affiliate_id=5088579051061248
- https://quii.gitbook.io/learn-go-with-tests/
- https://go.dev/doc/faq#closures_and_goroutines

* Pitfalls
** Overuse of declaration (~:=~)

Using ~:=~ to declare and assign a new variable while ~=~ is for assignment
only. If you use ~:=~ in an inner scope and use a name already defined in an
outer scope you will shadow the outer variable.

Here is a modified example used earlier in this guide. In the ~for~ loop we use
~:=~ which will redefine ~s~ instead of assigning a new value to ~s~. This code
will never terminate as the inner ~s~ will always get a value based on the other
~s~ (~[1,2]~) and the outer ~s~ will never change. The exit condition will never
be reached.

#+BEGIN_SRC go :noeval
package main

import "fmt"

func main() {
	originalArray := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

	s := originalArray[0:2] // Backed by original array
	printSlice(s)

	for cap(s) > 2 { // As long as we have capacity to extend beyond our length
		s := s[1:3] // THIS LINE DEFINES A NEW VARIABLE
		printSlice(s)
	}
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

Changing ~:=~ to ~=~ will make the example work as we now will start assigning
new values to ~s~ (inner ~s~ and outer ~s~ is the same variable).

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	originalArray := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

	s := originalArray[0:2] // Backed by original array
	printSlice(s)

	for cap(s) > 2 { // As long as we have capacity to extend beyond our length
		s = s[1:3] // THIS LINE ASSIGNS A NEW VALUE TO s
		printSlice(s)
	}
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

** Pointers to objects in a slice

Using pointers to elements in a slice which may be resized is dangerous. When
the slice is resized a new array may be allocated (depending on the capacity)
and then your pointer will still point to the value in the old array.

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := []int{0, 1, 2, 3, 4}
	p := &s[1]
	printSlice(s) // len=5 cap=5 [0 1 2 3 4]
	*p = 9
	printSlice(s) // len=5 cap=5 [0 9 2 3 4]
	// len == cap which will force go to create a new underlying array
	s = append(s, 5)
	printSlice(s) // len=6 cap=10 [0 9 2 3 4 5]
	fmt.Println(*p) // 9
	*p = 2
	printSlice(s) // len=6 cap=10 [0 9 2 3 4 5] <-- NO CHANGE
	fmt.Println(*p) // 2
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
#+END_SRC

To come around this you can create a slice of pointers instead:

#+BEGIN_SRC go :results output
package main

import "fmt"

func main() {
	s := make([]*int, 5, 5) // len=5 cap=5 [ <nil> <nil> <nil> <nil> <nil>]
	printSlice(s)
	for i := 0; i < 5; i++ {
		v := i
		s[i] = &v
	}
	p := s[1]
	printSlice(s) // len=5 cap=5 [ 0 1 2 3 4]
	*p = 9
	printSlice(s) // len=5 cap=5 [ 0 9 2 3 4]
	v := 5
	// len == cap which will force go to create a new underlying array
	s = append(s, &v)
	printSlice(s) // len=6 cap=10 [ 0 9 2 3 4 5]
	fmt.Println(*p) // 9
	*p = 2
	printSlice(s) // len=6 cap=10 [ 0 2 2 3 4 5] <-- SUCCESSFULLY UPDATED
	fmt.Println(*p) // 2
}

func printSlice(s []*int) {
	fmt.Printf("len=%d cap=%d [", len(s), cap(s))
	for _, v := range s {
		if v == nil {
			fmt.Printf(" <nil>")
		} else {
			fmt.Printf(" %v", *v)
		}
	}
	fmt.Println("]")
}
#+END_SRC

* Questions

- https://www.sohamkamani.com/golang/type-assertions-vs-type-conversions/
- https://talks.golang.org/2012/10things.slide#1
- Equality. Floats and strings
- Equality. Pointers
- Exception handling?
- Embedding https://go.dev/doc/effective_go#embedding
- Packages
- Higher order functions (https://www.golangprograms.com/higher-order-functions-in-golang.html)
- Generators and iterators http://www.golangpatterns.info/concurrency/generators
- About reveiver types: https://github.com/golang/go/wiki/CodeReviewComments#receiver-type
- ~new~ keyword? https://forum.golangbridge.org/t/how-to-cast-interface-to-a-given-interface/13997
- default implementations interface
  - https://www.reddit.com/r/golang/comments/28garc/what_is_the_preferred_way_to_provide_a_default/
  - https://go.dev/play/p/9l68IatydV
  - https://go.dev/play/p/ByoUzfqOpn
- https://yourbasic.org/golang/switch-statement/
- https://yourbasic.org/golang/for-loop-range-array-slice-map-channel/
- Reflect package?
- printf. Document placeholders
- Pointer escape analysis: https://stackoverflow.com/questions/13715237/return-pointer-to-local-struct
- Full slice expression: https://go.dev/ref/spec#Slice_expressions
- Varargs (~...~) both as argument and deconstruct array (given to as an argument)
- ~GOPATH~
- Strings, bytes, runes and characters in Go: https://go.dev/blog/strings
- https://pkg.go.dev/container/heap#Interface PriorityQueue. Hur kan interfacet implementeras som en mix?
- https://pkg.go.dev/fmt
- loop over map
- loop over channel
- write to channel and then read directly after
- https://yourbasic.org/golang/concurrent-programming/
- https://yourbasic.org/golang/gotcha-why-nil-error-not-equal-nil/

Values are returned by value:

#+BEGIN_SRC go :results output
package main

import "fmt"

type Foo struct {
	num int
}

func NewFoo() (Foo, *Foo) {
	f := Foo{33}
	p := &f
	p.num = 77 // Updates both values
	return f, p
}

func main() {
	// p is _NOT_ pointing a f
	f, p := NewFoo()
	fmt.Printf("f: %d p: %d\n", f.num, p.num) // f: 77 p: 77
	p.num = 44 // f is not updated
	fmt.Printf("f: %d p: %d\n", f.num, p.num) // f: 77 p: 44
}
#+END_SRC
