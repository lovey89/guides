* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#work-around-to-execute-haskell-programs-in-org-mode][Work around to execute haskell programs in org mode]]
- [[#basics][Basics]]
  - [[#basic-arithmetic][Basic arithmetic]]
  - [[#basic-logic-operators][Basic logic operators]]
  - [[#calling-functions][Calling functions]]
  - [[#defining-functions][Defining functions]]
  - [[#the-if-statement][The ~if~ statement]]
  - [[#lists][Lists]]
  - [[#tuples][Tuples]]
- [[#links][Links]]
#+END_QUOTE

* Work around to execute haskell programs in org mode

Executable code but syntax highlighting is set to python

#+BEGIN_SRC  python :python runghc :results output
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

Correct syntax highlighting but not executable

#+BEGIN_SRC  haskell
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

To toggle between these two modes you can run the ~toggleedit~ script. Note that
the two code blocks above have an extra space before the language name so that
they will not be affected by the script. The code block below will be affected
though

#+BEGIN_SRC haskell
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

* Basics
** Basic arithmetic

#+BEGIN_SRC haskell
main = do
  -- Addition
  print (2 + 2)
  -- Subtraction
  print (5 - 2)
  -- Multiplication
  print (5 * 5)
  -- Division (not integer division)
  print (5 / 2)
  -- Integer division
  print (div 5 2)
  -- Modulo
  print (mod 2 (-3))
  print (rem 2 (-3))
  -- Change precedence with parentheses
  print (2 + 2 * 2)
  print ((2 + 2) * 2)
#+END_SRC

When working with negative number, always enclose them in parentheses. The
example below won't work

#+BEGIN_SRC haskell
main = do
  print (5 * -3)
#+END_SRC

While the following will

#+BEGIN_SRC haskell
main = do
  print (5 * (-3))
#+END_SRC

** Basic logic operators

#+BEGIN_SRC haskell
main = do
  -- And
  print (True && True)
  print (True && False)
  -- Or
  print (True || False)
  print (False || False)
  -- Not
  print (not (True && False))
  print (not True)
#+END_SRC

Testing equality

#+BEGIN_SRC haskell
main = do
  -- Equality
  print (9 == 9)
  print (8 == 9)
  print ("hello" == "hello")
  -- Inequality
  print (9 /= 9)
  print (8 /= 9)
#+END_SRC

~==~ and ~/=~ will only work if the two elements can be compared. The following
will now work

#+BEGIN_SRC haskell
main = do
  print (4 /= "hello")
#+END_SRC

But sometimes objects of different types can be compared. E.g. integers and
floats. In the following example the integer will be converted to a float

#+BEGIN_SRC haskell
main = do
  print (4.0 == 4)
#+END_SRC

Comparing number

#+BEGIN_SRC haskell
main = do
  print (4 < 5)
  print (5 < 4)
  print (4 > 5)
  print (5 > 4)
  print (4 <= 5)
  print (5 <= 5)
  print (4 >= 5)
  print (5 >= 5)
#+END_SRC

** Calling functions

In haskell no parantheses should be used when providing the arguments to a
function. You just separate all arguments with a space. In the following
examples we still use parantheses for the ~print~ function. Otherwise ~succ 8~
would be treated a two arguments to the ~print~ function instead of a function
call itself

#+BEGIN_SRC haskell
main = do
  print (succ 8)
#+END_SRC

Multiple arguments

#+BEGIN_SRC haskell
main = do
  print (min 8 15)
  print (max 6.4 2)
#+END_SRC

A function call has the highest precedence so you don't need to put parantheses
around it

#+BEGIN_SRC haskell
main = do
  print (succ 9 + max 5 4 + 1)
  print ((succ 9) + (max 5 4) + 1)
  print (succ 8 * 2)
  print (succ (8 * 2))
#+END_SRC

You can make a function /infix/ by putting backticks around the function name

#+BEGIN_SRC haskell
main = do
  print (div 11 3)
  print (11 `div` 3)
#+END_SRC

** Defining functions

The following code defines a function that will double the input value

#+BEGIN_SRC haskell
doubleMe x = x + x

main = do
  print (doubleMe 5)
#+END_SRC

The order the functions are defined doesn't matter

#+BEGIN_SRC haskell
main = do
  print (doubleMe 5)

doubleMe x = x + x
#+END_SRC

Note that the ~doubleMe~ function doesn't specify a type so any type where the
~+~ operator can be applied can be used

#+BEGIN_SRC haskell
doubleMe x = x + x

main = do
  print (doubleMe 5)
  print (doubleMe 8.3)
#+END_SRC

Let us define 2 functions that double 2 input values and sums them together

#+BEGIN_SRC haskell
doubleMe x = x + x

doubleUs x y = 2 * x  + 2 * y
doubleUs2 x y = doubleMe x  + doubleMe y

main = do
  print (doubleUs 3 4)
  print (doubleUs2 3 4)
#+END_SRC

And let us define a function with no arguments

#+BEGIN_SRC haskell
numberOne = 1

main = do
  print (numberOne)
#+END_SRC

*** Naming

A function can't start with a capital letter and ~'~ is a valid character to
use. It is often used to denote a strict version of a function (one that isn't
lazy) or a slightly modified version of a function or a variable

** The ~if~ statement

Unlike other languages the ~else~ part is mandatory in Haskell. The ~if~
statement is an expression in Haskell as it has a return value. Below we are
writing the ~if~ statement on multiple lines but we can write it all on the same
line if we wanted to

#+BEGIN_SRC haskell
doubleOddNumber x = if x `mod` 2 == 0
                      then x
                      else x * 2

main = do
  print (doubleOddNumber 6)
  print (doubleOddNumber 5)
  print (doubleOddNumber (-4))
  print (doubleOddNumber (-7))
#+END_SRC

Since the ~if~ statement have a return value we can easily add 1 to the result

#+BEGIN_SRC haskell
doubleOddNumberAndAddOne x = (if x `mod` 2 == 0
                                then x
                                else x * 2) + 1

main = do
  print (doubleOddNumberAndAddOne 6)
  print (doubleOddNumberAndAddOne 5)
  print (doubleOddNumberAndAddOne (-4))
  print (doubleOddNumberAndAddOne (-7))
#+END_SRC

** Lists

In Haskell lists stores data of the same type so we can't have a list which both
store integers and characters. The ~let~ keyword is used in Haskell to define a
name

#+BEGIN_SRC haskell
main = do
  let myNumberList = [1,2,4,8,16,32]
  print myNumberList
  let myCharList = ['C','h','a','r','s']
  print myCharList
  let myStringList = ["My","String", "List"]
  print myStringList
#+END_SRC

As you see from the output of ~myCharList~ above, a string is a list of chars

#+BEGIN_SRC haskell
main = do
  print ("Chars" == ['C','h','a','r','s'])
#+END_SRC

Since strings are list we can use list functions on them

*** Concatenate lists

Concatenation is done with the ~++~ operator. Note that it can also be used on
strings which are nothing but a list of characters

#+BEGIN_SRC haskell
main = do
  print ([1,2,3,4] ++ [5,6,7,8])
  print ("Hello" ++ " " ++ "World")
  print (['H','a','s'] ++ ['k','e','l','l'])
#+END_SRC

Note that when you concatenate two lists, Haskell will internally walk through
all elements on the left hand side of the ~++~. This may affect performance for
big left hand side lists. Note that putting something at the beginning of a list
using the cons operator (~:~) is instantaneous

#+BEGIN_SRC haskell
main = do
  print (1:[2,3,4])
  print ('H':"ello World")
#+END_SRC

Note that ~++~ accepts two lists as arguments while ~:~ accepts an element and a
list. ~[1,2,3]~ is actually just syntactic sugar for ~1:2:3:[]~ (~[]~ is the
empty list).

*** Get an element in a list

To get an element at a specific index in the list we use the ~!!~ operator. The
index starts at 0.

#+BEGIN_SRC haskell
main = do
  let myIntegerList = [1,2,4,8,16,32]
  print (myIntegerList !! 1)
  print (myIntegerList !! 4)
#+END_SRC

*** Lists of lists

A list can contain of other lists. As before each element in a list needs to be
of the same type which means that all lists in a list of lists needs to contain
the same type of element, e.g. integers. The lists can be of different lengths.

#+BEGIN_SRC haskell
main = do
  let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
  print b
  print (b ++ [[3,2,1]])
  print ([3,2,1]:b)
  print (b !! 1)
#+END_SRC

*** Comparing lists

Lists can be compared with ~<~, ~<=~, ~>~ and ~>=~ if the elements the list
contains can be compared with these operators. The elements in the lists are
compared in order and if the elements on a index is equal the next pairs will
be compared

#+BEGIN_SRC haskell
main = do
  print ([3,2,1] > [2,1,0])
  print ([3,2,1] > [2,10,100])
  print ([3,4,2] > [3,4]) -- [3,4,2] is considered bigger as it has an extra element
  print ([3,4] > [3,4,2])
  print ([3,4,2] > [2,4])
  print ([3,4,2] == [3,4,2])
#+END_SRC

*** Other functions

~head~ returns the first element in a list

#+BEGIN_SRC haskell
main = do
  print (head [3,2,1])
#+END_SRC

~tail~ returns everything but the head

#+BEGIN_SRC haskell
main = do
  print (tail [4,3,2,1,0])
#+END_SRC

~last~ returns the last element in a list

#+BEGIN_SRC haskell
main = do
  print (last [4,3,2,1,0])
#+END_SRC

~init~ returns everything but the last element

#+BEGIN_SRC haskell
main = do
  print (init [4,3,2,1,0])
#+END_SRC

~length~ returns the length of a list

#+BEGIN_SRC haskell
main = do
  print (length [4,3,2,1,0])
#+END_SRC

~null~ checks if a list is empty. Returns ~True~ if empty. To be used instead of
checking for equality with ~[]~

#+BEGIN_SRC haskell
main = do
  print (null [4,3,2,1,0])
  print (null [])
#+END_SRC

~reverse~ reverses a list

#+BEGIN_SRC haskell
main = do
  print (reverse [4,3,2,1,0])
#+END_SRC

~take~ returns the first ~x~ elements from a list. Can be used on infinite
sequences

#+BEGIN_SRC haskell
main = do
  print (take 3 [4,3,2,1,0])
  print (take 8 [4,3,2,1,0])
  print (take 0 [4,3,2,1,0])
#+END_SRC

~drop~ is the opposite of ~take~. We return everything but the first ~x~
elements

#+BEGIN_SRC haskell
main = do
  print (drop 3 [4,3,2,1,0])
  print (drop 8 [4,3,2,1,0])
  print (drop 0 [4,3,2,1,0])
#+END_SRC

~maximum~ and ~minimum~ returns the largest or smallest element if the elements
can be compared

#+BEGIN_SRC haskell
main = do
  print (maximum [4,3,20,-4,1,0])
  print (minimum [4,3,20,-4,1,0])
#+END_SRC

~sum~ and ~product~ returns the sum or product of a list of numbers

#+BEGIN_SRC haskell
main = do
  print (sum [1,2,3,4])
  print (product [1,2,3,4])
#+END_SRC

~elem~ checks if an element is present in a list

#+BEGIN_SRC haskell
main = do
  print (2 `elem` [1,2,3,4])
  print (5 `elem` [1,2,3,4])
#+END_SRC

*** Texas ranges

If you want to create a list with all numbers ranging from 1 to 50 you can
create the list and provide each number individually. Or you can just write
~[1..50]~. You can do something similar with characters

#+BEGIN_SRC haskell
main = do
  print ([1..50])
  print (['a'..'z'])
  print (['A'..'Z'])
  print (['A'..'z'])
#+END_SRC

You can also define a step. The difference between the first and second element
in the range will be the step size

#+BEGIN_SRC haskell
main = do
  print ([1,4..50])
  print ([10,20..100])
#+END_SRC

You can also have a negative step size

#+BEGIN_SRC haskell
main = do
  print ([20,19..4])
  print ([100,90..0])
#+END_SRC

Because the way floats are handled in the computer it's bad idea to use floats
with ranges

#+BEGIN_SRC haskell
main = do
  print ([0.1, 0.3 .. 1])
#+END_SRC

You don't have to specify an upper limit. This will create an infinite lists but
since Haskell is lazy it will only generate as much as is needed

#+BEGIN_SRC haskell
main = do
  print (take 24 [13,26..])
#+END_SRC

To repeat a list an infinite amount of times you can use the ~cycle~ function

#+BEGIN_SRC haskell
main = do
  print (take 24 (cycle [1,2,3,4]))
  print (take 24 (cycle "Batman"))
#+END_SRC

To repeat an element an infinite numbers of time you can use the ~repeat~
function

#+BEGIN_SRC haskell
main = do
  print (take 24 (repeat 'A'))
  -- Or just use replicate for the same results
  print (replicate 24 'A')
#+END_SRC

*** List comprehensions

With list comprehensions we can transform every value in a list by applying a
function to it. Below we will multiply every value in a list with itself

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10]])
#+END_SRC

We can also filter the result. Say that we are only interested in the power if
two greater than 50

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10], x*x > 50])
#+END_SRC

We can include multiple predicates for the filtering and the element will only
be included in the resulting list if all of them evaluates to true. Let's add
the predicate that the result should be smaller than 90

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10], x*x > 50, x*x < 90])
#+END_SRC

We can also draw values from multiple lists where all combinations from the
input lists will be created. Below we will create tuples for each result

#+BEGIN_SRC haskell
main = do
  print ([(x,y) | x <- [1..4], y <- [3..5]])
#+END_SRC

We can also use predicates when drawing values from multiple lists. Below we
will only output the pairs whos sum is even

#+BEGIN_SRC haskell
main = do
  print ([(x,y) | x <- [1..4], y <- [3..5], even (x + y)])
#+END_SRC

We can now define our own version of ~length~

#+BEGIN_SRC haskell
length' xs = sum [1 | _ <- xs]

main = do
  print (length' [1..10])
#+END_SRC

The ~_~ in the code block above means that we don't care about the value that
would be put in that variable if we gave it a name

We can also nest list comprehensions. The code block below let us remove all odd
values from the containing lists without flattening it

#+BEGIN_SRC haskell
main = do
  let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
  print ([[ x | x <- xs, even x ] | xs <- xxs])
#+END_SRC

** Tuples



* Links

- [[https://hackage.haskell.org/package/CheatSheet-1.11/src/CheatSheet.pdf]]
- [[http://learnyouahaskell.com/chapters]]
