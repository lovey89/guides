* Joins

[[./img/sql_joins.jpg]]

Image found [[https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins][here]]

* Insert data from another table with default values (postgres)

#+BEGIN_SRC sql
INSERT INTO mytable1(col11, col12, col13, col14)
  SELECT col21, col22, 'default_string', 1
  FROM mytable2
  WHERE col23 = 'a_value';
#+END_SRC

* Insert/Update and retrieve the updated rows

#+BEGIN_SRC sql
INSERT INTO mytable(col1, col2, col3)
VALUES ('val1', 'val2', 'val3')
RETURNING
col1, col2, col3, col4, col5;
#+END_SRC

#+BEGIN_SRC sql
UPDATE mytable
SET col1 = 'val1', col2 = 'val2'
WHERE col3 = 'val3'
RETURNING
col1, col2, col3, col4, col5;
#+END_SRC

* Get constraints from Postgrespl

#+BEGIN_SRC sql
-- Table constraints
SELECT *
FROM information_schema.table_constraints;

-- Foreign key constraints
SELECT *
FROM information_schema.referential_constraints;

-- Check constraints
SELECT *
FROM information_schema.check_constraints;
#+END_SRC

* Get currently running queries in Postgresql

#+BEGIN_SRC sql
select pid, usename, state, client_addr, application_name, now()-query_start as "Running time", query
from pg_stat_activity
where state not in ('idle') and usename = 'name' -- Replace name with what?
order by now()-query_start desc; -- Sort by running time
#+END_SRC

* Get currently open connections in Postgresql

#+BEGIN_SRC sql
select client_addr,application_name,usename, pid, state, query_start, now()-query_start as "Running time",query
from pg_stat_activity
where usename = 'name'
order by now()-query_start desc;
#+END_SRC

* Abort queries in Postgresql

I don't know the difference between canceling and killing a query

#+BEGIN_SRC sql
-- cancel a query
SELECT pg_cancel_backend(20475);

-- OR

-- kill query
SELECT pg_terminate_backend(PID);
#+END_SRC

* Order by range (hack solution)

In the example below I want to find the number of people born in a specific
decade where the birth year is found in the birth_year column.

#+BEGIN_SRC sql
select (birth_year / 10) * 10 as decade, count(*)
from people
group by decade
order by decade asc;
#+END_SRC

If you are grouping some value you can use the following code

#+BEGIN_SRC sql
select (ct / 10 + 1) * 10 as numberOfObjects, count(*) --Note the "+ 1". I do that because I wanted the upper bound displayed
from (
  select col_1, count(*) ct
  from table_1
  group by col_1
) as foo -- apparently this is needed
group by numberOfObjects
order by numberOfObjects desc;
#+END_SRC

* Find duplicates

#+BEGIN_SRC sql
SELECT
    name, COUNT(*) as ct
FROM
    users
GROUP BY
    name
HAVING
    COUNT(*) > 1
ORDER BY ct DESC;
#+END_SRC

* Find duplicates (multiple columns)

#+BEGIN_SRC sql
SELECT
    name, email, COUNT(*) as ct
FROM
    users
GROUP BY
    name, email
HAVING
    COUNT(*) > 1
ORDER BY ct DESC;
#+END_SRC

* Doing a ~WHERE IN~ on multiple columns in Postgresql

#+BEGIN_SRC sql
SELECT *
FROM tbl
WHERE (col0, col1) IN ((val01, val02), (val11, val12), (val21, val22))
#+END_SRC

* Getting the total number of elements when using pagenation

#+BEGIN_SRC sql
SELECT *, count(*) OVER() AS full_count
FROM tbl
WHERE condition
ORDER BY col1
LIMIT 25
OFFSET 50
#+END_SRC

The ~full_count~ column will now contiain the total number of elements (before
applying ~LIMIT~ and ~OFFSET~). Note that the database will have to find all
values when using this and it may affect performance. Postgrespl's documentation
contains more information about [[https://www.postgresql.org/docs/current/tutorial-window.html][window functions]].

* Recursive calls in postgresql

#+BEGIN_SRC sql
with RECURSIVE parent (source_node, target_node, data1, data2) AS (
  SELECT source_node, target_node, data1, data2
  FROM graph_edges
  WHERE source_node = 'aaa'
UNION
  SELECT c.source_node, c.target_node, c.data1, c.data2
  FROM parent p join graph_edges c ON p.target_node = c.source_node
)

SELECT *
FROM parent;
#+END_SRC

* Update values in one table given values in another table (postgresql)

#+BEGIN_SRC sql
UPDATE totable t
SET column1 = f.column1,
  column2 = f.column2,
  column3 = f.column3
FROM fromtable f
WHERE f.id = t.id
AND t.id = 1 -- Optional if you only want it to happen on some rows
#+END_SRC

* Run an ~WHERE IN~ and also keep the values not found in the result

In this case I found it best to create a temporary table and then joining the
tables

#+BEGIN_SRC sql
create temp table temp_table(temp_column VARCHAR primary key); -- Or another type if not VARCHAR is suitable

insert into temp_table(temp_column) -- Add the values you want to search for
VALUES ("1"),
  ("2"),
  ("3"),
  ("4");

-- This step will now keep all values in temp_table even if it's not found in other_table
select *
from temp_table t left join other_table o
  on t.temp_column = o.other_column;

-- When you're done
drop table temp_table;
#+END_SRC

* Interesting links

[[http://rachbelaid.com/postgres-full-text-search-is-good-enough/]]
https://niallburkley.com/blog/index-columns-for-like-in-postgres/
http://www.sql-join.com/sql-join-types/
https://www.sitepoint.com/simply-sql-the-from-clause/
