* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#links][Links]]
- [[#install][Install]]
- [[#getting-started][Getting started]]
  - [[#build-infrastructure][Build infrastructure]]
  - [[#change-infrastructure][Change infrastructure]]
  - [[#destroy-infrastructure][Destroy infrastructure]]
  - [[#define-input-variables][Define input variables]]
  - [[#query-data-with-outputs][Query data with outputs]]
- [[#the-command-line-interface][The Command Line Interface]]
  - [[#initialize-terraform-configuration][Initialize Terraform configuration]]
  - [[#create-a-terraform-plan][Create a Terraform plan]]
  - [[#apply-terraform-configuration][Apply Terraform configuration]]
  - [[#customize-terraform-configuration-with-variables][Customize Terraform configuration with variables]]
  - [[#output-data-from-terraform][Output data from Terraform]]
  - [[#manage-terraform-versions][Manage Terraform versions]]
  - [[#lock-and-upgrade-provider-versions][Lock and upgrade provider versions]]
  - [[#target-resources][Target resources]]
  - [[#manage-resource-state][Manage resource state]]
  - [[#import][Import]]
  - [[#use-refresh-only-mode-to-sync-terraform-state][Use refresh-only mode to sync Terraform state]]
- [[#questions][Questions]]
#+END_QUOTE

* Links

- https://developer.hashicorp.com/terraform/tutorials

* Install

#+BEGIN_SRC bash :noeval
sudo dnf install -y dnf-plugins-core
sudo dnf config-manager --add-repo https://rpm.releases.hashicorp.com/fedora/hashicorp.repo
sudo dnf -y install terraform

# Verify
terraform -help # Current version is v1.9.4

# Enable auto complete
terraform -install-autocomplete
#+END_SRC

* Getting started
** Build infrastructure

With Terraform, you can provision an NGINX server in less than a minute using
Docker.

We have already created the project in [[file:001_learn-terraform-docker-container][001_learn-terraform-docker-container]].
This working directory houses the configuration files that you write to describe
the infrastructure you want Terraform to create and manage. When you initialize
and apply the configuration here, Terraform uses this directory to store
required plugins, modules (pre-written configurations), and information about
the real infrastructure it created.

Navigate to [[file:001_learn-terraform-docker-container][001_learn-terraform-docker-container]] and initialize the project
which downloads a plugin called provider that lets Terraform interact with
Docker.

#+BEGIN_SRC bash :noeval
terraform init
#+END_SRC

Provision the NGINX server with ~apply~:

#+BEGIN_SRC bash :noeval
terraform apply
#+END_SRC

Verify that the container is created with the ~docker ps~ command and open a web
browser and navigate to http://localhost:8000.

Stop the container with ~terraform destroy~.

*** Review the configuration

The set of files used to describe infrastructure in Terraform is known as a
/Terraform configuration/. Each configuration must be in its own working
directory. This is a complete configuration that you can deploy with Terraform.

**** ~terraform~ Block

The ~terraform {}~ block contains Terraform settings, including the required
providers Terraform will use to provision your infrastructure. For each
provider, the ~source~ attribute defines an optional hostname, a namespace, and
the provider type. Terraform installs providers from the [[https://registry.terraform.io/][Terraform Registry]] by
default. In this example configuration, the ~docker~ provider's source is
defined as ~kreuzwerker/docker~, which is shorthand for
~registry.terraform.io/kreuzwerker/docker~.

You can also set a version constraint for each provider defined in the
~required_providers~ block. The ~version~ attribute is optional, but
recommended. If no version is specified the most recent version will be
downloaded.

Docs: https://developer.hashicorp.com/terraform/language/providers/requirements

**** ~provider~ Block

The ~provider~ block configures the specified provider, in this case ~docker~. A
provider is a plugin that Terraform uses to create and manage your resources.

You can use multiple provider blocks in your Terraform configuration to manage
resources from different providers. You can even use different providers
together. For example, you could pass the Docker image ID to a Kubernetes
service.

**** ~resource~ Blocks

Use ~resource~ blocks to define components of your infrastructure. A resource
might be a physical or virtual component such as a Docker container, or it can
be a logical resource such as a Heroku application.

Resource blocks have two strings before the block: the resource type and the
resource name. In this example, the first resource type is ~docker_image~ and
the name is ~nginx~. The prefix of the type maps to the name of the provider. In
the example configuration, Terraform manages the ~docker_image~ resource with
the ~docker~ provider. Together, the resource type and resource name form a
unique ID for the resource. For example, the ID for your Docker image is
~docker_image.nginx~.

Resource blocks contain arguments which you use to configure the resource.
Arguments can include things like machine sizes, disk image names, or VPC IDs.
The [[https://developer.hashicorp.com/terraform/language/providers][providers reference]] documents the required and optional arguments for each
resource. For your container, the example configuration sets the Docker image as
the image source for your ~docker_container~ resource.

*** Initialize the directory

When you create a new configuration — or check out an existing configuration
from version control — you need to initialize the directory with ~terraform
init~.

Initializing a configuration directory downloads and installs the providers
defined in the configuration, which in this case is the ~docker~ provider.

Terraform downloads the ~docker~ provider and installs it in a hidden
subdirectory of your current working directory, named ~.terraform~. The
~terraform init~ command prints out which version of the provider was installed.
Terraform also creates a lock file named ~.terraform.lock.hcl~ which specifies
the exact provider versions used, so that you can control when you want to
update the providers used for your project.

*** Format and validate the configuration

The ~terraform fmt~ command automatically updates configurations in the current
directory for readability and consistency.

When you run ~terraform fmt~, Terraform will print out the names of the files it
modified, if any.

You can also make sure your configuration is syntactically valid and internally
consistent by using the ~terraform validate~ command.

No extra arguments needs to be added to either ~terraform fmt~ or ~terraform
validate~.

*** Create infrastructure

Apply the configuration now with the ~terraform apply~ command. Before it
applies any changes, Terraform prints out the execution plan which describes the
actions Terraform will take in order to change your infrastructure to match the
configuration.

Terraform will now pause and wait for your approval before proceeding. If
anything in the plan seems incorrect or dangerous, it is safe to abort here with
no changes made to your infrastructure. In this case the plan is acceptable, so
type ~yes~ at the confirmation prompt to proceed.

*** Inspect state

When you applied your configuration, Terraform wrote data into a file called
~terraform.tfstate~. Terraform stores the IDs and properties of the resources it
manages in this file, so that it can update or destroy those resources going
forward.

The Terraform state file is the only way Terraform can track which resources it
manages, and often contains sensitive information, so you must store your state
file securely and restrict access to only trusted team members who need to
manage your infrastructure. Terraform supports several [[https://developer.hashicorp.com/terraform/language/settings/backends/configuration][remote backends]] you can
use to store and manage your state.

Inspect the current state using ~terraform show~.

*** Manually Managing State

Terraform has a built-in command called ~terraform state~ for advanced state
management. Use the ~list~ subcommand to list of the resources in your project's
state.

#+BEGIN_SRC bash :noeval
terraform state list
#+END_SRC

** Change infrastructure

Infrastructure is continuously evolving, and Terraform helps you manage that
change. As you change Terraform configurations, Terraform builds an execution
plan that only modifies what is necessary to reach your desired state.

*** Update configuration

Now update the external port number of your container. Change the
~docker_container.nginx~ resource under the provider block in
[[file:001_learn-terraform-docker-container/main.tf][001_learn-terraform-docker-container/main.tf]] by replacing the ~ports.external~
value of ~8000~ with ~8080~.

*** Apply changes

This update changes the port number your container uses to serve your nginx
server. The Docker provider knows that it cannot change the port of a container
after it has been created, so Terraform will destroy the old container and
create a new one.

Run ~terraform apply~ again to see how Terraform will apply this change to the
existing resources.

The prefix ~-/+~ means that Terraform will destroy and recreate the resource,
rather than updating it in-place. Terraform can update some attributes in-place
(indicated with the ~~~ prefix), but changing the port for a Docker container
requires recreating it. Terraform handles these details for you, and the
execution plan displays what Terraform will do.

The output will also reveal what forces Terraform to replace the container by
displaying ~# forces replacement~ next to the field(s) that caused it.

** Destroy infrastructure

The ~terraform destroy~ command terminates resources managed by your Terraform
project. This command is the inverse of ~terraform apply~ in that it terminates
all the resources specified in your Terraform state. It does not destroy
resources running elsewhere that are not managed by the current Terraform
project.

The ~-~ prefix indicates that the container will be destroyed. As with apply,
Terraform shows its execution plan and waits for approval before making any
changes. In more complicated cases with multiple resources, Terraform will
destroy them in a suitable order to respect dependencies.

** Define input variables

Terraform configurations can include variables to make your configuration more
dynamic and flexible.

A project has already been setup at [[file:002_docker-container-with-variable][002_docker-container-with-variable]] which is
very similar to [[file:001_learn-terraform-docker-container][001_learn-terraform-docker-container]]. The differences are
explained below.

*** Set the container name with a variable

The current configuration includes a number of hard-coded values. Terraform
variables allow you to write configuration that is flexible and easier to
re-use.

Create a new file called ~variables.tf~ with a block defining a new
~container_name~ variable.

#+BEGIN_SRC hcl
variable "container_name" {
  description = "Value of the name for the Docker container"
  type        = string
  default     = "ExampleNginxContainer"
}
#+END_SRC

The name of the files are not important. Terraform loads all files in the
current directory ending in ~.tf~, so you can name your configuration files
however you choose.

In ~main.tf~, we have updated the ~docker_container~ resource block to use the
new variable by specifying ~name = var.container_name~. The ~container_name~
variable block will default to its default value unless you declare a different
value.

*** Apply your configuration

You can now apply your change with the default value with ~terraform apply~ or
override the value with the ~-var~ option.

Try both and see how terraform updates the state:

#+BEGIN_SRC bash :noeval
terraform apply
terraform apply -var "container_name=YetAnotherName"
#+END_SRC

For more about variables see:
https://developer.hashicorp.com/terraform/tutorials/configuration-language/variables

** Query data with outputs

We can use output values to organize data to be easily queried and displayed to
the Terraform user.

We continue with the [[file:002_docker-container-with-variable][002_docker-container-with-variable]] example:

*** Output Docker container configuration

We have also added a file [[file:002_docker-container-with-variable/outputs.tf][002_docker-container-with-variable/outputs.tf]].

*** Inspect output values

You must apply this configuration before you can use these output values. Apply
your configuration now. Terraform prints output values to the screen when you
apply your configuration. You can also query the outputs with the
~terraform output~ command.

You can use Terraform outputs to connect your Terraform projects with other
parts of your infrastructure, or with other Terraform projects. To learn more,
see: https://developer.hashicorp.com/terraform/tutorials/configuration-language/outputs

* The Command Line Interface
** Initialize Terraform configuration

The core Terraform workflow consists of three main steps after you have written
your Terraform configuration:

- *Initialize* prepares your workspace so Terraform can apply your
  configuration.
- Plan allows you to preview the changes Terraform will make before you apply
  them.
- Apply makes the changes defined by your plan to create, update, or destroy
  resources.

When you initialize a Terraform workspace, Terraform configures the backend,
installs all providers and modules referred to in your configuration, and
creates a version lock file if one doesn't already exist. In addition, you can
use the terraform init command to change your workspace's backend and upgrade
your workspace's providers and modules.

*** Initialize your workspace

#+BEGIN_SRC bash :noeval
terraform init
#+END_SRC

When you initialize a workspace, Terraform will attempt to download the provider
versions specified by the workspace's lock file. If the lock file does not
exist, Terraform will use the ~required_providers~ block to determine the
provider version and create a new lock file. If neither exists, Terraform will
search for a matching provider and download the latest version.

The lock file ~.terraform.lock.hcl~ should be commited to your repository to
ensure that the same provider versions are used across the team.

*** When to initialize Terraform

You initialize your Terraform workspace with terraform init when:

- You create new Terraform configuration and are ready to use it to create a
  workspace and provision infrastructure.
- You clone a version control repository containing Terraform configuration, and
  are ready to use it to create a workspace and provision infrastructure.
- You add, remove, or change the version of a module or provider in an existing
  workspace.
- You add, remove, or change the backend or cloud blocks within the terraform
  block of an existing workspace.

** Create a Terraform plan

When you provision infrastructure, Terraform creates an execution plan before it
applies any changes. Terraform creates the plan by comparing your Terraform
configuration to the state of your infrastructure. The execution plan consists
of a set of changes that create, update, or destroy resources. You can use the
~terraform plan~ command to compare your configuration to your resource's state,
review changes before you apply them, or to refresh your workspace's state.
Terraform plan supports automation workflows in CI/CD pipelines by guaranteeing
that the infrastructure changes Terraform applies match the ones you or your
team approve, even if the deploy process completes across different machines or
at different times.

*** Create a plan

There are three commands that tell Terraform to generate an execution plan:

- The ~terraform plan~ command creates a plan consisting of a set of changes
  that will make your resources match your configuration. This lets you preview
  the actions Terraform would take to modify your infrastructure before applying
  them. Terraform plan does not make any changes to your resources, you must
  apply a plan for Terraform to make changes.

  You can also save a plan with the ~-out~ flag. Later, you can apply the saved
  plan, and Terraform will only perform the changes listed in the plan. In an
  automated Terraform pipeline, applying a saved plan file ensures that
  Terraform only makes the changes you expect, even if your pipeline runs across
  multiple machines at different times.

- The ~terraform apply~ command applies a Terraform plan. If you do not pass a
  saved plan, then Terraform will a create a plan and prompt you for approval
  before applying the plan.

- The ~terraform destroy~ command creates an execution plan to delete all of the
  resources managed by your workspace.

Generate a plan:

#+BEGIN_SRC bash :noeval
terraform plan -out "tfplan"
#+END_SRC

The file ~tfplan~ is not in human readable format but you can inspect it with:

#+BEGIN_SRC bash :noeval
terraform show "tfplan"
#+END_SRC

You can also convert the code to json to easily inspect it with code:

#+BEGIN_SRC bash :noeval
terraform show -json "tfplan" | jq > tfplan.json
#+END_SRC

*Note:* Terraform plan files can contain sensitive data. Never commit a plan
file to version control.

*** Apply a saved plan

#+BEGIN_SRC bash :noeval
terraform apply "tfplan"
#+END_SRC

** Apply Terraform configuration

When you apply changes to your infrastructure, Terraform uses the providers and
modules installed during initialization to execute the steps stored in an
execution plan. These steps create, update, and delete infrastructure to match
your resource configuration.

*** Apply configuration

Apply the configuration with:

#+BEGIN_SRC bash :noeval
terraform apply
#+END_SRC

When you approve the plan and apply this configuration, Terraform will:

1. Lock your workspace's state, so that no other instances of Terraform will
   attempt to modify your state or apply changes to your resources. If Terraform
   detects an existing lock file (~.terraform.tfstate.lock.info~), it will
   report an error and exit.
2. Create a plan, and wait for you to approve it. Alternatively, you can provide
   a saved plan created with the ~terraform plan~ command, in which case
   Terraform will not prompt for approval.
3. Execute the steps defined in the plan using the providers you installed when
   you initialized your configuration. Terraform executes steps in parallel when
   possible, and sequentially when one resource depends on another.
4. Update your workspace's state with a snapshot of the new state of your
   resources.
5. Unlock your workspace's state.
6. Report the changes it made, as well as any output values defined in your
   configuration.

*** Errors during apply

When Terraform encounters an error during an apply step, it will:

1. Log the error and report it to the console.
2. Update the state file with any changes to your resources.
3. Unlock the state file.
4. Exit.

Your infrastructure may be in an invalid state after a Terraform apply step
errors out. Terraform does not support automatically rolling back a
partially-completed apply. After you resolve the error, you must apply your
configuration again to update your infrastructure to the desired state.

If the state has changed between the time you have created a plan and the time
you apply it since Terraform assumes as certain state.

Common reasons for apply errors include:

1. A change to a resource outside of Terraform's control.
2. Networking or other transient errors.
3. An expected error from the upstream API, such as a duplicate resource name or
   reaching a resource limit.
4. An unexpected error from the upstream API, such as an internal server error.
5. A bug in the Terraform provider code, or Terraform itself.

Depending on the cause of the error, you may need to resolve the underlying
issue by either modifying your configuration or diagnosing and resolving the
error from the cloud provider API. You can use the ~terraform show~ command to
print out your state. This command does not refresh your state, so the
information in your state can be out of date.

The next time you plan a change to this project, Terraform will update the
current state of your resources from the underlying APIs using the providers you
have installed. At this point Terraform may know how to fix the problem itself.

*** Replace Resources

When using Terraform, you will usually apply an entire configuration change at
once. Terraform and its providers will determine the changes to make and the
order to make them in. However, there are some cases where you may need to
replace or modify individual resources. Terraform provides two arguments to the
~plan~ and ~apply~ commands that allow you to interact with specific resources:
~-replace~ and ~-target~.

Use the ~-replace~ argument when a resource has become unhealthy or stops
working in ways that are outside of Terraform's control.

The ~-replace~ argument requires a resource address. List the resources in your
configuration with ~terraform state list~.

Use the ~-target~ command line argument when you apply to target individual
resources rather than apply the entire configuration.

** Customize Terraform configuration with variables

Terraform's input variables don't change values during a Terraform run such as
plan, apply, or destroy. Instead, they allow users to more safely customize
their infrastructure by assigning different values to the variables before
execution begins, rather than editing configuration files manually.

*** Parameterize your configuration

Variable declarations can appear anywhere in your configuration files. However,
it's recommended to put them into a separate file called ~variables.tf~ to make
it easier for users to understand how they can customize the configuration.

To parameterize an argument with an input variable, you must first define the
variable, then replace the hardcoded value with a reference to that variable in
your configuration. E.g.

#+BEGIN_SRC hcl
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-west-2"
}
#+END_SRC

The fields are:

- ~Description~: A short description to document the purpose of the variable.
- ~Type~: The type of data contained in the variable.
- ~Default~: The default value.

If you do not set a default value for a variable, you must assign a value before
Terraform can apply the configuration. Terraform does not support unassigned
variables.

Variable values must be literal values, and cannot use computed values like
resource attributes, expressions, or other variables. You can refer to variables
in your configuration with ~var.<variable_name>~.

*** Types of variables
**** Simple types

Apart from the ~string~ type there is also a ~number~ and ~bool~ type. These are
called /simple/ types.

When Terraform interprets values, either hard-coded or from variables, it will
convert them into the correct type if possible. So you can supply ~"2"~ instead
of ~2~ and it will work as well.

~bool~ can have the values ~true~ / ~false~.

**** Complex type

Terraform also supports several collection variable types.

- *List*: A sequence of values of the same type.
- *Map*: A lookup table, matching keys to values, all of the same type.
- *Set*: An unordered collection of unique values, all of the same type.

***** ~list~

The type of a ~list~ is given with it's type. E.g. ~list(string)~. But they can
also consit of complex types. E.g. ~list(list)~. Here's an example of a list:

#+BEGIN_SRC hcl
variable "private_subnet_cidr_blocks" {
  description = "Available cidr blocks for private subnets."
  type        = list(string)
  default     = [
    "10.0.101.0/24",
    "10.0.102.0/24",
    "10.0.103.0/24",
    "10.0.104.0/24",
  ]
}
#+END_SRC

You can retrieve elements in a list by index. Retrieve the second element from a
list by index with square brackets: ~var.private_subnet_cidr_blocks[1]~.

To get a slice you use the ~slice()~ function. E.g.:
~slice(var.private_subnet_cidr_blocks, 0, 3)~ will get element 0, 1 and 2 from
the list.

***** ~map~

An example of a map looks like this:

#+BEGIN_SRC hcl
variable "resource_tags" {
  description = "Tags to set for all resources"
  type        = map(string)
  default     = {
    project     = "project-alpha",
    environment = "dev"
  }
}
#+END_SRC

Setting the type to ~map(string)~ tells Terraform to expect strings for the
values in the map. Map keys are always strings.

To retrieve the value of the ~environment~ key from the ~resource_tags~ map:
~var.resource_tags["environment"]~.

You can also replace a full block with a map. E.g.

#+BEGIN_SRC hcl
tags = {
  project     = "project-alpha",
  environment = "dev"
}
#+END_SRC

can be replaced with:

#+BEGIN_SRC hcl
tags = var.resource_tags
#+END_SRC

*** Assign values to variables

Terraform requires a value for every variable. There are several ways to assign
variable values.

**** Use command line flag

You can use ~-var~ to set a variable. E.g.

#+BEGIN_SRC bash :noeval
terraform apply -var ec2_instance_type=t2.micro
# or
terraform plan -var ec2_instance_type=t2.micro
#+END_SRC

**** Assign values with a file

Terraform automatically loads all files in the current directory with the exact
name ~terraform.tfvars~ or matching ~*.auto.tfvars~. You can also use the
~-var-file~ flag to specify other files by name.

These files use syntax similar to Terraform configuration files (HCL), but they
cannot contain configuration such as resource definitions. Like Terraform
configuration files, these files can also contain JSON.

In addition to command line flags and variable files, you can use environment
variables to set input variables.

*** Interpolate variables in strings

Terraform configuration supports string interpolation - inserting the output of
an expression into a string. This allows you to use variables, local values, and
the output of functions to create strings in your configuration. You use the
~${variable}~ syntax.

E.g.

#+BEGIN_SRC hcl
resource "docker_container" "nginx" {
  image = docker_image.nginx.image_id
  name  = "Container_${var.container_name}"

  ports {
    internal = 80
    external = 8080
  }
}
#+END_SRC

*** Validate variables

You can also validate that the provided variables follow a certain format.

#+BEGIN_SRC hcl
variable "resource_tags" {
  description = "Tags to set for all resources"
  type        = map(string)
  default     = {
    project     = "my-project",
    environment = "dev"
  }

  validation {
    condition     = length(var.resource_tags["project"]) <= 16 && length(regexall("[^a-zA-Z0-9-]", var.resource_tags["project"])) == 0
    error_message = "The project tag must be no more than 16 characters, and only contain letters, numbers, and hyphens."
  }

  validation {
    condition     = length(var.resource_tags["environment"]) <= 8 && length(regexall("[^a-zA-Z0-9-]", var.resource_tags["environment"])) == 0
    error_message = "The environment tag must be no more than 8 characters, and only contain letters, numbers, and hyphens."
  }
}
#+END_SRC

Using variable validation can be a good way to catch configuration errors early.

** Output data from Terraform

Terraform output values let you export structured data about your resources. You
can use this data to configure other parts of your infrastructure with
automation tools, or as a data source for another Terraform workspace. Outputs
are also how you expose data from a child module to a root module.

*** Output information

You can add output declarations anywhere in your Terraform configuration files.
However, it's recommended to put them in a separate file called ~outputs.tf~ to
make it easier for users to understand your configuration and review its
expected outputs. E.g.:

#+BEGIN_SRC hcl
output "container_id" {
  description = "ID of the Docker container"
  value       = docker_container.nginx.id
}

output "image_id" {
  description = "ID of the Docker image"
  value       = docker_image.nginx.id
}
#+END_SRC

While the ~description~ argument is optional, you should include it in all
output declarations to document the intent and content of the output.

You can use the result of any Terraform expression as the value of an output.
Add the following definitions to ~outputs.tf~. E.g.

#+BEGIN_SRC hcl
output "lb_url" {
  description = "URL of load balancer"
  value       = "http://${module.elb_http.elb_dns_name}/"
}

output "web_server_count" {
  description = "Number of web servers provisioned"
  value       = length(module.ec2_instances.instance_ids)
}
#+END_SRC

 In order to see these outputs, you need to update the state by applying this
 new configuration, even though the infrastructure will not change.

*** Query outputs

After creating the outputs, use the ~terraform output~ command to query all of
them. You can also query output by name with ~terraform output <name>~.

By default Terraform wraps string outputs in quotes. You can disable that with
the ~-raw~ flag. E.g. ~terraform output -raw container_id~

*** Redact sensitive outputs

You can designate Terraform outputs as sensitive. Terraform will redact the
values of sensitive outputs to avoid accidentally printing them out to the
console. Use sensitive outputs to share sensitive data from your configuration
with other Terraform modules, automation tools, or HCP Terraform workspaces.

Terraform will redact sensitive outputs when planning, applying, or destroying
your configuration, or when you query all of your outputs. Terraform will not
redact sensitive outputs in other cases, such as when you query a specific
output by name, query all of your outputs in JSON format, or when you use
outputs from a child module in your root module.

E.g.

#+BEGIN_SRC hcl
output "db_password" {
  description = "Database administrator password"
  value       = aws_db_instance.database.password
  sensitive   = true
}
#+END_SRC

*** Generate machine-readable output

To get machine-readable format for automation, use the ~-json~ flag:

#+BEGIN_SRC bash :noeval
terraform output -json
#+END_SRC

*** Maps and lists

When you include the ~-json~ flag in your Terraform output commands, Terraform
converts maps and lists to the equivalent JSON data structures. E.g.

#+BEGIN_SRC tf
output "bucket_details" {
  description = "S3 bucket details."
  value = {
    arn    = aws_s3_bucket.data.arn,
    region = aws_s3_bucket.data.region,
    id     = aws_s3_bucket.data.id
  }
}
#+END_SRC

** Manage Terraform versions
*** Terraform version constraints

The following table summarizes some of the ways you can pin the Terraform
version in the ~required_version~ setting in the ~terraform {}~ block:

| Required Version    | Meaning                                           | Considerations                                          |
|---------------------+---------------------------------------------------+---------------------------------------------------------|
| ~1.7.5~             | Only Terraform v1.7.5 exactly                     |                                                         |
| ~>= 1.7.5~          | Any Terraform v1.7.5 or greater                   | Includes Terraform v2.0.0 and above                     |
| ~~> 1.7.5~          | Any Terraform v1.7.x, but not v1.8 or later       | Minor version updates are intended to be non-disruptive |
| ~>= 1.7.5, < 1.9.5~ | Terraform v1.7.5 or greater, but less than v1.9.5 |                                                         |

As a best practice, consider using ~~>~ style version constraints to pin your
major and minor Terraform version. Doing so will allow you and your team to use
patch version updates without updating your Terraform configuration. You can
then plan when you want to upgrade your configuration to use a new version of
Terraform, and carefully review the changes to ensure that your project still
works as intended.

** Lock and upgrade provider versions

Terraform providers manage resources by communicating between Terraform and
target APIs. Whenever the target APIs change or add functionality, provider
maintainers may update and version the provider.

If you do not scope provider version appropriately, Terraform will download the
latest provider version that fulfills the version constraint. This may lead to
unexpected infrastructure changes. By specifying carefully scoped provider
versions and using the dependency lock file, you can ensure Terraform is using
the correct provider version so your configuration is applied consistently.

The provider versions downloaded when running ~terraform init~ will be written
to ~.terraform.lock.hcl~ if it doesn't exists. Otherwise the exact version
written in the lock file will be downloaded. If the lock file is not found it
will download the latest version of the providers that you have defined in the
~required_providers {}~ block.

*** Upgrade the provider version

The ~-upgrade~ flag will upgrade all providers to the latest version consistent
within the version constraints specified in your configuration.

#+BEGIN_SRC bash :noeval
terraform init -upgrade
#+END_SRC

It can also be used for downgrading if the version constrants are modified to
a lower provider version.

Always run a Terraform plan after changing your provider versions. Occasionally
a provider upgrade will require that you to modify your configuration to work
with the new provider version. If the plan or apply steps fail, do not commit
the lock file to version control until you've resolved the error.

** Target resources

When you apply changes to your Terraform projects, Terraform generates a plan
that includes all of the differences between your configuration and the
resources currently managed by your project, if any. When you apply the plan,
Terraform will add, remove, and modify resources as proposed by the plan.

In a typical Terraform workflow, you apply the entire plan at once. Occasionally
you may want to apply only part of a plan, such as when Terraform's state has
become out of sync with your resources due to a network failure, a problem with
the upstream cloud platform, or a bug in Terraform or its providers. To support
this, Terraform lets you target specific resources when you plan, apply, or
destroy your infrastructure. Targeting individual resources can be useful for
troubleshooting errors, but should not be part of your normal workflow.

You can use Terraform's ~-target~ option to target specific resources, modules,
or collections of resources.

*** Try it out

Use project [[file:003_learn-terraform-plan][003_learn-terraform-plan]]:

#+BEGIN_SRC bash :noeval
terraform init
terraform apply
#+END_SRC

Update the ~random_pet~ config:

#+BEGIN_SRC diff
 resource "random_pet" "instance" {
-  length    = 2
+  length    = 5
 }
#+END_SRC

Plan the change:

#+BEGIN_SRC bash :noeval
terraform plan
#+END_SRC

Terraform plans to change the ~random_pet~ resource along with any resources
dependent on it.

Now target only ~random_pet.instance~:

#+BEGIN_SRC bash :noeval
terraform plan -target=random_pet.instance
#+END_SRC

Now only ~random_pet.instance~ will be updated. Try targeting
~docker_container.nginx~ instead:

#+BEGIN_SRC bash :noeval
terraform plan -target=docker_container.nginx
#+END_SRC

Terraform determines that ~docker_container.nginx~ depends on
~random_pet.instance~, and that the instance name configuration has changed.
Because of this dependency, Terraform will update both. Resource targeting
updates resources that the target depends on, but not resources that depend on
it.

You can also provide ~-target~ multiple times.

** Manage resource state

Terraform stores information about your infrastructure in a state file. This
state file keeps track of resources created by your configuration and maps them
to real-world resources.

Terraform compares your configuration with the state file and your existing
infrastructure to create plans and make changes to your infrastructure. When you
run ~terraform apply~ or ~terraform destroy~ against your initialized
configuration, Terraform writes metadata about your configuration to the state
file and updates your infrastructure resources accordingly. Occasionally, you
may need to manipulate your projects state outside of the standard workflow. For
example, you may want to remove a resource from your project without destroying
the real-world resource associated with it.

*** Move a resource to a different state file

You can move a state to a different state file with ~terraform state mv~

*** Remove a resource from state

Use a ~removed~ block to remove specific resources from your state. This does
not destroy the infrastructure itself, instead it indicates that your Terraform
configuration will no longer manage the resource.

Comment out the block of the resource that you don't want Terraform to manage
anylonger and add a ~removed~ block:

#+BEGIN_SRC tf
removed {
  from = aws_instance.example_new

  lifecycle {
    destroy = false
  }
}

# resource "aws_instance" "example_new" {
#   ami                    = data.aws_ami.ubuntu.id
#   instance_type          = "t2.micro"
#   vpc_security_group_ids = [aws_security_group.sg_8080.id]
#   user_data              = <<-EOF
#               #!/bin/bash
#               apt-get update
#               apt-get install -y apache2
#               sed -i -e 's/80/8080/' /etc/apache2/ports.conf
#               echo "Hello World" > /var/www/html/index.html
#               systemctl restart apache2
#               EOF
#   tags = {
#     Name = "terraform-learn-state-ec2"
#   }
# }
#+END_SRC

Then plan and apply the configuration.

** Import

Terraform supports bringing your existing infrastructure under its management.
By importing resources into Terraform, you can consistently manage your
infrastructure using a common workflow.

When you create new infrastructure with Terraform, you usually use the following
workflow:

1. Write Terraform configuration that defines the infrastructure you want to
   create.
2. Review the Terraform plan to ensure the configuration will result in the
   expected infrastructure.
3. Apply the configuration to have Terraform create your infrastructure.

You can use configuration to import existing resources into your state file with
the plan-and-apply workflow. You can use the ~terraform import~ command, but
configuration-driven import is safer, works with CICD pipelines, and allows you
to preview the import operation before modifying state. You can also optionally
use Terraform to generate an initial configuration for the resources you will
import.

Using configuration to import resources involves the following steps:

1. Identify the existing infrastructure you will import.
2. Define an import block for the resources.
3. Run terraform plan to review the import plan and optionally generate
   configuration for the resources.
4. Prune generated configuration to only the required arguments.
5. Apply the configuration to bring the resource into your Terraform state file.

*** Define import block to import docker container

Configuration-driven import relies on the ~import~ block, which has two required
arguments:

- ~id~ is the provider-specific identifier for the infrastructure you want to
  import
- ~to~ is the identifier Terraform will give the resource in state, consisting
  of the resource type and name

The ~id~ for a docker container is the SHA256 container ID you get by running

#+BEGIN_SRC bash :noeval
docker inspect --format="{{.ID}}" <container_name>
#+END_SRC

Add an ~import~ block to your configuration:

#+BEGIN_SRC tf
import {
  id = <container_id_hash>
  to = docker_container.web
}
#+END_SRC

*** Generate configuration

When importing a resource, you must both bring the resource into your state
file, and define a corresponding ~resource~ block for it in your configuration.
Although you can manually define the resource yourself, configuration-driven
import can generate configuration for you to use as a starting point.

The generated configuration contains all possible arguments for the imported
resources, including those set to default values and those without values. it's
recommended that you prune the generated configuration to only required
arguments and arguments whose values differ from defaults, to reduce the size of
your configuration.

Use ~terraform plan~ with the ~-generate-config-out~ flag to generate
configuration for the container you will import. Terraform builds a plan and
outputs the generated configuration for the container to the specified file.

E.g.

#+BEGIN_SRC bash :noeval
terraform plan -generate-config-out=generated.tf
#+END_SRC

Here you may see that Terraform plans to replace the imported resource due to
conflicts in the generated configuration and the imported instance. This is why
we usually need to prune the generated config and get rid of default
configuration. In the end our docker container resource should look something
like this:

#+BEGIN_SRC tf
resource "docker_container" "web" {
  env = []
  image = "..."
  name  = "hashicorp-learn"
  ports {
    external = 8080
    internal = 80
    ip       = "0.0.0.0"
    protocol = "tcp"
  }
}
#+END_SRC

Run ~terraform plan~ to verify that it will not replace the container.

Docker don't store all attributes that Terraform uses to create a container.
Since Docker does not track these attributes, Terraform did not include them in
the generated configuration. When you apply your configuration, the Docker
provider will assign the default values for these attributes and save them in
state, but they will not affect the running container.

It's recommended when you import a resource to make the first operation on the
resource a no-op. Basically, an operation that will not update the imported
resource.

*** Create image resource

You can bring some resources under Terraform's management without using the
~import~ block. This is often the case for resources defined by a single unique
ID or tag, such as Docker images.

In your ~generated.tf~ file, the ~docker_container.web~ resource specifies the
SHA256 hash ID of the image used to create the container. This is how Docker
stores the image ID internally, so the import operation loaded the image ID
directly into your state. However, identifying the image by its tag or name
would make your configuration easier to understand.

Retrieve the image's tag name by running the following command:

#+BEGIN_SRC bash :noeval
docker image inspect -f {{.RepoTags}} `docker inspect --format="{{.Image}}" <container_name>`
#+END_SRC

Then add the following configuration to your terraform configuration file to
represent this image as a resource.

#+BEGIN_SRC tf
resource "docker_image" "nginx" {
  name         = "nginx:latest"
}
#+END_SRC

Run ~terraform apply~. This will load the ~docker_image.nginx~ resource into
state. The image resource must exist in state before you can reference it. If
you would reference it in this step, the container would be recreated since
Terraform wouldn't know the ID during the plan step.

Now that Terraform created a resource for the image, you can reference it in
your container's configuration. Change the ~image~ value for
~docker_container.web~ to reference the new image resource.

Since ~docker_image.nginx.latest~ matches the hardcoded image ID you replaced,
~terraform apply~ returns a no-op.

*** Limitations and other considerations

- Importing manipulates the Terraform state file during the apply. You may want
  to create a backup before importing new infrastructure.
- Terraform import does not detect or generate relationships between
  infrastructure. You can manually add relationships to the configuration before
  you apply changes.
- Terraform import does not detect which default attributes you can skip
  setting.
- Not all providers and resources support Terraform import.
- Importing a resource into Terraform does not mean that Terraform can destroy
  and recreate it. For example, the imported infrastructure could rely on other
  unmanaged infrastructure or configuration.

** Use refresh-only mode to sync Terraform state

Terraform relies on the contents of your workspace's state file to generate an
execution plan to make changes to your resources. To ensure the accuracy of the
proposed changes, your state file must be up to date.

In Terraform, refreshing your state file updates Terraform's knowledge of your
infrastructure, as represented in your state file, with the actual state of your
infrastructure. Terraform ~plan~ and ~apply~ operations run an implicit
in-memory refresh as part of their functionality, reconciling any drift from
your state file before suggesting infrastructure changes. You can also update
your state file without making modifications to your infrastructure using the
~-refresh-only~ flag for ~plan~ and ~apply~ operations.

*** Run a refresh-only plan

A common error scenario that can prompt Terraform to refresh the contents of
your state file is mistakenly modifying your credentials or provider
configuration. E.g. providing the wrong cloud region.

You can compare your infrastructure with your statefile with
~terraform plan -refresh-only~. This will not update your state file. If the
changes in the plan are acceptable, you could run a
~terraform apply -refresh-only~ and approve the operation to overwrite your
state file without modifying your infrastructure.

A refresh-only ~apply~ operation also updates outputs, if necessary.


* Questions

What is the ~data~ keyword?
