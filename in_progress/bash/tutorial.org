* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#temp][Temp]]
- [[#examples][Examples]]
  - [[#script-with-curl-having-a-json-body][Script with curl having a json body]]
  - [[#run-script-with-arguments-from-a-file][Run script with arguments from a file]]
  - [[#assigning-multiple-variables-at-once][Assigning multiple variables at once]]
#+END_QUOTE

* Temp

https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/

#+BEGIN_SRC bash :results output :shebang "#!/bin/bash\nset bon jour"
#!/bin/bash

# An example where the input variables are provided in the source block header

echo $1
echo $2
echo $1$2
echo $#
#+END_SRC

* Examples
** Script with curl having a json body

#+BEGIN_SRC bash :results output :shebang "#!/bin/bash\nset input1 input2"
#!/bin/bash

ARG1="$1"
ARG2="$2"

PAYLOAD=$(cat << END_HEREDOC
{
   "field1": "Fixed value",
   "field2": "$ARG1",
   "field3": "$ARG2",
}
END_HEREDOC
)

# The echo should be removed of course
echo curl -X POST --header 'Content-Type: content-type' -d "$PAYLOAD" 'http://host:port/path/to/call'
#+END_SRC

** Run script with arguments from a file

#+BEGIN_SRC bash :results output
while read p; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n "First
second
third")
#+END_SRC

The example above will not process the last row as there is no ~\n~ on that row.
To overcome this problem you can use the following code

#+BEGIN_SRC bash :results output
while read p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading and trailing spaces  
third')
#+END_SRC

Now we have a problem that leading and trailing whitespaces are removed. This is
fixed by setting ~IFS~ to an empty string.

#+BEGIN_SRC bash :results output
while IFS="" read p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

Now the ~\~ on the third line is escaped. Add the ~-r~ option to ~read~ so
backslashes doesn't act as escape charactes

#+BEGIN_SRC bash :results output
while IFS="" read -r p || [[ -n "$p" ]]; do
  echo "$p" | sed -r 's/.*/"&"/'
done < <(echo -n 'First
second
  Line with leading \and trailing spaces  
third')
#+END_SRC

** Assigning multiple variables at once

Can be useful when using ~sed~ but here is a minimal example

#+BEGIN_SRC bash :results output
read VAR1 VAR2 <<< "  One   Two    Three  "

echo "$VAR1"
echo "$VAR2"
#+END_SRC

As you will notice from the example above all the text that doesn't get placed
in its own variable will be placed in the last variable

If you want to change the separator you can update the ~IFS~ variable.

#+BEGIN_SRC bash :results output
IFS=':' read VAR1 VAR2 <<< "  One    Two:   Three   Four"

echo "$VAR1"
echo "$VAR2"
#+END_SRC
