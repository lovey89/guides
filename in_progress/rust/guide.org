* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#links][Links]]
  - [[#tutorials][Tutorials]]
  - [[#cargo][Cargo]]
  - [[#api][API]]
- [[#other-things-to-look-at][Other things to look at]]
- [[#getting-started][Getting started]]
  - [[#installation][Installation]]
  - [[#hello-world][Hello, World]]
  - [[#hello-cargo][Hello, Cargo]]
- [[#guessing-game][Guessing game]]
- [[#common-programming-concepts][Common Programming Concepts]]
  - [[#variable-and-mutability][Variable and Mutability]]
  - [[#data-types][Data Types]]
  - [[#functions][Functions]]
  - [[#comments][Comments]]
  - [[#control-flow][Control Flow]]
- [[#ownership][Ownership]]
  - [[#ownership-rules][Ownership rules]]
  - [[#the-string-type][The ~String~ type]]
  - [[#memory-and-allocation][Memory and allocation]]
  - [[#ownership-and-functions][Ownership and functions]]
  - [[#return-values-and-scope][Return Values and Scope]]
  - [[#references-and-borrowing][References and Borrowing]]
  - [[#the-slice-type][The slice type]]
- [[#structs][Structs]]
  - [[#struct-update-syntax][Struct update syntax]]
  - [[#destruct-tuples][Destruct tuples]]
  - [[#tuple-structs][Tuple structs]]
  - [[#unit-like-structs][Unit-like structs]]
  - [[#ownerships-of-struct-data][Ownerships of struct data]]
  - [[#an-example-with-structs][An example with structs]]
  - [[#adding-useful-functionality-with-derived-traits][Adding Useful Functionality with Derived Traits]]
  - [[#methods][Methods]]
- [[#enums-and-pattern-matching][Enums and pattern matching]]
  - [[#defining-an-enum][Defining an enum]]
  - [[#the-match-control-flow-construct][The ~match~ control flow construct]]
  - [[#concise-control-flow-with-if-let][Concise Control Flow with ~if let~]]
- [[#managing-growing-projects-with-packages-crates-and-modules][Managing growing projects with packages, crates, and modules]]
  - [[#packages-and-crates][Packages and crates]]
  - [[#defining-modules-to-control-scope-and-privacy][Defining modules to control scope and privacy]]
  - [[#paths-for-referring-to-an-item-in-the-module-tree][Paths for referring to an item in the module tree]]
  - [[#bringing-paths-into-scope-with-the-use-keyword][Bringing paths into scope with the ~use~ keyword]]
  - [[#separating-modules-into-different-files][Separating modules into different files]]
- [[#common-collection][Common collection]]
  - [[#vectors][Vectors]]
  - [[#strings][Strings]]
  - [[#hash-maps][Hash maps]]
- [[#error-handling][Error handling]]
  - [[#unrecoverable-errors-with-panic][Unrecoverable Errors with ~panic!~]]
  - [[#recoverable-errors-with-result][Recoverable Errors with ~Result~]]
  - [[#which-one-to-use][Which one to use]]
- [[#generic-types-traits-and-lifetimes][Generic types, traits, and lifetimes]]
  - [[#generic-data-type][Generic data type]]
  - [[#traits-defining-shared-behavior][Traits: defining shared behavior]]
  - [[#validating-references-with-lifetimes][Validating References with Lifetimes]]
- [[#debug][Debug]]
- [[#crates-and-dependencies][Crates and dependencies]]
- [[#documentation][Documentation]]
- [[#style-guide][Style guide]]
- [[#clippy][Clippy]]
- [[#misc][Misc]]
  - [[#test-is-an-array-slice-and-a-vector-slice-the-same][Test: Is an array slice and a vector slice the same?]]
  - [[#test-iterating-over-arrays-and-vectors][Test: Iterating over arrays and vectors]]
- [[#questions][Questions]]
#+END_QUOTE

* Links
** Tutorials

- https://lborb.github.io/
- https://doc.rust-lang.org/book/
- https://github.com/rust-lang/rustlings/
- https://doc.rust-lang.org/stable/rust-by-example/

** Cargo

- https://doc.rust-lang.org/cargo/
- https://crates.io/

** API

- https://doc.rust-lang.org/std/index.html

* Other things to look at

- ~rustfmt~ command
- The prelude (a list of things that Rust automatically imports into every Rust
  program): https://doc.rust-lang.org/std/prelude/index.html

* Getting started
** Installation

https://doc.rust-lang.org/book/ch01-01-installation.html

#+BEGIN_SRC bash :noeval
curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh
cargo install rust-script # Run rust files as scripts. Needed for emacs babel
                          # Make sure the script is on your path afterwards!
rust-script --version
#+END_SRC

*** Update

Once Rust is installed via rustup, when a new version of Rust is released,
updating to the latest version is easy. From your shell, run the following
update script:

#+BEGIN_SRC bash :noeval
rustup update
#+END_SRC

*** Get documentation

The installation of Rust also includes a local copy of the documentation, so you
can read it offline. Run rustup doc to open the local documentation in your
browser.

#+BEGIN_SRC bash :noeval
rustup doc
#+END_SRC

This didn't work on my machine since [[https://stackoverflow.com/questions/55961953/access-denied-when-i-run-rustup-doc][firefox was installed with snap]] but I could
get it to work with:

#+BEGIN_SRC bash :noeval
google-chrome ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/index.html
#+END_SRC

** Hello, World

Files in rust are on the format ~program_name.rs~. Words should be separated with ~_~.

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
}
#+END_SRC

*** Compile it

Add the code from the file above in a file called ~hello_world.rs~, compile it
with ~rustc~ and execute the produced file, ~~hello_world~:

#+BEGIN_SRC bash :noeva
rustc hello_world.rs
./hello_world
#+END_SRC

*** Things to note

1. The ~main~ function is special: it is always the first code that runs in
   every executable Rust program. The first line declares a function named main
   that has no parameters and returns nothing. If there were parameters, they
   would go inside the parentheses, ~()~.
2. ~println!~ calls a Rust macro. If it called a function instead, it would be
   entered as ~println~ (without the ~!~). TODO: Link to macro section
3. Rust style is to indent with four spaces, not a tab. Run
   ~rustfmt hello_world.rs~ to format code according to the standard.

** Hello, Cargo

Cargo handles a lot of tasks for you, such as building your code, downloading
the libraries your code depends on, and building those libraries.

All code in this section is available in the [[file:001_hello_cargo][001_hello_cargo]] directory.

*** Creating a project

In a directory where you want to create a project, run:

#+BEGIN_SRC bash :noeval
cargo new hello_cargo
cd hello_cargo
#+END_SRC

This created the following file structure:

#+BEGIN_SRC
.
`-- hello_cargo
    |-- Cargo.toml
    `-- src
        `-- main.rs
#+END_SRC

The ~Cargo.toml~ file looks like this:

#+BEGIN_SRC toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#+END_SRC

The ~[package]~ heading, is a section heading that indicates that the following
statements are configuring a package.

The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use.

The ~[dependencies]~ heading, is the start of a section for you to list any of
your project’s dependencies (known as /crates/ in Rust).

Cargo expects your source files to live inside the ~src~ directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code.

*** Building and Running a Cargo Project

To build the project, run the following command while standing in the
~hello_cargo~ directory:

#+BEGIN_SRC bash :noeval
cargo build
#+END_SRC

A file is then created in ~target/debug/hello_cargo~. Run it by running the
following command:

#+BEGIN_SRC bash :noeval
./target/debug/hello_cargo
#+END_SRC

The default build is a ~debug~ build and that's why the binary ends up in that
directory.

You may notice that ~cargo build~ also creates a ~Cargo.lock~ in the top level
directory. This file keeps track of the exact versions of dependencies in your
project. Cargo understands [[https://semver.org/][Semantic Versioning]]. If you specify the version
~0.8.3~ this is actually a shorthand for ~^0.8.3~, meaning any version that is
at least ~0.8.3~ but below ~0.9.0~. Between builds the ~Cargo.lock~ file will
guarantee that the same version is used until you explicitly upgrade the
version. You should never need to update this file manually. If you want to make
cargo to reevaluate the version (finding a suitable version at least ~0.8.3~ but
below ~0.9.0~) you can run:

#+BEGIN_SRC bash :noeval
cargo update
#+END_SRC

You can both compile and run the project in one step by running:

#+BEGIN_SRC bash :noeval
cargo run
#+END_SRC

Cargo will automatically figure out what needs to be recompiled and what doesn't.

If you only want to make sure that the project compiles but not actually compile
the project you can run:

#+BEGIN_SRC bash :noeval
cargo check
#+END_SRC

This is much faster than actually compiling the code during development.

*** Building for release

You maybe noticed that the compile binary ended up in ~target/debug~. This is
a development build. They are faster to compile but are not optimized. In order
to optimize the build (which will also increase the build time) you should run
the following command:

#+BEGIN_SRC bash :noeval
cargo build --release
# --release can be used with run as well
cargo run --release
#+END_SRC

This result will end up in ~target/release~ instead of ~target/debug~ now.

* Guessing game

Code and comments for the guessing game is located in [[file:002_guessing_game][002_guessing_game]].

* Common Programming Concepts
** Variable and Mutability

By default variables are immutable. The code below won't compile since you are
trying to reassign the value of an immutable variable.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

But mutability can be very useful. Variables are immutable only by default and
you can make them mutable by adding ~mut~ in front of the variable name. In
addition to allowing this value to change, ~mut~ conveys intent to future
readers of the code by indicating that other parts of the code will be changing
this variable’s value.

#+BEGIN_SRC rust :results output
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

*** Constants

Rust also supports constants using the ~const~ keyword. An immutable variable
and a constant are not exactly the same in Rust.

- You aren’t allowed to use ~mut~ with constants, they're always immutable.
- You declare constants using the ~const~ keyword instead of the ~let~ keyword
- The type of the value /must/ be annotated
- Constants can be declared in any scope, including the global scope
- Constants may be set only to a constant expression, not the result of a value
  that could only be computed at runtime

Rust’s naming convention for constants is to use all uppercase with underscores
between words.

#+BEGIN_SRC rust :results output
fn main() {
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
    println!("{}", THREE_HOURS_IN_SECONDS)
}
#+END_SRC

*** Shadowing

You can declare a new variable with the same name as a previous variable.
Rustaceans say that the first variable is /shadowed/ by the second, which means
that the second variable’s value is what the program sees when the variable is
used.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;

    // This is allowed even though the previous 'x' isn't mutable since this
    // actually creates a new variable 'x' that shadows the previous one
    let x = x + 1;

    {
        // Also this 'x' will shadow the previous 'x'
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x); // 12
    }

    // The inner shadowing end and 'x' returns to bering 6
    println!("The value of x is: {}", x);
}
#+END_SRC

A shadowing variable can also use a different type. E.g. maybe we want to store
a string with spaces (e.g. for indentation) as an integer instead, the following
code would be allowed:

#+BEGIN_SRC rust :results output
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

Using a mutable variable to achieve the same wouldn't work as that would change
the type of the variable:

#+BEGIN_SRC rust :results output
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

** Data Types

Rust is a statically typed language, meaning that all values in Rust is of a
certain data type and that they must be known at compile time. The compiler can
usually infer what type we want to use based on the value and how we use it. In
cases when many types are possible, we must add a type annotation, like this:

#+BEGIN_SRC rust :noeval
let guess: u32 = "42".parse().expect("Not a number!");
#+END_SRC

*** Scalar Types

A scalar type represents a single value. Rust has four primary scalar types:
- integers
- floating-point numbers
- booleans
- characters

**** Integer Types

Integer types in Rust:

| Length  | Signed  | Unsigned |
|---------+---------+----------|
| 8-bit   | ~i8~    | ~u8~     |
| 16-bit  | ~i16~   | ~u16~    |
| 32-bit  | ~i32~   | ~u32~    |
| 64-bit  | ~i64~   | ~u64~    |
| 128-bit | ~i128~  | ~u128~   |
| arch    | ~isize~ | ~usize~  |

the ~isize~ and ~usize~ types depend on the kind of computer your program is
running on: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on
a 32-bit architecture.

You can write integer literals in any of the forms shown in the table below.
Note that number literals that can be multiple numeric types allow a type suffix,
such as ~57u8~, to designate the type. Number literals can also use ~_~ as a
visual separator to make the number easier to read, such as ~1_000~, which will
have the same value as if you had specified ~1000~.

| Number literals  | Example       |
|------------------+---------------|
| Decimal          | ~98_222~      |
| Hex              | ~0xff~        |
| Octal            | ~0o77~        |
| Binary           | ~0b1111_0000~ |
| Byte (~u8~ only) | ~b'A'~        |

Integer types default to ~i32~. The primary situation in which you’d use ~isize~
or ~usize~ is when indexing some sort of collection.

***** Types must match

It looks like as if the types must match when performing arithmetic operations.
The following example will fail to compile as there is no way to add a variable
of type ~i32~ with another variable of type ~i64~.

#+BEGIN_SRC rust :results output
fn main() {
    let x: i32 = 8;
    let y: i64 = 15;
    let z = x + y;

    println!("x: {}", x);
    println!("y: {}", y);
    println!("z: {}", z);
}
#+END_SRC

***** Overflow

Compiling in debug mode will cause the program to /panic/ at runtime if
overflow occurs. When compiling with the ~--release~ flag, no such checks are
included and Rust will perform /two's complement wrapping/. Relying on integer
overflow’s wrapping behavior is considered an error.

To explicitly handle the possibility of overflow, you can use these families of
methods that the standard library provides on primitive numeric types:

- Wrap in all modes with the ~wrapping_*~ methods, such as ~wrapping_add~
- Return the ~None~ value if there is overflow with the ~checked_*~ methods
- Return the value and a boolean indicating whether there was overflow with the
  ~overflowing_*~ methods
- Saturate at the value’s minimum or maximum values with ~saturating_*~ methods

**** Floating-Point Types

Rust’s floating-point types are ~f32~ and ~f64~, which are 32 bits and 64 bits
in size, respectively. The default type is ~f64~ because on modern CPUs it’s
roughly the same speed as ~f32~ but is capable of more precision.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32

    println!("x: {}", x);
    println!("y: {}", y)
}
#+END_SRC

**** Numeric Operations

#+BEGIN_SRC rust :results output
fn main() {
    // addition
    let sum = 5 + 10;
    println!("sum: {}", sum);

    // subtraction
    let difference = 95.5 - 4.3;
    println!("difference: {}", difference);

    // multiplication
    let product = 4 * 30;
    println!("product: {}", product);

    // division
    let quotient = 56.7 / 32.2;
    // The following will fail since you can't divide a float with an int
    //let quotient = 56.7 / 32;
    // The following will work though
    //let quotient = 56.7 / 32f64;
    let floored = 2 / 3; // Results in 0. Integer division rounds down to the nearest integer
    println!("quotient: {}", quotient);
    println!("floored: {}", floored);

    let truncated = -5 / 3;
    println!("truncated: {}", truncated); // results in -1

    // remainder
    let remainder = 43 % 5;
    println!("remainder: {}", remainder);
}
#+END_SRC

**** The Boolean Type

Boolean type in Rust has two possible values: ~true~ and ~false~. Booleans are
one byte in size. The boolean type in Rust is specified using ~bool~. For
example:

#+BEGIN_SRC rust :results output
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation

    println!("t: {}", t);
    println!("f: {}", f)
}
#+END_SRC

**** The Character Type

Rust’s ~char~ type is the language’s most primitive alphabetic type. ~char~
literals are specified with single quotes, as opposed to string literals, which
use double quotes.

#+BEGIN_SRC rust :results output
fn main() {
    let c = 'z';
    let z: char = 'ℤ';
    let heart_eyed_cat = '😻';

    println!("c: {}", c);
    println!("z: {}", z);
    println!("heart_eyed_cat: {}", heart_eyed_cat);
}
#+END_SRC

Rust’s ~char~ type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII.

*** Compbound types

Compound types can group multiple values into one type. Rust has two primitive
compound types: tuples and arrays.

**** The Tuple Type

Tuples have a fixed length: once declared, they cannot grow or shrink in size.
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. Type annotation is
optional:

#+BEGIN_SRC rust :noeval
fn main() {
    let annotated_tup: (i32, f64, u8) = (500, 6.4, 1);
    let unannotated_tup = (500, 6.4, 1);
}
#+END_SRC

To get the individual values out of a tuple, we can use pattern matching to
destructure a tuple value, like this:

#+BEGIN_SRC rust :results output
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+END_SRC

In the example above we clearly only cared about ~y~ so it's unnecessary to
create ~x~ and ~z~ as well. We can use ~_~ as a placeholder for unused values:

#+BEGIN_SRC rust :results output
fn main() {
    let tup = (500, 6.4, 1);
    let (_, y, _) = tup;

    println!("The value of y is: {}", y);
}
#+END_SRC

In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (~.~) followed by the index of the value we
want to access. For example:

#+BEGIN_SRC rust :results output
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("five_hundred:   {}", five_hundred);
    println!("six_point_four: {}", six_point_four);
    println!("one:            {}", one);
}
#+END_SRC

The tuple without any values, ~()~, is a special type that has only one value,
also written ~()~. The type is called the /unit type/ and the value is called
the /unit value/. Expressions implicitly return the unit value if they don’t
return any other value.

***** Mutable tuples

A tuple can be made mutable by adding the ~mut~ keyword. If you remove the ~mut~
keyword below, the compilation will fail

#+BEGIN_SRC rust :results output
fn main() {
    let mut x: (i32, f64, u8) = (500, 6.4, 1);
    x.0 = 400;
    let not_five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("not_five_hundred: {}", not_five_hundred);
    println!("six_point_four:   {}", six_point_four);
    println!("one:              {}", one);
}
#+END_SRC

**** The Array Type

Unlike a tuple, every element of an array must have the same type. Arrays in
Rust are different from arrays in some other languages because arrays in Rust
have a fixed length, like tuples. The length is defined at compile time. The
length of an array is part of its type.

In Rust, the values going into an array are written as a comma-separated list
inside square brackets:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
}
#+END_SRC

You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:

#+BEGIN_SRC rust :noeval
let a: [i32; 5] = [1, 2, 3, 4, 5];
#+END_SRC

Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [3; 5];
    let b = [3i64; 5]; // To define the type of the elements (in this case i64)
}
#+END_SRC

***** Accessing elements

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

If Rust knows at compile time that you are trying to access elements outside the
valid range, the compile will fail and you will get an error message. But checks
are done during run time as well so if you try to access an element outside the
valid range, the program will panic instead of allowing the program to access
the memory. Run the program in [[file:003_invalid_index][003_invalid_index]] for an example.

***** Mutable lists

Lists are immutable by default. You can make it mutable with the ~mut~ keyword

#+BEGIN_SRC rust :results output
fn main() {
    let mut a = [1, 2, 3, 4, 5];
    a[0] = 20;
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

** Functions

Rust code uses snake case as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+END_SRC

Function definitions in Rust start with ~fn~ and have a set of parentheses after
the function name. The curly brackets tell the compiler where the function body
begins and ends. Note that we defined ~another_function~ after the ~main~
function in the source code; we could have defined it before as well. Rust
doesn’t care where you define your functions, only that they’re defined
somewhere.

*** Function parameters

#+BEGIN_SRC rust :results output
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
#+END_SRC

In function signatures, you /must/ declare the type of each parameter. This is a
deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean.

Function with multiple paramaters:

#+BEGIN_SRC rust :results output
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+END_SRC

*** Function Bodies Contain Statements and Expressions

/Statements/ are instructions that perform some action and do not return a
value. /Expressions/ evaluate to a resulting value. Let’s look at some examples.

Creating a variable and assigning a value to it with the ~let~ keyword is a
statement. ~let y = 6;~ is a statement.

Statements do not return values. Therefore, you can’t assign a ~let~ statement
to another variable. E.g:

#+BEGIN_SRC rust :noeval
let x = (let y = 6); // Not valid code!
#+END_SRC

Expressions can be part of statements: the ~6~ in the statement ~let y = 6;~ is
an expression that evaluates to the value ~6~. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, ~{}~, is an expression, for example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let y = {
        let x = x + 3;
        x + 1
    };
    println!("The value of y is: {}", y);
}
#+END_SRC

The expression

#+BEGIN_SRC rust :noeval
let y = {
    let x = x + 3;
    x + 1
};
#+END_SRC

is a block that, in this case, evaluates to ~9~. That value gets bound to ~y~ as
part of the ~let~ statement. Note the ~x + 1~ line without a semicolon at the
end. Expressions do not include ending semicolons. If you add a semicolon to the
end of an expression, you turn it into a statement, which will then not return a
value. Keep this in mind as you explore function return values and expressions
next.

*** Functions with Return Values

Functions can return values to the code that calls them. We declare their type
after an arrow (~->~). In Rust, the return value of the function is synonymous
with the value of the final expression in the block of the body of a function.
You can return early from a function by using the ~return~ keyword and
specifying a value, but most functions return the last expression implicitly.

#+BEGIN_SRC rust :results output
fn five() -> i32 {
    5 // Note that there's no semi colon here
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
#+END_SRC

Another example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = plus_one(5);
    println!("The value of x is: {}", x);
    let y = plus_two(5);
    println!("The value of y is: {}", y);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}

fn plus_two(x: i32) -> i32 {
    // You are allowed to use 'return' to return early
    return x + 2 // Seems like the semi colon is optional here
}
#+END_SRC

**** Returning multiple values

You can always return a tuple if you want to:

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
#+END_SRC

** Comments

[[https://doc.rust-lang.org/reference/comments.html][Comments reference]]

Like in Java:

- Single line comments with ~//~
- Multi line comments starting with ~/*~ and ending with ~*/~

** Control Flow
*** ~if~ expressions

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+END_SRC

Blocks of code associated with the conditions in ~if~ expressions are sometimes
called /arms/. The ~else~ expression is optional.

It’s also worth noting that the condition in this code must be a ~bool~. If the
condition isn’t a ~bool~, we’ll get an error.

**** Handling Multiple Conditions with ~else if~

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+END_SRC

**** Using ~if~ in a ~let~ Statement

Because ~if~ is an expression, we can use it on the right side of a ~let~
statement:

#+BEGIN_SRC rust :results output
fn main() {
    let condition = true;
    // Notice the lack of semi colons inside the blocks. They are expressions!
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+END_SRC

Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the whole
~if~ expression depends on which block of code executes. This means the values
that have the potential to be results from each arm of the ~if~ must be the same
type. In the code above, the results of both the ~if~ arm and the ~else~ arm
were ~i32~ integers. If the types are mismatched we’ll get an error.

*** Repetition with Loops

Rust has three kinds of loops:

- ~loop~
- ~while~
- ~for~

**** The ~loop~ loop

The ~loop~ keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop. You can place the ~break~
keyword within the loop to tell the program when to stop executing the loop.

We can also use the ~continue~ keyword. The ~continue~ keyword within a loop
tells the program to skip over any remaining code in this iteration of the loop
and go to the next iteration.

If you have loops within loops, ~break~ and ~continue~ apply to the innermost
loop at that point. You can optionally specify a /loop label/ on a loop and then
use the label with ~break~ or ~continue~ to have those keywords applied to the
labeled loop instead of the innermost loop. Here’s an example with two nested
loops:

#+BEGIN_SRC rust :results output
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+END_SRC

The outer loop has the label ~'counting_up~ (you need to start the label with a
~'~), and it will count up from 0 to 2. The inner loop without a label counts
down from 10 to 9. The first ~break~ that doesn’t specify a label will exit the
inner loop only. The ~break 'counting_up;~ statement will exit the outer loop.

***** Returning values from loops

One of the uses of a ~loop~ is to retry an operation you know might fail, such
as checking whether a thread has completed its job. However, you might need to
pass the result of that operation to the rest of your code. To do this, you can
add the value you want returned after the ~break~ expression you use to stop the
loop; that value will be returned out of the loop so you can use it, as shown
here:

#+BEGIN_SRC rust :results output
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("The result is {}", result);
}
#+END_SRC

**** The ~while~ loop

A ~while~ loop works as one would expect. ~break~ and ~continue~ are also allowed.

#+BEGIN_SRC rust :results output
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+END_SRC

**** The ~for~ loop

The ~for~ loop can be used when looping over the elements of a collection. You
could do it with a ~while~ loop as well but it's more error prone (the index may
go out of bounds which will cause the program to panic if you enter the wrong
value) and less efficient (Rust adds a check that the index is within the bound
of the array on every iteration).

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+END_SRC

With the ~for~ loop:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
#+END_SRC

Even in situations in which you want to run some code a certain number of times,
as in the countdown example that used a ~while~ loop above, you can use a ~for~
loop. The way to do that would be to use a ~Range~, provided by the standard
library, which generates all numbers in sequence starting from one number and
ending before another number. ~rev~ reverses the range.

#+BEGIN_SRC rust :results output
fn main() {
    for number in (1..4).rev() {
    // Or
    //for number in (1..=3).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
#+END_SRC

* Ownership
** Ownership rules

Keep these rules in mind as we work through the examples that illustrate them:

- Each value in Rust has an owner.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.

** The ~String~ type

We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable.

When we want a mutable version, Rust has a second string type, ~String~. This
type manages data allocated on the heap and as such is able to store an amount
of text that is unknown to us at compile time. You can create a ~String~ from a
string literal using the ~from~ function and also modify the string:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`
}
#+END_SRC

Why can ~String~ be mutated but literals cannot? The difference is how these two
types deal with memory.

** Memory and allocation

In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.

With the ~String~ type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time, to
hold the contents. This means:

- The memory must be requested from the memory allocator at runtime.
- We need a way of returning this memory to the allocator when we’re done with
  our ~String~.

That first part is done by us: when we call ~String::from~, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.

However, the second part is different. In languages with a garbage collector,
the GC keeps track of and cleans up memory that isn’t being used anymore, and we
don’t need to think about it. In most languages without a GC, it’s our
responsibility to identify when memory is no longer being used and call code to
explicitly free it, just as we did to request it. Doing this correctly has
historically been a difficult programming problem. If we forget, we’ll waste
memory. If we do it too early, we’ll have an invalid variable. If we do it
twice, that’s a bug too. We need to pair exactly one ~allocate~ with exactly one
~free~.

Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. It's returned by Rust calling a special
function called ~drop~, and it’s where the author of an object type (e.g
~String~) can put the code to return the memory.

*** Move

Multiple variables can interact with the same data in different ways in Rust.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let mut y = x;
    println!("{}", x);
    println!("{}", y);
    y = 6;
    println!("{}", x);
    println!("{}", y);
}
#+END_SRC

This has the expected behaviour. The variables are simple values with a known,
fixed size and are stored on the stack and the value is simply copied.

What happends with ~String~s?

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    // Try to add back this line and it will fail
    //println!("{}", s1);
    println!("{}", s2);
}
#+END_SRC

A ~String~ is made up of three parts: a pointer to the memory that holds the
contents of the string, a length, and a capacity. This group of data is stored
on the stack (fixed length). The memory on the heap holds the contents.

When we assign ~s1~ to ~s2~, the ~String~ data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to.

So like in other programming languages both strings would be pointing to the
same data on the heap.

So when one of these variables goes out of scope, what would happen? To ensure
memory safety, after the line ~let s2 = s1~, Rust considers ~s1~ as no longer
valid. Therefore, Rust doesn’t need to free anything when ~s1~ goes out of
scope. So the example above will actually now compile!

So what is happening in the example above is not a shallow copy. Because the
first variable is invalidated this is instead known as a /move/.

*** Clone

If we instead would want to also copy the heap we could use the ~clone~ method.
E.g.:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s1 = String::from("hello");
    let mut s2 = s1.clone();
    println!("{}", s1);
    println!("{}", s2);
    s2.push_str(", world!");
    println!("{}", s1);
    println!("{}", s2);
}
#+END_SRC

This creates two independeny memory areas on the heap with different owners.

*** Stack-Only Data: Copy

Rust has a special annotation called the ~Copy~ trait that we can place on types
that are stored on the stack, as integers are. If a type implements the ~Copy~
trait, variables that use it do not /move/, but rather are trivially copied,
making them still valid after assignment to another variable.

Rust won’t let us annotate a type with ~Copy~ if the type, or any of its parts,
has implemented the ~Drop~ trait. If the type needs something special to happen
when the value goes out of scope and we add the ~Copy~ annotation to that type,
we’ll get a compile-time error.

As a general rule, any group of simple scalar values can implement ~Copy~, and
nothing that requires allocation or is some form of resource can implement
~Copy~. Here are some of the types that implement ~Copy~:


- All the integer types.
- The Boolean type
- All the floating point types
- The character type
- Tuples, if they only contain types that also implement ~Copy~. For example,
  ~(i32, i32)~ implements ~Copy~, but ~(i32, String)~ does not.

** Ownership and functions

The mechanics of passing a value to a function are similar to those when
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does.

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...

    //println!("{}", s);            // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward
    println!("{}", x);

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
#+END_SRC

** Return Values and Scope

Returning values can also transfer ownership.

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3

    let mut s4 = String::from("hello"); // The following also works
    s4 = takes_and_gives_back(s4);
} // Here, s3 and s4 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
#+END_SRC

While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but not
take ownership? It’s quite annoying that anything we pass in also needs to be
passed back if we want to use it again, in addition to any data resulting from
the body of the function that we might want to return as well.

** References and Borrowing

A ~reference~ is like a pointer in that it’s an address we can follow to access
the data stored at that address; that data is owned by some other variable.
Unlike a pointer, a reference is guaranteed to point to a valid value of a
particular type for the life of that reference.

Here is how you would define and use a ~calculate_length~ function that has a
reference to an object as a parameter instead of taking ownership of the value:

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, it is not dropped.
#+END_SRC

Note that we pass ~&s1~ into ~calculate_length~ and, in its definition, we take
~&String~ rather than ~String~. These ampersands represent references, and they
allow you to refer to some value without taking ownership of it.

The ~&s1~ syntax lets us create a reference that refers to the value of ~s1~ but
does not own it. Because it does not own it, the value it points to will not be
dropped when the reference stops being used.

When functions have references as parameters instead of the actual values, we
won’t need to return the values in order to give back ownership, because we
never had ownership.

We call the action of creating a reference ~borrowing~. When you’re done, you
have to give it back. You don’t own it.

Just as variables are immutable by default, so are references. We’re not allowed
to modify something we have a reference to. The following code won't compile:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+END_SRC

*** Mutable references

We can fix the code from above to allow us to modify a borrowed value with just
a few small tweaks that use, instead, a ~mutable reference~:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello"); // change s to be mut

    change(&mut s); // create a mutable reference

    println!("{}", s);
}

fn change(some_string: &mut String) { // Change to accept a mutable reference wiht &mut
    some_string.push_str(", world");
}
#+END_SRC

The updated function signature will make it very clear that the change function
will mutate the value it borrows.

Mutable references have one big restriction: if you have a mutable reference to
a value, you can have no other references to that value. This code that attempts
to create two mutable references to ~s~ will fail:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}
#+END_SRC

The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It’s something
that new Rustaceans struggle with, because most languages let you mutate
whenever you’d like. The benefit of having this restriction is that Rust can
prevent data races at compile time. A data race is similar to a race condition
and happens when these three behaviors occur:

- Two or more pointers access the same data at the same time.
- At least one of the pointers is being used to write to the data.
- There’s no mechanism being used to synchronize access to the data.

Rust enforces a similar rule for combining mutable and immutable references.
This code results in an error:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
}
#+END_SRC

Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references, the ~println!~,
occurs before the mutable reference is introduced:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // variables r1 and r2 will not be used after this point
    // and the scope for those variables ends here

    let r3 = &mut s; // no problem
    println!("{}", r3);
}
#+END_SRC

*** Dangling references

A dangling pointer is a pointer that references a location in memory that may
have been given to someone else by freeing some memory while preserving a
pointer to that memory. In Rust, by contrast, the compiler guarantees that
references will never be dangling references: if you have a reference to some
data, the compiler will ensure that the data will not go out of scope before the
reference to the data does.

#+BEGIN_SRC rust :results output
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
#+END_SRC

Because ~s~ is created inside dangle, when the code of dangle is finished, ~s~
will be deallocated. But we tried to return a reference to it. That means this
reference would be pointing to an invalid ~String~. Rust won’t let us do this.
Instead we could return ~s~ which would also transfer ownership.

*** The Rules of References

Let’s recap what we’ve discussed about references:

- At any given time, you can have either one mutable reference or any number of
  immutable references.
- References must always be valid.

** The slice type

/Slices/ let you reference a contiguous sequence of elements in a collection
rather than the whole collection. A slice is a kind of reference, so it does not
have ownership.

*** String slices

A string slice is a reference to part of a ~String~, and it looks like this:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
    println!("{}", hello);
    println!("{}", world);
}
#+END_SRC

We create slices using a range within brackets by specifying
~[starting_index..ending_index]~. ~starting_index~ is inclusive and
~ending_index~ is exclusive. Internally, the slice data structure stores a
pointer to the starting position and the length of the slice.

With Rust’s ~..~ range syntax, if you want to start at index zero, you can drop
the value before the two periods and if your slice includes the last index, you
can drop the trailing number.

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");

    let len = s.len();

    let start0 = &s[0..2];
    let start1 = &s[..2];

    let end0 = &s[5..len];
    let end1 = &s[5..];

    let full0 = &s[0..len];
    let full1 = &s[..];
}
#+END_SRC

Here's an example to get the first word of a ~String~:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");
    let fw = first_word(&s);
    println!("{}", fw);
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

This example includes an iteration which there will be more about later (TODO).

What if we try to modify the ~String~ which the slice is referencing?

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello world");
    let fw = first_word(&s);
    s.clear();
    println!("{}", fw);
    //s.clear(); // This clear would work since the immutable reference is out of scope
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

It won't compile! Recall from the borrowing rules that if we have an immutable
reference (e.g. a slice) to something, we cannot also take a mutable reference.
Because ~clear~ needs to truncate the ~String~, it needs to get a mutable
reference. The ~println!~ after the call to ~clear~ uses the reference in ~fw~,
so the immutable reference must still be active at that point.

*** String literals are slices

#+BEGIN_SRC rust :noeval
let s = "Hello, world!";
#+END_SRC

The type of ~s~ here is ~&str~: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; ~&str~ is an
immutable reference.

*** String slices as parameters

Knowing that you can take slices of literals and ~String~ values leads us to one
more improvement on ~first_word~, and that’s its signature:

#+BEGIN_SRC rust :noeval
fn first_word(s: &String) -> &str {
// Becomes
fn first_word(s: &str) -> &str {
#+END_SRC

This allows us to use the same function on both ~&String~ values and ~&str~
values. Defining a function to take a string slice instead of a reference to a
~String~ makes our API more general and useful without losing any functionality:

#+BEGIN_SRC rust :results output
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

*** Other slices

There’s a more general slice type, too. Consider this array:

#+BEGIN_SRC rust :noeval
let a = [1, 2, 3, 4, 5];
#+END_SRC

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3];
    assert_eq!(slice, &[2, 3]);
}
#+END_SRC

This slice has the type ~&[i32]~. It works the same way as string slices do, by
storing a reference to the first element and a length.

* Structs

Structs are similar to [[*The Tuple Type][tuples]], in that both hold multiple related values but in
a struct you’ll name each piece of data so it’s clear what the values mean.

To define a struct, we enter the keyword ~struct~ and name the entire struct.
Then, inside curly brackets, we define the /fields/. We define an /instance/ of
the struct in the following way (we don’t have to specify the fields in the same
order in which we declared them in the struct):

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
}
#+END_SRC

To get a specific value from a struct, we use dot notation. If the instance is
mutable, we can change a value by using the dot notation and assigning into a
particular field.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
#+END_SRC

Rust doesn’t allow us to mark only certain fields as mutable, so the instance
must be mutable. We can also construct a new instance of a struct as the last
expression of a function.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email: email, // Note the repetition!
        username: username, // Note the repetition!
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"));
}
#+END_SRC

The pattern above, that the parameter names and the struct field names are
exactly the same, we can use the /field init shorthand/ syntax to rewrite
~build_user~. Because the ~email~ field and the ~email~ parameter have the same
name, we only need to write ~email~ rather than ~email: email~.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email, // Repetition gone
        username, // Repetition gone
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"));
}
#+END_SRC

** Struct update syntax

It’s often useful to create a new instance of a struct that includes most of the
values from another instance, but changes some. You can do this using /struct
update syntax/. This how you would create a new instance with an updated ~email~
field without the syntax:

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
#+END_SRC

Using struct update syntax it would look like this (the result is the same
though).

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
#+END_SRC

The ~..user1~ must come last to specify that any remaining fields should get
their values from the corresponding fields in ~user1~, but we can choose to
specify values for as many fields as we want in any order, regardless of the
order of the fields in the struct’s definition.

Why is it called an update when we still use the ~=~ operator like assignments?
It's because we [[*Move][move]] the data. We can no longer use ~user1~ after creating
~user2~ because the ~String~ in the ~username~ field of ~user1~ was moved into
~user2~. If we had given ~user2~ new ~String~ values for both ~email~ and
~username~, and thus only used the ~active~ and ~sign_in_count~ values from
~user1~, then ~user1~ would still be valid after creating ~user2~. The types of
~active~ and ~sign_in_count~ are types that implement the ~Copy~ trait.

** Destruct tuples

Like a tuple you can destruct a struct.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
}

fn main() {
    let user1 = User {
        username: String::from("someusername123"),
        active: true,
    };

    let User {username: u, active: a} = user1;
}
#+END_SRC

If you don't care about some fields you can omit them and add ~..~ as a
"filler":

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
}

fn main() {
    let user1 = User {
        username: String::from("someusername123"),
        active: true,
    };

    let User {active: a, ..} = user1;
}
#+END_SRC

** Tuple structs

Rust also supports structs that look similar to tuples, called /tuple structs/.
They don’t have names associated with their fields; rather, they just have the
types of the fields. These are useful when you want to give the whole tuple a
name and make the tuple a different type from other tuples.

You define them as a regular ~struct~ but leave out the name of the fields:

#+BEGIN_SRC rust :results output
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
#+END_SRC

Note that the ~black~ and ~origin~ values are different types, because they’re
instances of different tuple structs. A function that takes a parameter of type
~Color~ cannot take a ~Point~ as an argument. If we used regular tuples we could
feed both ~black~ and ~origin~ the the same functions.

Otherwise, tuple struct instances are similar to tuples in that you can
destructure them into their individual pieces, and you can use a ~.~ followed by
the index to access an individual value. ~_~ can be used as a placeholder for
unused values when destructing a struct tuple:

#+BEGIN_SRC rust :results output
struct Color(i32, i32, i32);

fn main() {
    let c = Color(0, 1, 2);
    let Color(r, _, _) = c;
    println!("{}", r);
    println!("{}", c.1);
}
#+END_SRC

** Unit-like structs

You can also define structs that don’t have any fields. These are called
unit-like structs because they behave similarly to ~()~, the unit type.

#+BEGIN_SRC rust :results output
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
#+END_SRC

Unit-like structs can be useful when you need to implement a trait on some type
but don’t have any data that you want to store in the type itself. Traits will
be discussed later.

** Ownerships of struct data

In the examples above we have used the owned ~String~ type instead of the ~&str~
string slice type. This is a deliberate choice because we want each instance of
this struct to own all of its data and for that data to be valid for as long as
the entire struct is valid.

It’s also possible for structs to store references to data owned by something
else, but to do so requires the use of lifetimes (TODO).

** An example with structs

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let width = 30;
    let height = 50;
    let rect_tuple = (30, 50);
    let rect_struct = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_variables(width, height)
    );
    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_tuples(rect_tuple)
    );
    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_struct(&rect_struct)
    );
}

// Bad
fn area_with_variables(width: u32, height: u32) -> u32 {
    width * height
}

// Better
fn area_with_tuples(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}

// Best
fn area_with_struct(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
#+END_SRC

In the struct example we want to borrow the struct rather than take ownership of
it. This way, ~main~ retains its ownership and can continue using ~rect_struct~,
which is the reason we use the ~&~ in the function signature and where we call
the function. Note that accessing fields of a borrowed struct instance does not
move the field values, which is why you often see borrows of structs.

** Adding Useful Functionality with Derived Traits

We can't create a ~Rectangle~ directly:

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
#+END_SRC

The code above complains that the ~Display~ trait is not implemented for
~Rectangle~. It suggest to print with ~{:?}~ instead of ~{}~. Let's try that:

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
#+END_SRC

Now it complains that we don't have the ~Debug~ trait implemented. Instead of
manually implementing it we can derive it with ~#[derive(Debug)]~:

#+BEGIN_SRC rust :results output
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
    // Or
    println!("rect1 is {rect1:?}");
    // Or for pretty printing the debug output
    println!("rect1 is {rect1:#?}");
}
#+END_SRC

Another way to debug your code is with the ~dbg!~ macro. It takes ownership of
an expression (as opposed to ~println!~, which takes a reference), prints the
file and line number of where that ~dbg!~ macro call occurs in your code along
with the resultant value of that expression, and returns ownership of the value.

#+BEGIN_SRC rust :results output
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // The ownership is handed back so this is ok
        height: 50,
    };

    // Pass a reference since we don't handle the returned ownership here
    dbg!(&rect1);
}
#+END_SRC

The ~dbg!~ macro prints to ~stderr~ so executing this code in emacs will print
the log in the error output buffer.

** Methods

Rust allows structs, enums and traits to define methods and their first
parameter is always ~self~, which represents the instance of the struct the
method is being called on.

*** Defining methods

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
#+END_SRC

To define the function within the context of ~Rectangle~, we start an ~impl~
(implementation) block for ~Rectangle~. Everything within this ~impl~ block will
be associated with the ~Rectangle~ type.

In the signature for area, we use ~&self~ instead of ~rectangle: &Rectangle~ (as
in the example above). The ~&self~ is actually short for ~self: &Self~. Within
an ~impl~ block, the type ~Self~ is an alias for the type that the ~impl~ block
is for. Methods must have a parameter named ~self~ of type ~Self~ for their
first parameter, so Rust lets you abbreviate this with only the name ~self~ in
the first parameter spot. Note that we still need to use the ~&~ in front of the
self shorthand to indicate this method borrows the ~Self~ instance, just as we
did in ~rectangle: &Rectangle~. Methods can take ownership of ~self~, borrow
~self~ immutably as we’ve done here, or borrow ~self~ mutably, just as they can
any other parameter. If we wanted to change the instance that we’ve called the
method on as part of what the method does, we’d use ~&mut self~ as the first
parameter.

You are also allowed to give a method the same name as a structs fields. E.g.

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() { // The parentheses makes rust use the method and not the field
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
#+END_SRC

*** Automatic referencing and dereferencing

When you call a method with ~object.something()~, Rust automatically adds in
~&~, ~&mut~, or ~*~ so object matches the signature of the method. In other
words, the following are the same:

#+BEGIN_SRC rust :noeval
p1.distance(&p2);
(&p1).distance(&p2);
#+END_SRC

The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver — the type of ~self~.

*** Methods with more parameters

Working with more parameters works as one would expect

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn is_larger_than(&self, other: &Self) -> bool {
        self.area() > other.area()
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("rect1 is larger than rect2? {}", rect1.is_larger_than(&rect2));
    println!("rect1 is larger than rect3? {}", rect1.is_larger_than(&rect3));
}
#+END_SRC

*** Associated functions

All functions defined within an ~impl~ block are called /associated functions/
because they’re associated with the type named after the ~impl~. We can define
associated functions that don’t have ~self~ as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with.

Associated functions that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called ~new~, but
~new~ isn’t a special name and isn’t built into the language.

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let squared = Rectangle::square(3);
}
#+END_SRC

To call this associated function, we use the ~::~ syntax with the struct name.
This function is namespaced by the struct

*** Multiple ~impl~ blocks

Each struct is allowed to have multiple ~impl~ blocks. The following blocks are
equivalent. In this case, there’s no reason to separate these methods into
multiple ~impl~ blocks here, but this is valid syntax.

#+BEGIN_SRC rust :noeval
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+END_SRC

and

#+BEGIN_SRC rust :noeval
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+END_SRC

* Enums and pattern matching
** Defining an enum

To define am enum representing the different standards for IP addresses you
would define it like this:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}
#+END_SRC

~IpAddrKind~ is now a custom data type that we can use elsewhere in our code. We
can now create instances of each of the two variants of ~IpAddrKind~ and define
functions that takes any ~IpAddrKind~:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}

fn route(ip_kind: IpAddrKind) {}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(four);
    route(six);
}
#+END_SRC

To define the data associated with the enum you may be tempted to use enums in
combination with a struct, like this:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+END_SRC

But you can represent this using only enums. This new definition of the ~IpAddr~
enum says that both ~V4~ and ~V6~ variants will have associated ~String~ values:

#+BEGIN_SRC rust :results output
enum IpAddr {
    V4(String),
    V6(String)
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC

We attach data to each variant of the enum directly, so there is no need for an
extra struct (this is not possible in e.g. Java). Here it’s also easier to see
another detail of how enums work: the name of each enum variant that we define
also becomes a function that constructs an instance of the enum. That is,
~IpAddr::V4()~ is a function call that takes a ~String~ argument and returns an
instance of the ~IpAddr~ type. We automatically get this constructor function
defined as a result of defining the enum.

Each variant can have different types and amounts of associated data. If we
wanted to store ~V4~ addresses as four ~u8~ values but still express ~V6~
addresses as one ~String~ value, we wouldn’t be able to with a struct. Enums
handle this case with ease:

#+BEGIN_SRC rust :results output
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String)
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC

You can put any kind of data inside an enum variant: strings, numeric types,
structs, or another enum for example.

A more advanced example could look like this:

#+BEGIN_SRC rust :results output
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+END_SRC

This enum has four variants with different types:

- ~Quit~ has no data associated with it at all.
- ~Move~ has named fields like a struct does.
- ~Write~ includes a single ~String~.
- ~ChangeColor~ includes three ~i32~ values.

There is one more similarity between enums and structs: just as we’re able to
define methods on structs using ~impl~, we’re also able to define methods on
enums. Here’s a method named ~call~ that we could define on our ~Message~ enum:

#+BEGIN_SRC rust :results output
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+END_SRC

*** The ~Option~ enum

There is no ~null~ value in Rust, but it does have an enum that can encode the
concept of a value being present or absent. This enum is ~Option<T>~, and it is
[[https://doc.rust-lang.org/std/option/enum.Option.html][defined by the standard library]] library as follows:

#+BEGIN_SRC rust :results output
enum Option<T> {
    None,
    Some(T)
}
#+END_SRC

The ~Option<T>~ enum is so useful that it’s even included in the prelude. Its
variants are also included in the prelude: you can use ~Some~ and ~None~
directly without the ~Option::~ prefix. The ~Option<T>~ enum is still just a
regular enum, and ~Some(T)~ and ~None~ are still variants of type ~Option<T>~.

The ~<T>~ syntax is a generic type parameter. Here are some examples of using
~Option~ values to hold number types and string types:

#+BEGIN_SRC rust :results output
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
#+END_SRC

The type of ~some_number~ is ~Option<i32>~. The type of ~some_char~ is
~Option<char>~, which is a different type. Rust can infer these types because
we’ve specified a value inside the ~Some~ variant. For ~absent_number~, Rust
requires us to annotate the overall ~Option~ type: the compiler can’t infer the
type that the corresponding ~Some~ variant will hold by looking only at a ~None~
value.

~Option<T>~ is a different type than ~T~ so the following will fail:

#+BEGIN_SRC rust :results output
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;
#+END_SRC

When we have a value of a type like ~i8~ in Rust, the compiler will ensure that
we always have a valid value. We can proceed confidently without having to check
for ~null~ before using that value. Only when we have an ~Option<T>~ do we have
to worry about possibly not having a value, and the compiler will make sure we
handle that case before using the value. In other words, you have to convert an
~Option<T>~ to a ~T~ before you can perform ~T~ operations with it. This can be
done with the ~match~ expression (see below) or with the functions described in
[[https://doc.rust-lang.org/std/option/enum.Option.html][Option's documentation]].

** The ~match~ control flow construct

~match~ allows you to compare a value against a series of patterns and then
execute code based on which pattern matches. The power of ~match~ comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.

Here's an example:

#+BEGIN_SRC rust :results output
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10, // Try remove one option
        Coin::Quarter => 25,
    }
}

let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let penny_cents = value_in_cents(Coin::Penny);
println!("{}", penny_cents);
#+END_SRC

The different options in a ~match~ expression are called the ~match~ arms. An
arm has two parts: a pattern and some code. The first arm here has a pattern
that is the value ~Coin::Penny~ and then the ~=>~ operator that separates the
pattern and the code to run. The code in this case is just the value ~1~. Each
arm is separated from the next with a comma.

The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire ~match~ expression.

We don’t typically use curly brackets if the match arm code is short, but if you
want to run multiple lines of code in a ~match~ arm, you must use curly
brackets, and the comma following the arm is then optional. E.g.

#+BEGIN_SRC rust :results output
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let penny_cents = value_in_cents(Coin::Penny);
println!("{}", penny_cents);
#+END_SRC

*** Patterns that bind to values

~match~ can bind to the parts of the values that match the pattern. This is how
we can extract values out of enum variants.

Let's add a ~UsState~ enum to the ~Quarter~ variant of our ~Coin~ enum:

#+BEGIN_SRC rust :results output
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state); // We use the derive(Debug) functionality here
            25
        }
    }
}
let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let quarter_cents = value_in_cents(Coin::Quarter(UsState::Alaska));
println!("{}", quarter_cents)
#+END_SRC

*** Matching with ~Option<T>~

The concept above can also be applied to ~Option<T>~. E.g.

#+BEGIN_SRC rust :results output
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
println!("{:?}", five);
let six = plus_one(five);
println!("{:?}", six);
let none = plus_one(None);
println!("{:?}", none);
#+END_SRC

*** Matches are exhaustive

In a ~match~ statement all patterns must be covered, otherwise it won't compile.
E.g.

#+BEGIN_SRC rust :results output
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        //None => None,
        Some(i) => Some(i + 1),
    }
}
#+END_SRC

Try to run the code above and see that the compilation fails.

*** Catch-all patterns and the ~_~ placeholder

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        22..=30 => println!("A value between 20 and 30 (inclusive)"),
        other => println!("Just a {}...", other)
    }
}

print_number(3);
print_number(9);
print_number(7);
print_number(25);
#+END_SRC

The code above compile even though we haven't covered all possible values a ~u8~
can have. This is because the last pattern will match all values not
specifically listed (the variable may be named anything, not just ~other~).

If we don't care about the "catch all" value we can use ~_~. By using this, the
value won't be bound to ~_~ and Rust won't warn us about an unused variable.

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        _ => println!("Just another value...")
    }
}

print_number(3);
print_number(9);
print_number(7);
#+END_SRC

But what if we don't want to do anything in the catch all scenario? Just use the
/unit value/, ~()~ (discussed in [[*The Tuple Type][The Tuple Type]] section).

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        _ => ()
    }
}

print_number(3);
print_number(9);
print_number(7);
#+END_SRC

** Concise Control Flow with ~if let~

If you only care about one value it may feel unnecessary to write code like
this:

#+BEGIN_SRC rust :results output
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
#+END_SRC

To satisfy the ~match~ expression, we have to add ~_ => ()~ after processing
just one variant, which is annoying boilerplate code to add. Instead we can use
~if let~ when we only want to process one single variant:

#+BEGIN_SRC rust :results output
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
#+END_SRC

Using ~if let~ means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that ~match~ enforces.

In other words, you can think of ~if let~ as syntax sugar for a ~match~ that
runs code when the value matches one pattern and then ignores all other values.

It's also allowed to use ~else~ with ~if let~. The block of code that goes with
the ~else~ is the same as the block of code that would go with the ~_~ case in
the ~match~ expression that is equivalent to the ~if let~ and ~else~.

#+BEGIN_SRC rust :results output
//let config_max = Some(3u8);
let config_max: Option<u8> = None;
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
} else {
    println!("No maximum value is defined");
}
#+END_SRC

* Managing growing projects with packages, crates, and modules

Rust has a number of features that allow you to manage your code’s organization,
including which details are exposed, which details are private, and what names
are in each scope in your programs. These features, sometimes collectively
referred to as the module system, include:

- *Packages:* A Cargo feature that lets you build, test, and share crates
- *Crates:* A tree of modules that produces a library or executable
- *Modules* and *use:* Let you control the organization, scope, and privacy of
  paths
- *Paths:* A way of naming an item, such as a struct, function, or module

** Packages and crates

A /crate/ is the smallest amount of code that the Rust compiler considers at a
time. Even if you run ~rustc~ rather than ~cargo~ and pass a single source code
file, the compiler considers that file to be a crate. Crates can contain
modules, and the modules may be defined in other files that get compiled with
the crate.

A crate can come in one of two forms: a binary crate or a library crate. /Binary
crates/ are programs you can compile to an executable that you can run, such as
a command-line program or a server. Each must have a function called ~main~ that
defines what happens when the executable runs. All the crates we’ve created so
far have been binary crates.

/Library crates/ don’t have a ~main~ function, and they don’t compile to an
executable. Instead, they define functionality intended to be shared with
multiple projects. Most of the time when Rustaceans say “crate”, they mean
library crate, and they use “crate” interchangeably with the general programming
concept of a "library".

The /crate root/ is a source file that the Rust compiler starts from and makes
up the root module of your crate.

A /package/ is a bundle of one or more crates that provides a set of
functionality. A package contains a ~Cargo.toml~ file that describes how to
build those crates. ~cargo~ is actually a package that contains the binary crate
for the command-line tool you’ve been using to build your code. The ~cargo~
package also contains a library crate that the binary crate depends on. Other
projects can depend on the ~cargo~ library crate to use the same logic the
~cargo~ command-line tool uses.

A package can contain as many binary crates as you like, but at most only one
library crate. A package must contain at least one crate, whether that’s a
library or binary crate.

After we run ~cargo new my-project~, we use ~ls~ to see what Cargo creates. In
the project directory, there’s a ~Cargo.toml~ file, giving us a package. There’s
also a ~src~ directory that contains ~main.rs~. Open ~Cargo.toml~ in your text
editor, and note there’s no mention of ~src/main.rs~. Cargo follows a convention
that ~src/main.rs~ is the crate root of a binary crate with the same name as the
package. Likewise, Cargo knows that if the package directory contains
~src/lib.rs~, the package contains a library crate with the same name as the
package, and ~src/lib.rs~ is its crate root. Cargo passes the crate root files
to ~rustc~ to build the library or binary.

Here, we have a package that only contains ~src/main.rs~, meaning it only
contains a binary crate named ~my-project~. If a package contains ~src/main.rs~
and ~src/lib.rs~, it has two crates: a binary and a library, both with the same
name as the package. A package can have multiple binary crates by placing files
in the ~src/bin~ directory: each file will be a separate binary crate.

** Defining modules to control scope and privacy
*** Modules cheat sheet

Here we provide a quick reference on how modules, paths, the use keyword, and
the pub keyword work in the compiler, and how most developers organize their
code.

**** Start from the crate root

When compiling a crate, the compiler first looks in the crate root file (usually
~src/lib.rs~ for a library crate or ~src/main.rs~ for a binary crate) for code
to compile.

**** Declaring modules

In the crate root file, you can declare new modules; say, you declare a “garden”
module with ~mod garden;~. The compiler will look for the module’s code in these
places:

- Inline, within curly brackets that replace the semicolon following ~mod garden~
- In the file ~src/garden.rs~
- In the file ~src/garden/mod.rs~

**** Declaring submodules

In any file other than the crate root, you can declare submodules. For example,
you might declare ~mod vegetables;~ in ~src/garden.rs~. The compiler will look
for the submodule’s code within the directory named for the parent module in
these places:

- Inline, directly following ~mod vegetables~, within curly brackets instead of
  the semicolon
- In the file ~src/garden/vegetables.rs~
- In the file ~src/garden/vegetables/mod.rs~

**** Paths to code in modules

Once a module is part of your crate, you can refer to code in that module from
anywhere else in that same crate, as long as the privacy rules allow, using the
path to the code. For example, an ~Asparagus~ type in the garden vegetables
module would be found at ~crate::garden::vegetables::Asparagus~.

**** Private vs public

Code within a module is private from its parent modules by default. To make a
module public, declare it with ~pub mod~ instead of ~mod~. To make items within
a public module public as well, use ~pub~ before their declarations.

**** The use keyword

Within a scope, the ~use~ keyword creates shortcuts to items to reduce
repetition of long paths. In any scope that can refer to
~crate::garden::vegetables::Asparagus~, you can create a shortcut with
~use crate::garden::vegetables::Asparagus;~ and from then on you only need to
write ~Asparagus~ to make use of that type in the scope.

**** Example

Here we create a binary crate named ~backyard~ that illustrates these rules. The
crate’s directory, also named ~backyard~, contains these files and directories
(all code is located under [[file:004_modules/backyard][004_modules/backyard]]):

#+BEGIN_SRC
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
#+END_SRC

The crate root file in this case is ~src/main.rs~, and it contains:

#+BEGIN_SRC rust :noeval
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
#+END_SRC

The ~pub mod garden;~ line tells the compiler to include the code it finds in
~src/garden.rs~, which is:

#+BEGIN_SRC rust :noeval
pub mod vegetables;
#+END_SRC

Here, ~pub mod vegetables;~ means the code in ~src/garden/vegetables.rs~ is
included too. That code is:

#+BEGIN_SRC rust :noeval
#[derive(Debug)]
pub struct Asparagus {}
#+END_SRC

If you remove ~pub~ from ~pub mod garden;~ the module will be private for
~garden~ and you wouldn't be able to use it in the ~main.rs~ file. Same for
~pub struct Asparagus {}~.

*** Grouping related code in modules

/Modules/ let us organize code within a crate for readability and easy reuse.
Modules also allow us to control the /privacy/ of items, because code within a
module is private by default. We can choose to make modules and the items within
them public, which exposes them to allow external code to use and depend on
them.

we can organize its functions into nested modules. Create a new library named
~restaurant~ by running ~cargo new restaurant --lib~; then enter the code in
into ~src/lib.rs~ to define some modules and function signatures. Here’s the
front of house section:

#+BEGIN_SRC rust :noeval
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
#+END_SRC

We define a module with the ~mod~ keyword followed by the name of the module (in
this case, ~front_of_house~). The body of the module then goes inside curly
brackets. Inside modules, we can place other modules, as in this case with the
modules ~hosting~ and ~serving~. Modules can also hold definitions for other
items, such as structs, enums, constants, traits, and functions. By using
modules, we can group related definitions together and name why they’re related.

Earlier, we mentioned that ~src/main.rs~ and ~src/lib.rs~ are called /crate
roots/. The reason for their name is that the contents of either of these two
files form a module named ~crate~ at the root of the crate’s module structure,
known as the /module tree/.

#+BEGIN_SRC
crate
└── front_of_house
    ├── hosting
    │   ├── add_to_waitlist
    │   └── seat_at_table
    └── serving
        ├── take_order
        ├── serve_order
        └── take_payment
#+END_SRC

The tree above shows how some of the modules nest inside one another; for
example, ~hosting~ nests inside ~front_of_house~. The tree also shows that some
modules are siblings to each other, such as ~hosting~ and ~serving~. If module
~A~ is contained inside module ~B~, we say that module ~A~ is the /child/ of
module ~B~ and that module ~B~ is the /parent/ of module ~A~. Notice that the
entire module tree is rooted under the implicit module named ~crate~.

** Paths for referring to an item in the module tree

To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. To call a function, we need to
know its path.

A path can take two forms:

- An /absolute path/ is the full path starting from a crate root; for code from
  an external crate, the absolute path begins with the crate name, and for code
  from the current crate, it starts with the literal ~crate~.
- A /relative path/ starts from the current module and uses ~self~, ~super~, or
  an identifier in the current module.

Both absolute and relative paths are followed by one or more identifiers
separated by double colons (~::~). Example:

#+BEGIN_SRC rust :noeval
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+END_SRC

Note that the ~hosting~ module and ~add_to_waitlist~ are marked public. In Rust,
all items (functions, methods, structs, enums, modules, and constants) are
private to parent modules by default. If you want to make an item like a
function or struct private, you put it in a module.

Items in a parent module can’t use the private items inside child modules, but
items in child modules can use the items in their ancestor modules. This is
because child modules wrap and hide their implementation details, but the child
modules can see the context in which they’re defined.

*** Exposing paths with the ~pub~ keyword

As mentioned before, in Rust, all items (functions, methods, structs, enums,
modules, and constants) are private to parent modules by default. To make them
available for the parent module, you add the ~pub~ keyword.

When defining a module private (e.g. with ~mod hosting;~) the public items in
than module will be available to this module, but no parent modules. If you
define it with the ~pub~ keyword (~pub mod hosting;~) the public items in that
module will be available to this module and it's parent module (and that modules
parent if this module was declared public).

*** Starting relative paths with ~super~

We can construct relative paths that begin in the parent module, rather than the
current module or the crate root, by using ~super~ at the start of the path.
This is like starting a filesystem path with the ~..~ syntax.

#+BEGIN_SRC rust :noeval
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
#+END_SRC

The ~fix_incorrect_order~ function is in the ~back_of_house~ module, so we can
use ~super~ to go to the parent module of ~back_of_house~, which in this case is
~crate~, the root. From there, we look for ~deliver_order~ and find it.

*** Making structs and enums public

We can also use ~pub~ to designate structs and enums as public, but there are a
few details extra to the usage of ~pub~ with structs and enums. If we use ~pub~
before a struct definition, we make the struct public, but the struct’s fields
will still be private. We can make each field public or not on a case-by-case
basis.

#+BEGIN_SRC rust :results output
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
#+END_SRC

Because the ~toast~ field in the ~back_of_house::Breakfast~ struct is public, in
~eat_at_restaurant~ we can write and read to the ~toast~ field using dot
notation. Notice that we can’t use the ~seasonal_fruit~ field in
~eat_at_restaurant~ because ~seasonal_fruit~ is private.

Also, note that because ~back_of_house::Breakfast~ has a private field, the
struct needs to provide a public associated function that constructs an instance
of ~Breakfast~ (we’ve named it ~summer~ here). If ~Breakfast~ didn’t have such a
function, we couldn’t create an instance of ~Breakfast~ in ~eat_at_restaurant~
because we couldn’t set the value of the private ~seasonal_fruit~ field in
~eat_at_restaurant~.

In contrast, if we make an enum public, all of its variants are then public. We
only need the ~pub~ before the ~enum~ keyword.

#+BEGIN_SRC rust :results output
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
#+END_SRC

** Bringing paths into scope with the ~use~ keyword

Instead of writing out the full parths to use items in other modules we can use
use the ~use~ keyword to create a shortcut to a path, and then use the shorter
name everywhere else in the scope.

#+BEGIN_SRC rust :results output
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting; // Relative path but we could use the absolute path as well
//use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    // instead of
    //front_of_house::hosting::add_to_waitlist();
}
#+END_SRC

~hosting~ is now a valid name in this scope, just as though the ~hosting~ module
had been defined here. Note that ~use~ only creates the shortcut for the
particular scope in which the ~use~ occurs. The code block below moves the
~eat_at_restaurant~ function into a new child module named ~customer~, which is
then a different scope than the ~use~ statement, so the function body won’t
compile:

#+BEGIN_SRC rust :noeval
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
#+END_SRC

To fix this problem, move the ~use~ within the ~customer~ module too, or
reference the shortcut in the parent module with ~super::hosting~ within the
child ~customer~ module.

*** Creating idiomatic ~use~ paths

In the example above you could also specified the ~use~ path all the way down
to the function, like this:

#+BEGIN_SRC rust :results output
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting::add_to_waitlist;


pub fn eat_at_restaurant() {
    add_to_waitlist();
}
#+END_SRC

Although this accomplished the same task the former is the idiomatic way to
bring a function into scope with ~use~. Bringing the function’s parent module
into scope with ~use~ means we have to specify the parent module when calling
the function. Specifying the parent module when calling the function makes it
clear that the function isn’t locally defined while still minimizing repetition
of the full path.

On the other hand, when bringing in structs, enums, and other items with ~use~,
it’s idiomatic to specify the full path. E.g.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
#+END_SRC

*** Providing new names with the ~as~ keyword

In some cases you may try to bring two types of the same name with the ~use~
keyword. We can use the ~as~ keyword to give the type a new local name, or
/alias/.

#+BEGIN_SRC rust :noeval
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
#+END_SRC

In the second ~use~ statement, we chose the new name ~IoResult~ for the
~std::io::Result~ type, which won’t conflict with the ~Result~ from ~std::fmt~
that we’ve also brought into scope.

*** Re-exporting names with ~pub use~

When we bring a name into scope with the ~use~ keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that code’s scope, we can combine ~pub~
and ~use~. This technique is called /re-exporting/ because we’re bringing an
item into scope but also making that item available for others to bring into
their scope.

#+BEGIN_SRC rust :results output
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+END_SRC

Before this change, external code would have to call the ~add_to_waitlist~
function by using the path ~restaurant::front_of_house::hosting::add_to_waitlist()~.
Now that this ~pub use~ has re-exported the ~hosting~ module from the root
module, external code can now use the path ~restaurant::hosting::add_to_waitlist()~
instead.

With ~pub use~, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.

*** Using external packages

In the guessing game we developed earlier ([[file:002_guessing_game][002_guessing_game]]) we used an
external package called ~rand~ to get random numbers. To use ~rand~ in our
project, we added this line to ~Cargo.toml~:

#+BEGIN_SRC toml
rand = "0.8.5"
#+END_SRC

Adding ~rand~ as a dependency in ~Cargo.toml~ tells Cargo to download the ~rand~
package and any dependencies from [[crates.io]] and make ~rand~ available to our
project.

Then, to bring ~rand~ definitions into the scope of our package, we added a
~use~ line starting with the name of the crate, ~rand~, and listed the items we
wanted to bring into scope. In the code block below we bring the ~Rng~ trait
into scope and call the ~rand::thread_rng~ function:

#+BEGIN_SRC rust :noeval
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
#+END_SRC

Members of the Rust community have made many packages available at [[crates.io]],
and pulling any of them into your package involves these same steps: listing
them in your package’s ~Cargo.toml~ file and using ~use~ to bring items from
their crates into scope.

Note that the standard ~std~ library is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change ~Cargo.toml~ to include ~std~. But we do need to refer to
it with ~use~ to bring items from there into our package’s scope. For example,
with ~HashMap~ we would use this line:

#+BEGIN_SRC rust :results output
use std::collections::HashMap;
#+END_SRC

This is an absolute path starting with ~std~, the name of the standard library
crate.

*** Using nested paths to clean up large ~use~ lists

Instead of bringing multiple items into scope in multiple lines like this:

#+BEGIN_SRC rust :results output
use std::cmp::Ordering;
use std::io;
#+END_SRC

We can use nested paths to bring the same items into scope in one line. We do
this by specifying the common part of the path, followed by two colons, and then
curly brackets around a list of the parts of the paths that differ:

#+BEGIN_SRC rust :results output
use std::{cmp::Ordering, io};
#+END_SRC

We can use a nested path at any level in a path, which is useful when combining
two ~use~ statements that share a subpath. E.g.

#+BEGIN_SRC rust :results output
use std::io;
use std::io::Write;
#+END_SRC

The common part of these two paths is ~std::io~, and that’s the complete first
path. To merge these two paths into one ~use~ statement, we can use ~self~ in
the nested path:

#+BEGIN_SRC rust :results output
use std::io::{self, Write};
#+END_SRC

*** The glob operator

If we want to bring /all/ public items defined in a path into scope, we can
specify that path followed by the ~*~ glob operator:

#+BEGIN_SRC rust :results output
use std::collections::*;
#+END_SRC

** Separating modules into different files

When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.

Note that you only need to load a file using a ~mod~ declaration /once/ in your
module tree. Once the compiler knows the file is part of the project (and knows
where in the module tree the code resides because of where you’ve put the ~mod~
statement), other files in your project should refer to the loaded file’s code
using a path to where it was declared. In other words, ~mod~ is not an “include”
operation.

#+BEGIN_SRC rust :noeval
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+END_SRC

This single file has been divided into multiple files (one module per file) in
[[file:005_restaurant][005_restaurant]]. The files are structured like this:

#+BEGIN_SRC
restaurant
├── Cargo.toml
├── Cargo.lock
└── src
    ├── lib.rs
    ├── front_of_house.rs
    └── front_of_house
        └── hosting.rs
#+END_SRC

We’ve moved each module’s code to a separate file, and the module tree remains
the same. The function calls in ~eat_at_restaurant~ will work without any
modification, even though the definitions live in different files.

Note that the ~pub use crate::front_of_house::hosting~ statement in ~src/lib.rs~
also hasn’t changed. The ~mod~ keyword declares modules, and Rust looks in a
file with the same name as the module for the code that goes into that module.

*** Alternate file paths

For a module named ~front_of_house~ declared in the crate root, the compiler
will look for the module’s code in:

- ~src/front_of_house/hosting.rs~
- ~src/front_of_house/hosting/mod.rs~ (older style, still supported path)

For a module named ~hosting~ that is a submodule of ~front_of_house~, the
compiler will look for the module’s code in:

- ~src/front_of_house/hosting.rs~
- ~src/front_of_house/hosting/mod.rs~ (older style, still supported path)

If you use both styles for the same module, you’ll get a compiler error. Using a
mix of both styles for different modules in the same project is allowed, but
might be confusing for people navigating your project.

The main downside to the style that uses files named ~mod.rs~ is that your
project can end up with many files named ~mod.rs~, which can get confusing when
you have them open in your editor at the same time.

* Common collection

We won't mention all collections from the standard library in this section. But
unlike the built-in array and tuple types (that also can store multiple values),
the data these collections point to is stored on the heap, which means the
amount of data does not need to be known at compile time and can grow or shrink
as the program runs.

To learn about the other kinds of collections provided by the standard library,
see [[https://doc.rust-lang.org/std/collections/index.html][the documentation]].

** Vectors

The type ~Vec<T>~, also known as a /vector/, acts like an ~ArrayList<T>~ in
Java.

*** Creating a new vector

To create a new empty vector, we call the ~Vec::new~ function:

#+BEGIN_SRC rust :results output
let v: Vec<i32> = Vec::new();
#+END_SRC

Since we aren’t inserting any values into this vector, we added a type
annotation, otherwise Rust wouldn't know what kind of elements we intend to
store. In this case we’ve told Rust that the ~Vec<T>~ in ~v~ will hold elements
of the ~i32~ type.

You can also create a ~Vec<T>~ with initial values and Rust will infer the type
of value you want to store. Rust provides the ~vec!~ macro, which will create a
new vector that holds the values you give it.

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3];
#+END_SRC

The code block above creates a new ~Vec<i32>~ that holds the values ~1~, ~2~,
and ~3~. The integer type is ~i32~ because that’s the default integer type.

*** Updating a vector

To create a vector and then add elements to it, we can use the ~push~ method:

#+BEGIN_SRC rust :results output
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#+END_SRC

As with any variable, if we want to be able to change its value, we need to make
it mutable using the ~mut~ keyword. The numbers we place inside are all of type
~i32~, and Rust infers this from the data, so we don’t need the ~Vec<i32>~
annotation.

*** Reading elements of vectors

There are two ways to reference a value stored in a vector: via indexing or
using the ~get~ method.

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2]; // Type annotation not needed here
println!("The third element is {third}");

let third: i32 = v[2]; // This is allowed since i32 implements the Copy trait so ownership is not transferred
println!("The third element is {third}");

let third: Option<&i32> = v.get(2); // Type annotation not needed here
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
#+END_SRC

Using ~&~ and ~[]~ gives us a reference to the element at the index value. When
we use the ~get~ method with the index passed as an argument, we get an
~Option<&T>~ that we can use with ~match~.

The difference with using indexing or the ~get~ method is what happens when we
index outside the array (and the return type of course):

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3, 4, 5];
let _does_not_exist = &v[100];
#+END_SRC

The code above panics because it references a nonexistent element. This method
is best used when you want your program to crash if there’s an attempt to access
an element past the end of the vector.

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3, 4, 5];
let _does_not_exist = v.get(100);
#+END_SRC

When the ~get~ method is passed an index that is outside the vector, it returns
~None~ without panicking. Your code will have logic to handle having either
~Some(&element)~ or ~None~.

When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules to ensure this reference and any other references
to the contents of the vector remain valid. Recall the rule that states you
can’t have mutable and immutable references in the same scope.

#+BEGIN_SRC rust :results output
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6); // Code will work by placing this line last
println!("The first element is: {first}");
#+END_SRC

This code won't compile. We hold an immutable reference to the first element in
a vector and try to add an element to the end. It might look like it should
work: why should a reference to the first element care about changes at the end
of the vector? This error is due to the way vectors work: because vectors put
the values next to each other in memory, adding a new element onto the end of
the vector might require allocating new memory and copying the old elements to
the new space, if there isn’t enough room to put all the elements next to each
other where the vector is currently stored. In that case, the reference to the
first element would be pointing to deallocated memory. The borrowing rules
prevent programs from ending up in that situation.

*** Iterating over the values in a vector

To access each element in a vector in turn, we would iterate through all of the
elements rather than use indices to access one at a time. The code block below
shows how to use a ~for~ loop to get immutable references to each element in a
vector of ~i32~ values and print them.

#+BEGIN_SRC rust :results output
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
#+END_SRC

We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The example below adds ~50~ to
each element.

#+BEGIN_SRC rust :results output
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
for i in &v {
    println!("{i}");
}
#+END_SRC

To change the value that the mutable reference refers to, we have to use the ~*~
dereference operator to get to the value in ~i~ before we can use the ~+=~
operator.

*** Using an enum to store multiple types

Vectors can only store values that are the same type. Fortunately, the variants
of an enum are defined under the same enum type, so when we need one type to
represent elements of different types, we can define and use an enum. E.g.:

#+BEGIN_SRC rust :results output
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
#+END_SRC

Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. We
must also be explicit about what types are allowed in this vector. If Rust
allowed a vector to hold any type, there would be a chance that one or more of
the types would cause errors with the operations performed on the elements of
the vector. Using an enum plus a ~match~ expression means that Rust will ensure
at compile time that every possible case is handled.

*** Dropping a vector drops its elements

Like any other ~struct~, a vector is freed when it goes out of scope. When the
vector gets dropped, all of its contents are also dropped. The borrow checker
ensures that any references to contents of a vector are only used while the
vector itself is valid.

** Strings

Strings in Rust are more complicated than other languages for three reasons:

- Rust’s propensity for exposing possible errors
- Strings being a more complicated data structure than many programmers give
  them credit for, and
- UTF-8

We discuss strings in the context of collections because strings are implemented
as a collection of bytes, plus some methods to provide useful functionality when
those bytes are interpreted as text.

Rust has only one string type in the core language, which is the string slice
~str~ that is usually seen in its borrowed form ~&str~. String literals, for
example, are stored in the program’s binary and are therefore string slices.

The ~String~ type, which is provided by Rust’s standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. Both ~String~ and string slices are used heavily in Rust’s standard
library, and are both UTF-8 encoded.

*** Creating a new string

Many of the same operations available with ~Vec<T>~ are available with ~String~
as well, because ~String~ is actually implemented as a wrapper around a vector
of bytes with some extra guarantees, restrictions, and capabilities.

This is how you create an empty ~String~:

#+BEGIN_SRC rust :results output
let mut s = String::new();
#+END_SRC

We can load data into this mutable ~String~. Often, we have some initial data
that we want to start the string with. For that, we use the ~to_string~ method,
which is available on any type that implements the ~Display~ trait, as string
literals do.

#+BEGIN_SRC rust :results output
let data = "initial contents";
let s = data.to_string();
// the method also works on a literal directly:
let s = "initial contents".to_string();
#+END_SRC

We can also use the function ~String::from~ to create a ~String~ from a string
literal. This code is equivalent to using the ~to_string~ method:

#+BEGIN_SRC rust :results output
let s = String::from("initial contents");
#+END_SRC

Since strings are UTF-8 encoded we can include any properly encoded data in
them:

#+BEGIN_SRC rust :results output
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
#+END_SRC

*** Updating a string

We can grow a ~String~ by using the ~push_str~ method to append a string slice:

#+BEGIN_SRC rust :results output
let mut s = String::from("foo");
s.push_str("bar");
println!("{s}")
#+END_SRC

The ~push_str~ method takes a string slice because we don’t necessarily want to
take ownership of the parameter. So in the example below we can still use ~s2~
after the call to ~push_str~:

#+BEGIN_SRC rust :results output
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s1 is {s1}");
println!("s2 is {s2}");
#+END_SRC

To add a character instead of a string slice you can use the ~push~ method:

#+BEGIN_SRC rust :results output
let mut s = String::from("lo");
s.push('l');
println!("{s}")
#+END_SRC

**** Concatenation with the ~+~ operator or the ~format!~ macro

Often, you’ll want to combine two existing strings. One way to do so is to use
the ~+~ operator:

#+BEGIN_SRC rust :results output
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
println!("{s3}")
#+END_SRC

The reason ~s1~ is no longer valid after the addition, and the reason we used a
reference to ~s2~, has to do with the signature of the method that’s called when
we use the ~+~ operator. The ~+~ operator uses the ~add~ method, whose signature
looks something like this:

#+BEGIN_SRC rust :noeval
fn add(self, s: &str) -> String {
#+END_SRC

The reason why the code above works even though we called ~+~ with a ~&String~
instead of ~&str~ is that the compiler can /coerce/ the ~&String~ argument into
a ~&str~. Because ~add~ does not take ownership of the ~s~ parameter, ~s2~ will
still be a valid ~String~ after this operation.

If we need to concatenate multiple strings, the behavior of the ~+~ operator
gets unwieldy:

#+BEGIN_SRC rust :results output
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = s1 + "-" + &s2 + "-" + &s3;
println!("{s}");
println!("{s2}"); // Still valid
println!("{s3}"); // Still valid
#+END_SRC

For more complicated string combining, we can instead use the ~format!~ macro:

#+BEGIN_SRC rust :results output
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{s1}-{s2}-{s3}");
println!("{s}");
println!("{s1}"); // All variables still valid
println!("{s2}");
println!("{s3}");
#+END_SRC

The ~format!~ macro works like ~println!~, but instead of printing the output to
the screen, it returns a ~String~ with the contents. The ~format!~ macro uses
references so that this call doesn’t take ownership of any of its parameters.

*** Indexing into strings

If you try to access parts of a ~String~ using indexing syntax in Rust, you’ll
get an error:

#+BEGIN_SRC rust :results output
let s1 = String::from("hello");
let h = s1[0];
#+END_SRC

Because the way a ~String~ is represented internally (UTF-8 character) it's not
suitable to allow indexing.

Another reason Rust doesn’t allow us to index into a ~String~ to get a character
is that indexing operations are expected to always take constant time (O(1)).
But it isn’t possible to guarantee that performance with a ~String~, because
Rust would have to walk through the contents from the beginning to the index to
determine how many valid characters there were.

*** Slicing strings

You can slice a string like this:

#+BEGIN_SRC rust :results output
let hello = "Здравствуйте";
let s = &hello[0..4];
println!("{s}");
#+END_SRC

Note that only the 2 first characters was returned. That is because you index on
the bytes and in this case the first 2 characters are represented internally by
4 bytes.

If we were to try to slice only part of a character’s bytes with something like
~&hello[0..3]~, Rust would panic at runtime in the same way as if an invalid
index were accessed in a vector:

#+BEGIN_SRC rust :results output
let hello = "Здравствуйте";
let s = &hello[0..3];
println!("{s}");
#+END_SRC

You should use ranges to create string slices with caution, because doing so can
crash your program.

*** Iterating over a string

The best way to operate on pieces of strings is to be explicit about whether you
want characters or bytes. For individual Unicode scalar values, use the ~chars~
method. Calling ~chars~ on “Здр” separates out and returns three values of type
~char~, and you can iterate over the result to access each element:

#+BEGIN_SRC rust :results output
for c in "Здр".chars() {
    println!("{c}");
}
#+END_SRC

The ~bytes~ method returns each raw byte:

#+BEGIN_SRC rust :results output
for b in "Здр".bytes() {
    println!("{b}");
}
#+END_SRC

** Hash maps

The type ~HashMap<K, V>~ stores a mapping of keys of type ~K~ to values of type
~V~ using a hashing function, which determines how it places these keys and
values into memory.

*** Creating a new hash map

One way to create an empty hash map is using ~new~ and adding elements with
~insert~.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
#+END_SRC

Note that we need to first ~use~ the ~HashMap~ from the collections portion of
the standard library. It’s not included in the features brought into scope
automatically in the prelude.

Like vectors, hash maps are homogeneous: all of the keys must have the same type
as each other, and all of the values must have the same type.

*** Accessing values

We can get a value out of the hash map by providing its key to the ~get~ method:

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);

println!("{score}")
#+END_SRC

The ~get~ method returns an ~Option<&V>~; if there’s no value for that key in
the hash map, get will return ~None~. This program handles the ~Option~ by
calling ~copied~ to get an ~Option<i32>~ rather than an ~Option<&i32>~, then
~unwrap_or~ to set ~score~ to zero if ~scores~ doesn't have an entry for the
key.

We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a ~for~ loop:

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
#+END_SRC

*** Ownership

For types that implement the ~Copy~ trait, like ~i32~, the values are copied
into the hash map. For owned values like ~String~, the values will be moved and
the hash map will be the owner of those values.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
#+END_SRC

If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid.

*** Updating a hash map

When you want to change the data in a hash map, you have to decide how to handle
the case when a key already has a value assigned.

**** Overwriting a value

If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
#+END_SRC

**** Adding a key and value only if a key isn’t present

Hash maps have a special API called ~entry~ that takes the key you want to check
as a parameter. The return value of the ~entry~ method is an enum called ~Entry~
that represents a value that might or might not exist. Let’s say we want to
check whether the key for the ~Yellow~ team has a value associated with it. If
it doesn’t, we want to insert the value ~50~, and the same for the ~Blue~ team.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
#+END_SRC

The ~or_insert~ method on ~Entry~ is defined to return a mutable reference to
the value for the corresponding ~Entry~ key if that key exists, and if not,
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.

**** Updating a value based on the old value

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
#+END_SRC

The ~split_whitespace~ method returns an iterator over sub-slices, separated by
whitespace, of the value in ~text~. The ~or_insert~ method returns a mutable
reference (~&mut V~) to the value for the specified key. Here we store that
mutable reference in the ~count~ variable, so in order to assign to that value,
we must first dereference ~count~ using the asterisk (~*~). The mutable
reference goes out of scope at the end of the ~for~ loop, so all of these
changes are safe and allowed by the borrowing rules.

* Error handling

In many cases, Rust requires you to acknowledge the possibility of an error and
take some action before your code will compile. This requirement makes your
program more robust by ensuring that you’ll discover errors and handle them
appropriately before you’ve deployed your code to production.

Rust groups errors into two major categories: /recoverable/ and /unrecoverable/
errors.

** Unrecoverable Errors with ~panic!~


When a program panics it will print a failure message, unwind, clean up the
stack, and quit. Via an environment variable, you can also have Rust display the
call stack when a panic occurs to make it easier to track down the source of the
panic.

To make a program panic you can use the ~panic!~ macro

#+BEGIN_SRC rust :results output
fn main() {
    panic!("crash and burn");
}
#+END_SRC

*** Using a ~panic!~ backtrace

The following command will panic:

#+BEGIN_SRC rust :results output
fn main() {
    let v = vec![1, 2, 3];
    v[99];
}
#+END_SRC

The output will look something like this:

#+BEGIN_SRC
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', rust-src-f1BHax.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+END_SRC

It only reveals which line in our code that makes a call to a function that
panics. The next note line tells us that we can set the ~RUST_BACKTRACE~
environment variable to get a backtrace of exactly what happened to cause the
error. Then it will look something like this:

#+BEGIN_SRC
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:250:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/alloc/src/vec/mod.rs:2628:9
   6: panic::main                    <---- The project was named panic
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
#+END_SRC

In order to get backtraces with this information, debug symbols must be enabled.
Debug symbols are enabled by default when using ~cargo build~ or ~cargo run~
without the ~--release~ flag.

** Recoverable Errors with ~Result~

For recoverable errors we use the ~Result~ enum instead of causing the program
to panic.

#+BEGIN_SRC rust :results output
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+END_SRC

Because ~Result~ has the generic type parameters ~<T, E>~, we can use the
~Result~ type and the functions defined on it in many different situations where
the successful value and error value we want to return may differ.

The ~File::open~ function will return a ~Result<std::fs::File, std::io::Error>~:

#+BEGIN_SRC rust :results output
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
#+END_SRC

Like the ~Option~ enum, the ~Result~ enum and its variants have been brought
into scope by the prelude, so we don’t need to specify ~Result::~ before the
~Ok~ and ~Err~ variants in the match arms.

*** Matching on different errors

Sometimes we want to take different actions for different failure reasons. If
~File::open~ failed because the file doesn’t exist, we want to create the file
and return the handle to the new file. If ~File::open~ failed for any other
reason we still want the code to ~panic!~.

#+BEGIN_SRC rust :results output
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");
    // Try open a file with no read permissions to see what happens
    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
#+END_SRC

The type of the value that ~File::open~ returns inside the ~Err~ variant is
~io::Error~, which is a struct provided by the standard library. This struct has
a method ~kind~ that we can call to get an ~io::ErrorKind~ value.

**** Alternatives to using ~match~ with ~Result<T, E>~

You can also use closures (more about that later), which are used with many of
the methods defined on ~Result<T, E>~. Here’s another way to write the same
logic as shown in the previous example, this time using closures and the
~unwrap_or_else~ method:

#+BEGIN_SRC rust :results output
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
#+END_SRC

*** Getting the value or panic using ~unwrap~ and ~expect~

If the ~Result~ value is the ~Ok~ variant, ~unwrap~ will return the value inside
the ~Ok~. If the ~Result~ is the ~Err~ variant, ~unwrap~ will call the ~panic!~
macro for us.

#+BEGIN_SRC rust :results output
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
#+END_SRC

Similarly, the ~expect~ method lets us also choose the ~panic!~ error message.
Using ~expect~ instead of ~unwrap~ and providing good error messages can convey
your intent and make tracking down the source of a panic easier.

#+BEGIN_SRC rust :results output
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
#+END_SRC

*** Propagating errors

Instead of handling the error within the function itself, you can return the
error to the calling code.

#+BEGIN_SRC rust :noeval
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
#+END_SRC

If this function succeeds without any problems, the code that calls this
function will receive an ~Ok~ value that holds a ~String~ - the username that
this function read from the file. Both the ~File::open~ function and the
~read_to_string~ method has the error type ~io::Error~ which makes that type
suitable for our function as well. So in the code block above we can see that we
return errors early to the caller if anything fails. Remember that we don't need
to explicitly say ~return~ when the error is the last expression.

The code that calls this code will then handle getting either an ~Ok~ value that
contains a username or an ~Err~ value that contains an ~io::Error~.

**** A shortcut for propagating errors: the ~?~ operator

This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator ~?~ to make this easier.

Let's rewrite the previous code using the ~?~ operator:

#+BEGIN_SRC rust :noeval
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
#+END_SRC

The ~?~ placed after a ~Result~ value is defined to work in almost the same way
as the ~match~ expressions we defined to handle the ~Result~ values before. If
the value of the ~Result~ is an ~Ok~, the value inside the ~Ok~ will get
returned from this expression, and the program will continue. If the value is an
~Err~, the ~Err~ will be returned from the whole function as if we had used the
~return~ keyword so the error value gets propagated to the calling code.

There is a difference between what the ~match~ expression does and what the ~?~
operator does: error values that have the ~?~ operator called on them go through
the ~from~ function, defined in the ~From~ trait in the standard library, which
is used to convert values from one type into another. When the ~?~ operator
calls the ~from~ function, the error type received is converted into the error
type defined in the return type of the current function. This is useful when a
function returns one error type to represent all the ways a function might fail,
even if parts might fail for many different reasons.

For example, we could change the ~read_username_from_file~ function in to return
a custom error type named ~OurError~ that we define. If we also define
~impl From<io::Error> for OurError~ to construct an instance of ~OurError~ from
an ~io::Error~, then the ~?~ operator calls in the body of
~read_username_from_file~ will call ~from~ and convert the error types without
needing to add any more code to the function.

We could actually write an even shorter version of the code above by chaining
method calls immediately after the ~?~:

#+BEGIN_SRC rust :noeval
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
#+END_SRC

Since this is a fairly common operation to read a file into a ~String~, the
standard library provides the convenient ~fs::read_to_string~ function that
opens the file, creates a new ~String~, reads the contents of the file, puts the
contents into that ~String~, and returns it.

#+BEGIN_SRC rust :results output
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
#+END_SRC

**** Where the ~?~ operator can be used

The ~?~ operator can only be used in functions whose return type is compatible
with the value the ~?~ is used on. In addition to that it can only be used in a
function returning a ~Result~, ~Option~, or another type that implements
~FromResidual~.

The behavior of the ~?~ operator when called on an ~Option<T>~ is similar to its
behavior when called on a ~Result<T, E>~: if the value is ~None~, the ~None~
will be returned early from the function at that point. If the value is ~Some~,
the value inside the ~Some~ is the resulting value of the expression and the
function continues. E.g.:

#+BEGIN_SRC rust :noeval
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
#+END_SRC

This code takes the ~text~ string slice argument and calls the ~lines~ method on
it, which returns an iterator over the lines in the string. Because this
function wants to examine the first line, it calls ~next~ on the iterator to get
the first value from the iterator. If ~text~ is the empty string, this call to
~next~ will return ~None~, in which case we use ~?~ to stop and return ~None~
from ~last_char_of_first_line~. If ~text~ is not the empty string, ~next~ will
return a ~Some~ value containing a string slice of the first line in text.

The ~?~ extracts the string slice, and we can call ~chars~ on that string slice
to get an iterator of its characters. We’re interested in the last character in
this first line, so we call ~last~ to return the last item in the iterator. This
is an ~Option~ because it’s possible that the first line is the empty string,
for example if ~text~ starts with a blank line but has characters on other
lines. The ~?~ operator in the middle gives us a concise way to express this
logic, allowing us to implement the function in one line.

So far, all the ~main~ functions we’ve used return ~()~. There are restrictions
on what its return type can be for the programs to behave as expected. ~main~
can also return a ~Result<(), E>~. E.g.:

#+BEGIN_SRC rust :results output
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;
    Ok(())
}
#+END_SRC

The ~Box<dyn Error>~ type is a /trait object/, which we’ll talk more about
later. For now, you can read ~Box<dyn Error>~ to mean "any kind of error".
Using ~?~ on a ~Result~ value in a ~main~ function with the error type
~Box<dyn Error>~ is allowed, because it allows any ~Err~ value to be returned
early.

When a ~main~ function returns a ~Result<(), E>~, the executable will exit with
a value of ~0~ if ~main~ returns ~Ok(())~ and will exit with a nonzero value if
~main~ returns an ~Err~ value. The ~main~ function may return any types that
implement the ~std::process::Termination~ trait, which contains a function
~report~ that returns an ~ExitCode~.

** Which one to use

When code panics, there’s no way to recover. You could call ~panic!~ for any
error situation, whether there’s a possible way to recover or not, but then
you’re making the decision that a situation is unrecoverable on behalf of the
calling code.

* Generic types, traits, and lifetimes
** Generic data type
*** In function definitions

When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.

#+BEGIN_SRC rust :results output
//fn largest<T>(list: &[T]) -> &T { // This won't work as we need to be able to
                                    // compare the elements in the slice. We
                                    // must add that T must support the PartialOrd
                                    // trait. More about traits soon
fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+END_SRC

*** In struct definitions

We can also define structs to use a generic type parameter in one or more fields
using the ~<>~ syntax.

#+BEGIN_SRC rust :results output
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
#+END_SRC

Note that because we’ve used only one generic type to define ~Point<T>~, this
definition says that the ~Point<T>~ struct is generic over some type ~T~, and
the fields ~x~ and ~y~ are both that same type, whatever that type may be. To
define a ~Point~ struct where ~x~ and ~y~ are both generics but could have
different types, we can use multiple generic type parameters.

#+BEGIN_SRC rust :results output
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+END_SRC

*** In enum definitions

As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the ~Option<T>~ enum that the standard
library provides:

#+BEGIN_SRC rust :results output
enum Option<T> {
    Some(T),
    None,
}
#+END_SRC

Enums can use multiple generic types as well. The definition of the ~Result~
enum is one example:

#+BEGIN_SRC rust :results output
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+END_SRC

*** In method definitions

We can implement methods on structs and enums and use generic types in their
definitions, too.

#+BEGIN_SRC rust :results output
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
#+END_SRC

Here, we’ve defined a method named ~x~ on ~Point<T>~ that returns a reference to
the data in the field ~x~.

Note that we have to declare ~T~ just after ~impl~ so we can use ~T~ to specify
that we’re implementing methods on the type ~Point<T>~. By declaring ~T~ as a
generic type after ~impl~, Rust can identify that the type in the angle brackets
in ~Point~ is a generic type rather than a concrete type. We could have chosen a
different name for this generic parameter than the generic parameter declared in
the struct definition, but using the same name is conventional.

We can also specify constraints on generic types when defining methods on the
type. We could, for example, implement methods only on ~Point<f32>~ instances
rather than on ~Point<T>~ instances with any generic type. In the example below
we use the concrete type ~f32~, meaning we don’t declare any types after ~impl~.

#+BEGIN_SRC rust :results output
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// My own example to see if different types can have different implementations
// This works
impl Point<char> {
    fn distance_from_origin(&self) -> u8 {
        0
    }
}

fn main() {
    let integer_point = Point { x: 5, y: 10 };
    println!("integer_point.x = {}", integer_point.x());
    // The following is not valid as distance_from_origin is only defined for Point<f32>
    //println!("integer_point.distance_from_origin() = {}", integer_point.distance_from_origin());

    let float_point = Point { x: 5.0, y: 10.0 };
    println!("float_point.x = {}", float_point.x());
    println!("float_point.distance_from_origin() = {}", float_point.distance_from_origin());

    let char_point = Point { x: 'a', y: 'b' };
    println!("char_point.x = {}", char_point.x());
    println!("char_point.distance_from_origin() = {}", char_point.distance_from_origin());
}
#+END_SRC

Generic type parameters in a struct definition aren’t always the same as those
you use in that same struct’s method signatures. The example below uses the
generic types ~X1~ and ~Y1~ for the ~Point~ struct and ~X2~ and ~Y2~ for the
~mixup~ method signature to make the example clearer. The method creates a new
~Point~ instance with the ~x~ value from the ~self~ ~Point~ (of type ~X1~) and
the ~y~ value from the passed-in ~Point~ (of type ~Y2~).

#+BEGIN_SRC rust :results output
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+END_SRC

The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with ~impl~ and some are declared with the method
definition. Here, the generic parameters ~X1~ and ~Y1~ are declared after ~impl~
because they go with the struct definition. The generic parameters ~X2~ and ~Y2~
are declared after ~fn mixup~, because they’re only relevant to the method.

*** Performance of code using generics

Using generics won't make your code run any slower. The compiler does the
opposite of the steps we used to create the generic code: the compiler looks at
all the places where generic code is called and generates code for the concrete
types the generic code is called with.

Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand.

** Traits: defining shared behavior

Traits are similar to a feature often called /interfaces/ in other languages,
(such as Java) although with some differences.

*** Defining a trait

Let’s say we have multiple structs that hold various kinds and amounts of text:
a ~NewsArticle~ and a ~Tweet~. We want to make a media aggregator library crate
that can display summaries of data that might be stored in a ~NewsArticle~ or
~Tweet~ instance. To do this, we need a summary from each type, and we’ll
request that summary by calling a ~summarize~ method on an instance. This code
shows the definition of a public ~Summary~ trait that expresses this behavior.

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize(&self) -> String;
}
#+END_SRC

Here, we declare a trait using the ~trait~ keyword and then the trait’s name,
which is ~Summary~ in this case. We’ve also declared the trait as ~pub~ so that
crates depending on this crate can make use of this trait too. Inside the curly
brackets, we declare the method signatures that describe the behaviors of the
types that implement this trait.

After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide its
own custom behavior for the body of the method.

A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.

*** Implementing a trait on a type

The following code block shows how to implement the ~Summary~ trait for our
~NewsArticle~ and ~Tweet~ structs.

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
#+END_SRC

Implementing a trait on a type is similar to implementing regular methods. The
difference is that after ~impl~, we put the trait name we want to implement,
then use the ~for~ keyword, and then specify the name of the type we want to
implement the trait for. Within the ~impl~ block, we put the method signatures
that the trait definition has defined. Instead of adding a semicolon after each
signature, we use curly brackets and fill in the method body with the specific
behavior that we want the methods of the trait to have for the particular type.

To call the trait methods you have to bring the trait into scope as well as the
types. E.g.

#+BEGIN_SRC rust :noeval
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+END_SRC

Other crates can also bring the ~Summary~ trait into scope to implement
~Summary~ on their own types. One restriction to note is that we can implement a
trait on a type only if at least one of the trait or the type is local to our
crate. But we can’t implement external traits on external types. For example, we
can’t implement the ~Display~ trait on ~Vec<T>~ within our crate. Without the
rule, two crates could implement the same trait for the same type, and Rust
wouldn’t know which implementation to use.

*** Default implementations

In the code block below we specify a default string for the ~summarize~ method
of the ~Summary~ trait instead of only defining the method signature.

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+END_SRC

To use a default implementation to summarize instances of ~NewsArticle~, we
specify an empty ~impl~ block with ~impl Summary for NewsArticle {}~. The syntax
for overriding a default implementation is the same as the syntax for
implementing a trait method that doesn’t have a default implementation.

Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify a
small part of it. For example, we could define the ~Summary~ trait to have a
~summarize_author~ method whose implementation is required, and then define a
~summarize~ method that has a default implementation that calls the
~summarize_author~ method:

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
#+END_SRC

To use this version of ~Summary~, we only need to define ~summarize_author~ when
we implement the trait.

*** Traits as parameters

Let's define a ~notify~ function that calls the ~summarize~ method on its ~item~
parameter, which is of some type that implements the ~Summary~ trait. To do
this, we use the ~impl Trait~ syntax:

#+BEGIN_SRC rust :noeval
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+END_SRC

Instead of a concrete type for the ~item~ parameter, we specify the ~impl~
keyword and the trait name. This parameter accepts any type that implements the
specified trait.

**** Trait bound syntax

The ~impl Trait~ syntax works for straightforward cases but is actually syntax
sugar for a longer form known as a /trait bound/:

#+BEGIN_SRC rust :noeval
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+END_SRC

We place trait bounds with the declaration of the generic type parameter after a
colon and inside angle brackets.

We can have two parameters that implement ~Summary~. Doing so with the
~impl Trait~ syntax looks like this:

#+BEGIN_SRC rust :noeval
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
#+END_SRC

In this case ~item1~ and ~item2~ may be of different types as long as they both
implement the ~Summary~ trait. If we want to force both parameters to have the
same type, however, we must use a trait bound, like this:

#+BEGIN_SRC rust :noeval
pub fn notify<T: Summary>(item1: &T, item2: &T) {
#+END_SRC

In this case we define that ~item1~ and ~item2~ must be of the generic type ~T~
which will be a single type, hence ~item1~ and ~item2~ will be of the same type.

**** Specifying multiple trait bounds with the ~+~ syntax

We can also specify more than one trait bound. If we wanted ~notify~ to accept
an ~item~ that both implements the ~Display~ and ~Summary~ trait we can do that
the following way:

#+BEGIN_SRC rust :noeval
pub fn notify(item: &(impl Summary + Display)) {
#+END_SRC

This can also be done using the trait bound syntax:

#+BEGIN_SRC rust :results output
pub fn notify<T: Summary + Display>(item: &T) {
#+END_SRC

**** Clearer trait bounds with ~where~ clause

Rust has alternate syntax for specifying trait bounds inside a ~where~ clause
after the function signature. So instead of writing this:

#+BEGIN_SRC rust :noeval
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
#+END_SRC

you can write like this:

#+BEGIN_SRC rust :noeval
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
#+END_SRC

*** Returning types that implements traits

The ~impl Trait~ syntax can also be used for the return type

#+BEGIN_SRC rust :noeval
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
#+END_SRC

The function above returns some type that implements the ~Summary~ trait without
naming the concrete type. In this case, the function returns a ~Tweet~.

However, you can only use ~impl Trait~ if you’re returning a single type. For
example, a function that returns either a ~NewsArticle~ or a ~Tweet~ (based on
some condition) with the return type specified as ~impl Summary~ wouldn’t work.
This restriction exists due to how the ~impl Trait~ is implemented in compiler.

*** Using trait bounds to conditionally implement methods

By using a trait bound with an ~impl~ block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits.

#+BEGIN_SRC rust :results output
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

// Implemented for all Pairs
impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

// Only implemented for Pairs of Ts where T implements Display and PartialOrd
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
#+END_SRC

We can also conditionally implement a trait for any type that implements another
trait. Implementations of a trait on any type that satisfies the trait bounds
are called /blanket implementations/. For example, the standard library
implements the ~ToString~ trait on any type that implements the ~Display~ trait.
The ~impl~ block in the standard library looks similar to this code:

#+BEGIN_SRC rust :noeval
impl<T: Display> ToString for T {
    // --snip--
}
#+END_SRC

This means that we can call the ~to_string~ method defined by the ~ToString~
trait on any type that implements the ~Display~ trait. For example, we can turn
integers into their corresponding ~String~ values like this because integers
implement ~Display~:

#+BEGIN_SRC rust :results output
let s = 3.to_string();
#+END_SRC

** Validating References with Lifetimes

Lifetimes are another kind of generic that we’ve already been using. Rather than
ensuring that a type has the behavior we want, lifetimes ensure that references
are valid as long as we need them to be.

every reference in Rust has a lifetime, which is the scope for which that
reference is valid. Most of the time, lifetimes are implicit and inferred. But
sometimes we must annotate lifetimes when the lifetimes of references could be
related in a few different ways.

*** The Borrow Checker

The following code won't compile:

#+BEGIN_SRC rust :results output
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
#+END_SRC

You can clearly see the the scope (or lifetime) of ~x~ (~'b~) is smaller than
the scope of ~r~ (~'a~). And ~r~ is holding a reference to a ~x~ which is out of
scope when it's being referred to, meaning that r actually holds a dangling
reference. This is not allowed in Rust.

The following code fixes that:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
}                         // --+-------+
#+END_SRC

Here, ~x~ has the lifetime ~'b~, which in this case is larger than ~'a~. This
means ~r~ can reference ~x~ because Rust knows that the reference in ~r~ will
always be valid while ~x~ is valid.

*** Generic Lifetimes in Functions

We’ll write a function that returns the longer of two string slices. This
function will take two string slices and return a single string slice:

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

This code looks correct but won't compile. The error text reveals that the
return type needs a generic lifetime parameter on it because Rust can’t tell
whether the reference being returned refers to ~x~ or ~y~ (and we don't know
that in the general case either).

Basically the borrow checker don't know how the lifetime of ~x~ and ~y~ relate
to the lifetime of the return value. The returned value can only live as long as
the value it is referencing.

*** Lifetime Annotation Syntax

Lifetime annotations don’t change how long any of the references live. Rather,
they describe the relationships of the lifetimes of multiple references to each
other without affecting the lifetimes. I see them as part of the contract of the
function.

The names of lifetime parameters must start with an apostrophe (~'~) and are
usually all lowercase and very short, like generic types. Most people use the
name ~'a~ for the first lifetime annotation. We place lifetime parameter
annotations after the ~&~ of a reference, using a space to separate the
annotation from the reference’s type. E.g.:

#+BEGIN_SRC rust :noeval
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
#+END_SRC

One lifetime annotation by itself doesn’t have much meaning because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other.

*** Lifetime Annotations in Function Signatures

To use lifetime annotations in function signatures, we need to declare the
generic /lifetime/ parameters inside angle brackets between the function name
and the parameter list, just as we did with generic /type/ parameters (after all
lifetime annotations is a type of generics).

The following code will compile and the lifetime parameter ~'a~ expresses the
following constraint: the returned reference will be valid as long as both the
parameters are valid.

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints.

In the example above both ~string1~ and ~string2~ scope ends after the
~println!~ expression so the program is valid. The following program is also
valid:

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

~string1~ has a larger lifetime but both lifetimes are still valid when the
~result~ variable is printed.

The following program is not valid though:

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

Even though as humans can see that ~string1~ is longer and is still valid at the
point where ~result~ is printed it still breaks the contract saying that the
lifetime of the reference returned by the ~longest~ function is the same as the
smaller of the lifetimes of the references passed in.

*** Thinking in Terms of Lifetimes

If we changed the implementation of the ~longest~ function to always return the
first parameter rather than the longest string slice, we wouldn’t need to
specify a lifetime on the ~y~ parameter.

When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does not refer to one of the parameters, it must refer to
a value created within this function. However, this would be a dangling
reference because the value will go out of scope at the end of the function.
This is not allowed in Rust. One way to fix that would be to return an owned
data type rather than a reference so the calling function is then responsible
for cleaning up the value.

*** Lifetime Annotations in Struct Definitions

We can define structs to hold references, but in that case we would need to add
a lifetime annotation on every reference in the struct’s definition. E.g:

#+BEGIN_SRC rust :results output
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
#+END_SRC

As with generic data types, we declare the name of the generic lifetime
parameter inside angle brackets after the name of the struct so we can use the
lifetime parameter in the body of the struct definition. This annotation means
an instance of ~ImportantExcerpt~ can’t outlive the reference it holds in its
~part~ field.

In the example above the ~ImportantExcerpt~ struct that holds a reference to the
first sentence of the ~String~ owned by the variable ~novel~. ~novel~ doesn’t go
out of scope until after the ~ImportantExcerpt~ goes out of scope, so the
reference in the ~ImportantExcerpt~ instance is valid.

*** Lifetime Elision

How come the following program works even though we haven't defined any explicit
lifetimes?

#+BEGIN_SRC rust :results output
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

fn main() {
    let s = String::from("Hello world");
    let fw = first_word(&s);
    println!("{}", fw)
}
#+END_SRC

We could expect that the proper signature would look like this:

#+BEGIN_SRC rust :noeval
fn first_word<'a>(s: &'a str) -> &'a str {
#+END_SRC

This was the case in very early versions of Rust but some patterns have been
found to be predictable so this can be added automatically. These patterns are
known as /lifetime elision rules/ and they’re a set of particular cases that the
compiler will consider, and if your code fits these cases, you don’t need to
write the lifetimes explicitly. If there is still ambiguity as to what lifetimes
the references have after Rust applies the rules, the compiler will give you an
error that you can resolve by adding the lifetime annotations.

Lifetimes on function or method parameters are called /input lifetimes/, and
lifetimes on return values are called /output lifetimes/.

The compiler uses three rules to figure out the lifetimes of the references when
there aren’t explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it can’t
figure out lifetimes, the compiler will stop with an error. These rules apply to
~fn~ definitions as well as ~impl~ blocks. The rules are:

- The compiler assigns a lifetime parameter to each parameter that’s a
  reference. In other words, a function with one parameter gets one lifetime
  parameter: ~fn foo<'a>(x: &'a i32);~ a function with two parameters gets two
  separate lifetime parameters: ~fn foo<'a, 'b>(x: &'a i32, y: &'b i32);~ and so
  on.
- If there is exactly one input lifetime parameter, that lifetime is assigned to
  all output lifetime parameters: ~fn foo<'a>(x: &'a i32) -> &'a i32~.
- If there are multiple input lifetime parameters, but one of them is ~&self~ or
  ~&mut self~ because this is a method, the lifetime of ~self~ is assigned to
  all output lifetime parameters. This third rule makes methods much nicer to
  read and write because fewer symbols are necessary.

E.g.:

#+BEGIN_SRC rust :noeval
fn first_word(s: &str) -> &str {
#+END_SRC

Apply rule 1 and 2 and we get:

#+BEGIN_SRC rust :noeval
fn first_word<'a>(s: &'a str) -> &'a str {
#+END_SRC

Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.

Another example:

#+BEGIN_SRC rust :noeval
fn first_word(s: &str) -> &str {
#+END_SRC

We can apply rule 1 but rule 2 and 3 can't be applied so it becomes:

#+BEGIN_SRC rust :noeval
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
#+END_SRC

After working through all three rules, we still haven’t figured out what the
return type’s lifetime is. The compilation will fail and you will have to
provide lifetime annotations yourself.

*** Lifetime Annotations in Method Definitions

When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters.  Where we declare and use the lifetime
parameters depends on whether they’re related to the struct fields or the method
parameters and return values.

Lifetime names for struct fields always need to be declared after the ~impl~
keyword and then used after the struct’s name because those lifetimes are part
of the struct’s type.

#+BEGIN_SRC rust :results output
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
#+END_SRC

The lifetime parameter declaration after ~impl~ and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to ~self~ because of the first elision rule.

Here is an example where the third lifetime elision rule applies:

#+BEGIN_SRC rust :results output
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
#+END_SRC

There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both ~&self~ and ~announcement~ their own lifetimes. Then, because one
of the parameters is ~&self~, the return type gets the lifetime of ~&self~, and
all lifetimes have been accounted for.

* Debug

https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits

* Crates and dependencies

When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the registry, which is a copy of data from
[[https://crates.io/]]. crates.io is where people in the Rust ecosystem post their
open source Rust projects for others to use.

* Documentation

Another neat feature of Cargo is that you can run the command below, which will
build documentation provided by all of your dependencies locally and open it in
your browser.

#+BEGIN_SRC bash :noeval
cargo doc --open
#+END_SRC

* Style guide

https://doc.rust-lang.org/1.0.0/style/style/naming/README.html

* Clippy

https://doc.rust-lang.org/clippy/

* Misc

Can a immutable var become mutable? Write an example where a function returns
a ~String~ and assign it to both mutable and immutable variables.

** Test: Is an array slice and a vector slice the same?

#+BEGIN_SRC rust :results output
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}

fn main() {
    let a = [1, 2, 3, 4, 5];
    let v = vec![1, 2, 3, 4, 5];
    print_type_of(&a);
    print_type_of(&v);
    let a_slice = &a[1..3];
    let v_slice = &v[1..3];
    print_type_of(&a_slice);
    print_type_of(&v_slice);
}
#+END_SRC

#+BEGIN_SRC rust :results output
fn print_array(a: &[i32; 3]) {
    for e in a {
        println!("Array element: {e}");
    }
}

fn print_vector(v: &Vec<i32>) {
    for e in v {
        println!("Vector element: {e}");
    }
}

fn print_slice(s: &[i32]) {
    for e in s {
        println!("Slice element: {e}");
    }
}

fn main() {
    let a = [1, 2, 3];
    let v = vec![1, 2, 3];
    print_array(&a);
    //print_array(&v);
    print_vector(&v);
    //print_vector(&a);
    print_slice(&a);
    print_slice(&v);
}
#+END_SRC

Conclusion: Yes, it looks like the slices are treated the same.

** Test: Iterating over arrays and vectors

#+BEGIN_SRC rust :results output
fn main() {
    let v = vec![1, 2, 3];
    //for e in &v { // This will work
    for e in v {
        println!("Slice element: {e}");
    }
    for e in v {
        println!("Slice element: {e}");
    }
}
#+END_SRC

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3];
    for e in a {
        println!("Slice element: {e}");
    }
    for e in a {
        println!("Slice element: {e}");
    }
}
#+END_SRC

Why does the lower example work even though we don't use borrowing? Something
with the ~Copy~ trait?

* Questions

- Can I create an ~impl~ block for an object not defined by me?
- How does lifetimes work with methods? Comparing self with other and return a field from one of them?
- What is the static lifetime?
