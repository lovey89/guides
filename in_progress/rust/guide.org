* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#links][Links]]
  - [[#tutorials][Tutorials]]
  - [[#cargo][Cargo]]
  - [[#api][API]]
- [[#other-things-to-look-at][Other things to look at]]
- [[#getting-started][Getting started]]
  - [[#installation][Installation]]
  - [[#hello-world][Hello, World]]
  - [[#hello-cargo][Hello, Cargo]]
- [[#guessing-game][Guessing game]]
- [[#common-programming-concepts][Common Programming Concepts]]
  - [[#variable-and-mutability][Variable and Mutability]]
  - [[#data-types][Data Types]]
  - [[#functions][Functions]]
  - [[#comments][Comments]]
  - [[#control-flow][Control Flow]]
- [[#ownership][Ownership]]
  - [[#ownership-rules][Ownership rules]]
  - [[#the-string-type][The ~String~ type]]
  - [[#memory-and-allocation][Memory and allocation]]
  - [[#ownership-and-functions][Ownership and functions]]
  - [[#return-values-and-scope][Return Values and Scope]]
  - [[#references-and-borrowing][References and Borrowing]]
  - [[#the-slice-type][The slice type]]
- [[#structs][Structs]]
  - [[#struct-update-syntax][Struct update syntax]]
  - [[#destruct-tuples][Destruct tuples]]
  - [[#tuple-structs][Tuple structs]]
  - [[#unit-like-structs][Unit-like structs]]
  - [[#ownerships-of-struct-data][Ownerships of struct data]]
  - [[#an-example-with-structs][An example with structs]]
  - [[#adding-useful-functionality-with-derived-traits][Adding Useful Functionality with Derived Traits]]
  - [[#methods][Methods]]
- [[#enums-and-pattern-matching][Enums and pattern matching]]
  - [[#defining-an-enum][Defining an enum]]
  - [[#the-match-control-flow-construct][The ~match~ control flow construct]]
  - [[#concise-control-flow-with-if-let][Concise Control Flow with ~if let~]]
- [[#managing-growing-projects-with-packages-crates-and-modules][Managing growing projects with packages, crates, and modules]]
  - [[#packages-and-crates][Packages and crates]]
  - [[#defining-modules-to-control-scope-and-privacy][Defining modules to control scope and privacy]]
  - [[#paths-for-referring-to-an-item-in-the-module-tree][Paths for referring to an item in the module tree]]
  - [[#bringing-paths-into-scope-with-the-use-keyword][Bringing paths into scope with the ~use~ keyword]]
  - [[#separating-modules-into-different-files][Separating modules into different files]]
- [[#common-collection][Common collection]]
  - [[#vectors][Vectors]]
  - [[#strings][Strings]]
  - [[#hash-maps][Hash maps]]
- [[#error-handling][Error handling]]
  - [[#unrecoverable-errors-with-panic][Unrecoverable Errors with ~panic!~]]
  - [[#recoverable-errors-with-result][Recoverable Errors with ~Result~]]
  - [[#which-one-to-use][Which one to use]]
- [[#generic-types-traits-and-lifetimes][Generic types, traits, and lifetimes]]
  - [[#generic-data-type][Generic data type]]
  - [[#traits-defining-shared-behavior][Traits: defining shared behavior]]
  - [[#validating-references-with-lifetimes][Validating References with Lifetimes]]
- [[#writing-automated-tests][Writing Automated Tests]]
  - [[#how-to-write-tests][How to Write Tests]]
  - [[#controlling-how-tests-are-run][Controlling how tests are run]]
  - [[#test-organization][Test Organization]]
- [[#an-io-project-building-a-command-line-program][An I/O Project: Building a Command Line Program]]
  - [[#accepting-command-line-arguments][Accepting Command Line Arguments]]
  - [[#reading-a-file][Reading a File]]
  - [[#refactoring-to-improve-modularity-and-error-handling][Refactoring to Improve Modularity and Error Handling]]
  - [[#writing-the-search-function][Writing the ~search~ function]]
  - [[#working-with-environment-variables][Working with Environment Variables]]
  - [[#writing-error-messages-to-standard-error-instead-of-standard-output][Writing Error Messages to Standard Error Instead of Standard Output]]
- [[#functional-language-features-iterators-and-closures][Functional Language Features: Iterators and Closures]]
  - [[#closures-anonymous-functions-that-capture-their-environment][Closures: Anonymous Functions that Capture Their Environment]]
  - [[#processing-a-series-of-items-with-iterators][Processing a Series of Items with Iterators]]
  - [[#improving-minigrep][Improving ~minigrep~]]
  - [[#a-comment-about-performance-between-loops-vs-iterators][A comment about performance between loops vs iterators]]
- [[#more-about-cargo-and-cratesio][More About Cargo and Crates.io]]
  - [[#customizing-builds-with-release-profiles][Customizing Builds with Release Profiles]]
  - [[#improving-a-crate-before-publishing-to-cratesio][Improving a Crate before Publishing to Crates.io]]
  - [[#cargo-workspaces][Cargo Workspaces]]
  - [[#installing-binaries-with-cargo-install][Installing Binaries with ~cargo install~]]
  - [[#extending-cargo-with-custom-commands][Extending Cargo with Custom Commands]]
- [[#smart-pointers][Smart Pointers]]
  - [[#using-boxt-to-point-to-data-on-the-heap][Using ~Box<T>~ to Point to Data on the Heap]]
  - [[#treating-smart-pointers-like-regular-references-with-the-deref-trait][Treating Smart Pointers Like Regular References with the ~Deref~ Trait]]
  - [[#running-code-on-cleanup-with-the-drop-trait][Running Code on Cleanup with the ~Drop~ Trait]]
  - [[#rct-the-reference-counted-smart-pointer][~Rc<T>~, the Reference Counted Smart Pointer]]
  - [[#refcellt-and-the-interior-mutability-pattern][~RefCell<T>~ and the Interior Mutability Pattern]]
  - [[#reference-cycles-can-leak-memory][Reference Cycles Can Leak Memory]]
- [[#fearless-concurrency][Fearless Concurrency]]
  - [[#using-threads-to-run-code-simultaneously][Using Threads to Run Code Simultaneously]]
  - [[#using-message-passing-to-transfer-data-between-threads][Using Message Passing to Transfer Data Between Threads]]
  - [[#shared-state-concurrency][Shared-State Concurrency]]
  - [[#extensible-concurrency-with-the-sync-and-send-traits][Extensible Concurrency with the Sync and Send Traits]]
  - [[#ending-notes][Ending notes]]
- [[#object-oriented-programming-features-of-rust][Object-Oriented Programming Features of Rust]]
  - [[#characteristics-of-object-oriented-languages][Characteristics of Object-Oriented Languages]]
  - [[#using-trait-objects-that-allow-for-values-of-different-types][Using Trait Objects That Allow for Values of Different Types]]
  - [[#implementing-an-object-oriented-design-pattern][Implementing an Object-Oriented Design Pattern]]
- [[#patterns-and-matching][Patterns and Matching]]
  - [[#all-the-places-patterns-can-be-used][All the Places Patterns Can Be Used]]
  - [[#refutability-whether-a-pattern-might-fail-to-match][Refutability: Whether a Pattern Might Fail to Match]]
  - [[#pattern-syntax][Pattern Syntax]]
- [[#debug][Debug]]
- [[#crates-and-dependencies][Crates and dependencies]]
- [[#documentation][Documentation]]
- [[#style-guide][Style guide]]
- [[#clippy][Clippy]]
- [[#misc][Misc]]
  - [[#test-is-an-array-slice-and-a-vector-slice-the-same][Test: Is an array slice and a vector slice the same?]]
  - [[#test-iterating-over-arrays-and-vectors][Test: Iterating over arrays and vectors]]
- [[#questions][Questions]]
- [[#things-to-investigate][Things to investigate]]
#+END_QUOTE

* Links
** Tutorials

- https://lborb.github.io/
- https://doc.rust-lang.org/book/
- https://github.com/rust-lang/rustlings/
- https://doc.rust-lang.org/stable/rust-by-example/

** Cargo

- https://doc.rust-lang.org/cargo/
- https://crates.io/

** API

- https://doc.rust-lang.org/std/index.html

* Other things to look at

- ~rustfmt~ command
- The prelude (a list of things that Rust automatically imports into every Rust
  program): https://doc.rust-lang.org/std/prelude/index.html

* Getting started
** Installation

https://doc.rust-lang.org/book/ch01-01-installation.html

#+BEGIN_SRC bash :noeval
curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh
cargo install rust-script # Run rust files as scripts. Needed for emacs babel
                          # Make sure the script is on your path afterwards!
rust-script --version
#+END_SRC

*** Update

Once Rust is installed via rustup, when a new version of Rust is released,
updating to the latest version is easy. From your shell, run the following
update script:

#+BEGIN_SRC bash :noeval
rustup update
#+END_SRC

*** Get documentation

The installation of Rust also includes a local copy of the documentation, so you
can read it offline. Run rustup doc to open the local documentation in your
browser.

#+BEGIN_SRC bash :noeval
rustup doc
#+END_SRC

This didn't work on my machine since [[https://stackoverflow.com/questions/55961953/access-denied-when-i-run-rustup-doc][firefox was installed with snap]] but I could
get it to work with:

#+BEGIN_SRC bash :noeval
google-chrome ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/index.html
#+END_SRC

** Hello, World

Files in rust are on the format ~program_name.rs~. Words should be separated with ~_~.

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
}
#+END_SRC

*** Compile it

Add the code from the file above in a file called ~hello_world.rs~, compile it
with ~rustc~ and execute the produced file, ~~hello_world~:

#+BEGIN_SRC bash :noeva
rustc hello_world.rs
./hello_world
#+END_SRC

*** Things to note

1. The ~main~ function is special: it is always the first code that runs in
   every executable Rust program. The first line declares a function named main
   that has no parameters and returns nothing. If there were parameters, they
   would go inside the parentheses, ~()~.
2. ~println!~ calls a Rust macro. If it called a function instead, it would be
   entered as ~println~ (without the ~!~). TODO: Link to macro section
3. Rust style is to indent with four spaces, not a tab. Run
   ~rustfmt hello_world.rs~ to format code according to the standard.

** Hello, Cargo

Cargo handles a lot of tasks for you, such as building your code, downloading
the libraries your code depends on, and building those libraries.

All code in this section is available in the [[file:001_hello_cargo][001_hello_cargo]] directory.

*** Creating a project

In a directory where you want to create a project, run:

#+BEGIN_SRC bash :noeval
cargo new hello_cargo
cd hello_cargo
#+END_SRC

This created the following file structure:

#+BEGIN_SRC
.
`-- hello_cargo
    |-- Cargo.toml
    `-- src
        `-- main.rs
#+END_SRC

The ~Cargo.toml~ file looks like this:

#+BEGIN_SRC toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#+END_SRC

The ~[package]~ heading, is a section heading that indicates that the following
statements are configuring a package.

The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use.

The ~[dependencies]~ heading, is the start of a section for you to list any of
your project’s dependencies (known as /crates/ in Rust).

Cargo expects your source files to live inside the ~src~ directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code.

*** Building and Running a Cargo Project

To build the project, run the following command while standing in the
~hello_cargo~ directory:

#+BEGIN_SRC bash :noeval
cargo build
#+END_SRC

A file is then created in ~target/debug/hello_cargo~. Run it by running the
following command:

#+BEGIN_SRC bash :noeval
./target/debug/hello_cargo
#+END_SRC

The default build is a ~debug~ build and that's why the binary ends up in that
directory.

You may notice that ~cargo build~ also creates a ~Cargo.lock~ in the top level
directory. This file keeps track of the exact versions of dependencies in your
project. Cargo understands [[https://semver.org/][Semantic Versioning]]. If you specify the version
~0.8.3~ this is actually a shorthand for ~^0.8.3~, meaning any version that is
at least ~0.8.3~ but below ~0.9.0~. Between builds the ~Cargo.lock~ file will
guarantee that the same version is used until you explicitly upgrade the
version. You should never need to update this file manually. If you want to make
cargo to reevaluate the version (finding a suitable version at least ~0.8.3~ but
below ~0.9.0~) you can run:

#+BEGIN_SRC bash :noeval
cargo update
#+END_SRC

You can both compile and run the project in one step by running:

#+BEGIN_SRC bash :noeval
cargo run
#+END_SRC

Cargo will automatically figure out what needs to be recompiled and what doesn't.

If you only want to make sure that the project compiles but not actually compile
the project you can run:

#+BEGIN_SRC bash :noeval
cargo check
#+END_SRC

This is much faster than actually compiling the code during development.

*** Building for release

You maybe noticed that the compile binary ended up in ~target/debug~. This is
a development build. They are faster to compile but are not optimized. In order
to optimize the build (which will also increase the build time) you should run
the following command:

#+BEGIN_SRC bash :noeval
cargo build --release
# --release can be used with run as well
cargo run --release
#+END_SRC

This result will end up in ~target/release~ instead of ~target/debug~ now.

* Guessing game

Code and comments for the guessing game is located in [[file:002_guessing_game][002_guessing_game]].

Run with:

#+BEGIN_SRC bash :noeval
cargo run
#+END_SRC

* Common Programming Concepts
** Variable and Mutability

By default variables are immutable. The code below won't compile since you are
trying to reassign the value of an immutable variable.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

But mutability can be very useful. Variables are immutable only by default and
you can make them mutable by adding ~mut~ in front of the variable name. In
addition to allowing this value to change, ~mut~ conveys intent to future
readers of the code by indicating that other parts of the code will be changing
this variable’s value.

#+BEGIN_SRC rust :results output
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

*** Constants

Rust also supports constants using the ~const~ keyword. An immutable variable
and a constant are not exactly the same in Rust.

- You aren’t allowed to use ~mut~ with constants, they're always immutable.
- You declare constants using the ~const~ keyword instead of the ~let~ keyword
- The type of the value /must/ be annotated
- Constants can be declared in any scope, including the global scope
- Constants may be set only to a constant expression, not the result of a value
  that could only be computed at runtime

Rust’s naming convention for constants is to use all uppercase with underscores
between words.

#+BEGIN_SRC rust :results output
fn main() {
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
    println!("{}", THREE_HOURS_IN_SECONDS)
}
#+END_SRC

*** Shadowing

You can declare a new variable with the same name as a previous variable.
Rustaceans say that the first variable is /shadowed/ by the second, which means
that the second variable’s value is what the program sees when the variable is
used.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;

    // This is allowed even though the previous 'x' isn't mutable since this
    // actually creates a new variable 'x' that shadows the previous one
    let x = x + 1;

    {
        // Also this 'x' will shadow the previous 'x'
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x); // 12
    }

    // The inner shadowing end and 'x' returns to bering 6
    println!("The value of x is: {}", x);
}
#+END_SRC

A shadowing variable can also use a different type. E.g. maybe we want to store
a string with spaces (e.g. for indentation) as an integer instead, the following
code would be allowed:

#+BEGIN_SRC rust :results output
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

Using a mutable variable to achieve the same wouldn't work as that would change
the type of the variable:

#+BEGIN_SRC rust :results output
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

** Data Types

Rust is a statically typed language, meaning that all values in Rust is of a
certain data type and that they must be known at compile time. The compiler can
usually infer what type we want to use based on the value and how we use it. In
cases when many types are possible, we must add a type annotation, like this:

#+BEGIN_SRC rust :noeval
let guess: u32 = "42".parse().expect("Not a number!");
#+END_SRC

*** Scalar Types

A scalar type represents a single value. Rust has four primary scalar types:
- integers
- floating-point numbers
- booleans
- characters

**** Integer Types

Integer types in Rust:

| Length  | Signed  | Unsigned |
|---------+---------+----------|
| 8-bit   | ~i8~    | ~u8~     |
| 16-bit  | ~i16~   | ~u16~    |
| 32-bit  | ~i32~   | ~u32~    |
| 64-bit  | ~i64~   | ~u64~    |
| 128-bit | ~i128~  | ~u128~   |
| arch    | ~isize~ | ~usize~  |

the ~isize~ and ~usize~ types depend on the kind of computer your program is
running on: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on
a 32-bit architecture.

You can write integer literals in any of the forms shown in the table below.
Note that number literals that can be multiple numeric types allow a type suffix,
such as ~57u8~, to designate the type. Number literals can also use ~_~ as a
visual separator to make the number easier to read, such as ~1_000~, which will
have the same value as if you had specified ~1000~.

| Number literals  | Example       |
|------------------+---------------|
| Decimal          | ~98_222~      |
| Hex              | ~0xff~        |
| Octal            | ~0o77~        |
| Binary           | ~0b1111_0000~ |
| Byte (~u8~ only) | ~b'A'~        |

Integer types default to ~i32~. The primary situation in which you’d use ~isize~
or ~usize~ is when indexing some sort of collection.

***** Types must match

It looks like as if the types must match when performing arithmetic operations.
The following example will fail to compile as there is no way to add a variable
of type ~i32~ with another variable of type ~i64~.

#+BEGIN_SRC rust :results output
fn main() {
    let x: i32 = 8;
    let y: i64 = 15;
    let z = x + y;

    println!("x: {}", x);
    println!("y: {}", y);
    println!("z: {}", z);
}
#+END_SRC

***** Overflow

Compiling in debug mode will cause the program to /panic/ at runtime if
overflow occurs. When compiling with the ~--release~ flag, no such checks are
included and Rust will perform /two's complement wrapping/. Relying on integer
overflow’s wrapping behavior is considered an error.

To explicitly handle the possibility of overflow, you can use these families of
methods that the standard library provides on primitive numeric types:

- Wrap in all modes with the ~wrapping_*~ methods, such as ~wrapping_add~
- Return the ~None~ value if there is overflow with the ~checked_*~ methods
- Return the value and a boolean indicating whether there was overflow with the
  ~overflowing_*~ methods
- Saturate at the value’s minimum or maximum values with ~saturating_*~ methods

#+BEGIN_SRC rust :results output
fn main() {
    let mut x: i8 = 127;
    x = x.wrapping_add(1);
    println!("x: {}", x);

    x = 127;
    let checked_x: Option<i8> = x.checked_add(1);
    println!("checked_x: {:?}", checked_x);

    x = 127;
    let overflow_x: (i8, bool) = x.overflowing_add(1);
    println!("overflow_x: {:?}", overflow_x);

    x = 127;
    x = x.saturating_add(1);
    println!("x: {}", x);
}
#+END_SRC

**** Floating-Point Types

Rust’s floating-point types are ~f32~ and ~f64~, which are 32 bits and 64 bits
in size, respectively. The default type is ~f64~ because on modern CPUs it’s
roughly the same speed as ~f32~ but is capable of more precision.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32

    println!("x: {}", x);
    println!("y: {}", y)
}
#+END_SRC

**** Numeric Operations

#+BEGIN_SRC rust :results output
fn main() {
    // addition
    let sum = 5 + 10;
    println!("sum: {}", sum);

    // subtraction
    let difference = 95.5 - 4.3;
    println!("difference: {}", difference);

    // multiplication
    let product = 4 * 30;
    println!("product: {}", product);

    // division
    let quotient = 56.7 / 32.2;
    // The following will fail since you can't divide a float with an int
    //let quotient = 56.7 / 32;
    // The following will work though
    //let quotient = 56.7 / 32f64;
    let floored = 2 / 3; // Results in 0. Integer division rounds down to the nearest integer
    println!("quotient: {}", quotient);
    println!("floored: {}", floored);

    let truncated = -5 / 3;
    println!("truncated: {}", truncated); // results in -1

    // remainder
    let remainder = 43 % 5;
    println!("remainder: {}", remainder);
}
#+END_SRC

**** The Boolean Type

Boolean type in Rust has two possible values: ~true~ and ~false~. Booleans are
one byte in size. The boolean type in Rust is specified using ~bool~. For
example:

#+BEGIN_SRC rust :results output
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation

    println!("t: {}", t);
    println!("f: {}", f)
}
#+END_SRC

**** The Character Type

Rust’s ~char~ type is the language’s most primitive alphabetic type. ~char~
literals are specified with single quotes, as opposed to string literals, which
use double quotes.

#+BEGIN_SRC rust :results output
fn main() {
    let c = 'z';
    let z: char = 'ℤ';
    let heart_eyed_cat = '😻';

    println!("c: {}", c);
    println!("z: {}", z);
    println!("heart_eyed_cat: {}", heart_eyed_cat);
}
#+END_SRC

Rust’s ~char~ type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII.

*** Compbound types

Compound types can group multiple values into one type. Rust has two primitive
compound types: tuples and arrays.

**** The Tuple Type

Tuples have a fixed length: once declared, they cannot grow or shrink in size.
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. Type annotation is
optional:

#+BEGIN_SRC rust :noeval
fn main() {
    let annotated_tup: (i32, f64, u8) = (500, 6.4, 1);
    let unannotated_tup = (500, 6.4, 1);
}
#+END_SRC

To get the individual values out of a tuple, we can use pattern matching to
destructure a tuple value, like this:

#+BEGIN_SRC rust :results output
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+END_SRC

In the example above we clearly only cared about ~y~ so it's unnecessary to
create ~x~ and ~z~ as well. We can use ~_~ as a placeholder for unused values:

#+BEGIN_SRC rust :results output
fn main() {
    let tup = (500, 6.4, 1);
    let (_, y, _) = tup;

    println!("The value of y is: {}", y);
}
#+END_SRC

In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (~.~) followed by the index of the value we
want to access. For example:

#+BEGIN_SRC rust :results output
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("five_hundred:   {}", five_hundred);
    println!("six_point_four: {}", six_point_four);
    println!("one:            {}", one);
}
#+END_SRC

The tuple without any values, ~()~, is a special type that has only one value,
also written ~()~. The type is called the /unit type/ and the value is called
the /unit value/. Expressions implicitly return the unit value if they don’t
return any other value.

***** Mutable tuples

A tuple can be made mutable by adding the ~mut~ keyword. If you remove the ~mut~
keyword below, the compilation will fail

#+BEGIN_SRC rust :results output
fn main() {
    let mut x: (i32, f64, u8) = (500, 6.4, 1);
    x.0 = 400;
    let not_five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("not_five_hundred: {}", not_five_hundred);
    println!("six_point_four:   {}", six_point_four);
    println!("one:              {}", one);
}
#+END_SRC

**** The Array Type

Unlike a tuple, every element of an array must have the same type. Arrays in
Rust are different from arrays in some other languages because arrays in Rust
have a fixed length, like tuples. The length is defined at compile time. The
length of an array is part of its type.

In Rust, the values going into an array are written as a comma-separated list
inside square brackets:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
}
#+END_SRC

You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:

#+BEGIN_SRC rust :noeval
let a: [i32; 5] = [1, 2, 3, 4, 5];
#+END_SRC

Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [3; 5];
    println!("{a:?}");
    let b = [3i64; 5]; // To define the type of the elements (in this case i64)
    println!("{b:?}");
}
#+END_SRC

***** Accessing elements

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

If Rust knows at compile time that you are trying to access elements outside the
valid range, the compile will fail and you will get an error message. But checks
are done during run time as well so if you try to access an element outside the
valid range, the program will panic instead of allowing the program to access
the memory. Run the program in [[file:003_invalid_index][003_invalid_index]] for an example.

***** Mutable lists

Lists are immutable by default. You can make it mutable with the ~mut~ keyword

#+BEGIN_SRC rust :results output
fn main() {
    let mut a = [1, 2, 3, 4, 5];
    a[0] = 20;
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

** Functions

Rust code uses snake case as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+END_SRC

Function definitions in Rust start with ~fn~ and have a set of parentheses after
the function name. The curly brackets tell the compiler where the function body
begins and ends. Note that we defined ~another_function~ after the ~main~
function in the source code; we could have defined it before as well. Rust
doesn’t care where you define your functions, only that they’re defined
somewhere.

*** Function parameters

#+BEGIN_SRC rust :results output
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
#+END_SRC

In function signatures, you /must/ declare the type of each parameter. This is a
deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean.

Function with multiple paramaters:

#+BEGIN_SRC rust :results output
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+END_SRC

*** Function Bodies Contain Statements and Expressions

/Statements/ are instructions that perform some action and do not return a
value. /Expressions/ evaluate to a resulting value. Let’s look at some examples.

Creating a variable and assigning a value to it with the ~let~ keyword is a
statement. ~let y = 6;~ is a statement.

Statements do not return values. Therefore, you can’t assign a ~let~ statement
to another variable. E.g:

#+BEGIN_SRC rust :noeval
let x = (let y = 6); // Not valid code!
#+END_SRC

Expressions can be part of statements: the ~6~ in the statement ~let y = 6;~ is
an expression that evaluates to the value ~6~. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, ~{}~, is an expression, for example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let y = {
        let x = x + 3;
        x + 1
    };
    println!("The value of y is: {}", y);
}
#+END_SRC

The expression

#+BEGIN_SRC rust :noeval
let y = {
    let x = x + 3;
    x + 1
};
#+END_SRC

is a block that, in this case, evaluates to ~9~. That value gets bound to ~y~ as
part of the ~let~ statement. Note the ~x + 1~ line without a semicolon at the
end. Expressions do not include ending semicolons. If you add a semicolon to the
end of an expression, you turn it into a statement, which will then not return a
value. Keep this in mind as you explore function return values and expressions
next.

*** Functions with Return Values

Functions can return values to the code that calls them. We declare their type
after an arrow (~->~). In Rust, the return value of the function is synonymous
with the value of the final expression in the block of the body of a function.
You can return early from a function by using the ~return~ keyword and
specifying a value, but most functions return the last expression implicitly.

#+BEGIN_SRC rust :results output
fn five() -> i32 {
    5 // Note that there's no semi colon here
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
#+END_SRC

Another example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = plus_one(5);
    println!("The value of x is: {}", x);
    let y = plus_two(5);
    println!("The value of y is: {}", y);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}

fn plus_two(x: i32) -> i32 {
    // You are allowed to use 'return' to return early
    return x + 2 // Seems like the semi colon is optional here
}
#+END_SRC

**** Returning multiple values

You can always return a tuple if you want to:

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
#+END_SRC

** Comments

[[https://doc.rust-lang.org/reference/comments.html][Comments reference]]

Like in Java:

- Single line comments with ~//~
- Multi line comments starting with ~/*~ and ending with ~*/~

** Control Flow
*** ~if~ expressions

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+END_SRC

Blocks of code associated with the conditions in ~if~ expressions are sometimes
called /arms/. The ~else~ expression is optional.

It’s also worth noting that the condition in this code must be a ~bool~. If the
condition isn’t a ~bool~, we’ll get an error.

**** Handling Multiple Conditions with ~else if~

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+END_SRC

**** Using ~if~ in a ~let~ Statement

Because ~if~ is an expression, we can use it on the right side of a ~let~
statement:

#+BEGIN_SRC rust :results output
fn main() {
    let condition = true;
    // Notice the lack of semi colons inside the blocks. They are expressions!
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+END_SRC

Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the whole
~if~ expression depends on which block of code executes. This means the values
that have the potential to be results from each arm of the ~if~ must be the same
type. In the code above, the results of both the ~if~ arm and the ~else~ arm
were ~i32~ integers. If the types are mismatched we’ll get an error.

*** Repetition with Loops

Rust has three kinds of loops:

- ~loop~
- ~while~
- ~for~

**** The ~loop~ loop

The ~loop~ keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop. You can place the ~break~
keyword within the loop to tell the program when to stop executing the loop.

We can also use the ~continue~ keyword. The ~continue~ keyword within a loop
tells the program to skip over any remaining code in this iteration of the loop
and go to the next iteration.

If you have loops within loops, ~break~ and ~continue~ apply to the innermost
loop at that point. You can optionally specify a /loop label/ on a loop and then
use the label with ~break~ or ~continue~ to have those keywords applied to the
labeled loop instead of the innermost loop. Here’s an example with two nested
loops:

#+BEGIN_SRC rust :results output
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+END_SRC

The outer loop has the label ~'counting_up~ (you need to start the label with a
~'~), and it will count up from 0 to 2. The inner loop without a label counts
down from 10 to 9. The first ~break~ that doesn’t specify a label will exit the
inner loop only. The ~break 'counting_up;~ statement will exit the outer loop.

***** Returning values from loops

One of the uses of a ~loop~ is to retry an operation you know might fail, such
as checking whether a thread has completed its job. However, you might need to
pass the result of that operation to the rest of your code. To do this, you can
add the value you want returned after the ~break~ expression you use to stop the
loop; that value will be returned out of the loop so you can use it, as shown
here:

#+BEGIN_SRC rust :results output
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("The result is {}", result);
}
#+END_SRC

**** The ~while~ loop

A ~while~ loop works as one would expect. ~break~ and ~continue~ are also allowed.

#+BEGIN_SRC rust :results output
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+END_SRC

**** The ~for~ loop

The ~for~ loop can be used when looping over the elements of a collection. You
could do it with a ~while~ loop as well but it's more error prone (the index may
go out of bounds which will cause the program to panic if you enter the wrong
value) and less efficient (Rust adds a check that the index is within the bound
of the array on every iteration).

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+END_SRC

With the ~for~ loop:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
#+END_SRC

Even in situations in which you want to run some code a certain number of times,
as in the countdown example that used a ~while~ loop above, you can use a ~for~
loop. The way to do that would be to use a ~Range~, provided by the standard
library, which generates all numbers in sequence starting from one number and
ending before another number. ~rev~ reverses the range.

#+BEGIN_SRC rust :results output
fn main() {
    for number in (1..4).rev() {
    // Or
    //for number in (1..=3).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
#+END_SRC

* Ownership
** Ownership rules

Keep these rules in mind as we work through the examples that illustrate them:

- Each value in Rust has an owner.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.

** The ~String~ type

We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable.

When we want a mutable version, Rust has a second string type, ~String~. This
type manages data allocated on the heap and as such is able to store an amount
of text that is unknown to us at compile time. You can create a ~String~ from a
string literal using the ~from~ function and also modify the string:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`
}
#+END_SRC

Why can ~String~ be mutated but literals cannot? The difference is how these two
types deal with memory.

** Memory and allocation

In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.

With the ~String~ type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time, to
hold the contents. This means:

- The memory must be requested from the memory allocator at runtime.
- We need a way of returning this memory to the allocator when we’re done with
  our ~String~.

That first part is done by us: when we call ~String::from~, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.

However, the second part is different. In languages with a garbage collector,
the GC keeps track of and cleans up memory that isn’t being used anymore, and we
don’t need to think about it. In most languages without a GC, it’s our
responsibility to identify when memory is no longer being used and call code to
explicitly free it, just as we did to request it. Doing this correctly has
historically been a difficult programming problem. If we forget, we’ll waste
memory. If we do it too early, we’ll have an invalid variable. If we do it
twice, that’s a bug too. We need to pair exactly one ~allocate~ with exactly one
~free~.

Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. It's returned by Rust calling a special
function called ~drop~, and it’s where the author of an object type (e.g
~String~) can put the code to return the memory.

*** Move

Multiple variables can interact with the same data in different ways in Rust.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let mut y = x;
    println!("{}", x);
    println!("{}", y);
    y = 6;
    println!("{}", x);
    println!("{}", y);
}
#+END_SRC

This has the expected behaviour. The variables are simple values with a known,
fixed size and are stored on the stack and the value is simply copied.

What happends with ~String~s?

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    // Try to add back this line and it will fail
    //println!("{}", s1);
    println!("{}", s2);
}
#+END_SRC

A ~String~ is made up of three parts: a pointer to the memory that holds the
contents of the string, a length, and a capacity. This group of data is stored
on the stack (fixed length). The memory on the heap holds the contents.

When we assign ~s1~ to ~s2~, the ~String~ data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to.

So like in other programming languages both strings would be pointing to the
same data on the heap.

So when one of these variables goes out of scope, what would happen? To ensure
memory safety, after the line ~let s2 = s1~, Rust considers ~s1~ as no longer
valid. Therefore, Rust doesn’t need to free anything when ~s1~ goes out of
scope. So the example above will actually now compile!

So what is happening in the example above is not a shallow copy. Because the
first variable is invalidated this is instead known as a /move/.

*** Clone

If we instead would want to also copy the heap we could use the ~clone~ method.
E.g.:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s1 = String::from("hello");
    let mut s2 = s1.clone();
    println!("{}", s1);
    println!("{}", s2);
    s2.push_str(", world!");
    println!("{}", s1);
    println!("{}", s2);
}
#+END_SRC

This creates two independeny memory areas on the heap with different owners.

*** Stack-Only Data: Copy

Rust has a special annotation called the ~Copy~ trait that we can place on types
that are stored on the stack, as integers are. If a type implements the ~Copy~
trait, variables that use it do not /move/, but rather are trivially copied,
making them still valid after assignment to another variable.

Rust won’t let us annotate a type with ~Copy~ if the type, or any of its parts,
has implemented the ~Drop~ trait. If the type needs something special to happen
when the value goes out of scope and we add the ~Copy~ annotation to that type,
we’ll get a compile-time error.

As a general rule, any group of simple scalar values can implement ~Copy~, and
nothing that requires allocation or is some form of resource can implement
~Copy~. Here are some of the types that implement ~Copy~:


- All the integer types.
- The Boolean type
- All the floating point types
- The character type
- Tuples, if they only contain types that also implement ~Copy~. For example,
  ~(i32, i32)~ implements ~Copy~, but ~(i32, String)~ does not.

** Ownership and functions

The mechanics of passing a value to a function are similar to those when
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does.

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...

    //println!("{}", s);            // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward
    println!("{}", x);

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
#+END_SRC

** Return Values and Scope

Returning values can also transfer ownership.

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3

    let mut s4 = String::from("hello"); // The following also works
    s4 = takes_and_gives_back(s4);
} // Here, s3 and s4 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
#+END_SRC

While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but not
take ownership? It’s quite annoying that anything we pass in also needs to be
passed back if we want to use it again, in addition to any data resulting from
the body of the function that we might want to return as well.

** References and Borrowing

A ~reference~ is like a pointer in that it’s an address we can follow to access
the data stored at that address; that data is owned by some other variable.
Unlike a pointer, a reference is guaranteed to point to a valid value of a
particular type for the life of that reference.

Here is how you would define and use a ~calculate_length~ function that has a
reference to an object as a parameter instead of taking ownership of the value:

#+BEGIN_SRC rust :results output
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, it is not dropped.
#+END_SRC

Note that we pass ~&s1~ into ~calculate_length~ and, in its definition, we take
~&String~ rather than ~String~. These ampersands represent references, and they
allow you to refer to some value without taking ownership of it.

The ~&s1~ syntax lets us create a reference that refers to the value of ~s1~ but
does not own it. Because it does not own it, the value it points to will not be
dropped when the reference stops being used.

When functions have references as parameters instead of the actual values, we
won’t need to return the values in order to give back ownership, because we
never had ownership.

We call the action of creating a reference ~borrowing~. When you’re done, you
have to give it back. You don’t own it.

Just as variables are immutable by default, so are references. We’re not allowed
to modify something we have a reference to. The following code won't compile:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+END_SRC

*** Mutable references

We can fix the code from above to allow us to modify a borrowed value with just
a few small tweaks that use, instead, a ~mutable reference~:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello"); // change s to be mut

    change(&mut s); // create a mutable reference

    println!("{}", s);
}

fn change(some_string: &mut String) { // Change to accept a mutable reference wiht &mut
    some_string.push_str(", world");
}
#+END_SRC

The updated function signature will make it very clear that the change function
will mutate the value it borrows.

Mutable references have one big restriction: if you have a mutable reference to
a value, you can have no other references to that value. This code that attempts
to create two mutable references to ~s~ will fail:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}
#+END_SRC

The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It’s something
that new Rustaceans struggle with, because most languages let you mutate
whenever you’d like. The benefit of having this restriction is that Rust can
prevent data races at compile time. A data race is similar to a race condition
and happens when these three behaviors occur:

- Two or more pointers access the same data at the same time.
- At least one of the pointers is being used to write to the data.
- There’s no mechanism being used to synchronize access to the data.

Rust enforces a similar rule for combining mutable and immutable references.
This code results in an error:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

    println!("{}, {}, and {}", r1, r2, r3);
}
#+END_SRC

Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references, the ~println!~,
occurs before the mutable reference is introduced:

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // variables r1 and r2 will not be used after this point
    // and the scope for those variables ends here

    let r3 = &mut s; // no problem
    println!("{}", r3);
}
#+END_SRC

*** Dangling references

A dangling pointer is a pointer that references a location in memory that may
have been given to someone else by freeing some memory while preserving a
pointer to that memory. In Rust, by contrast, the compiler guarantees that
references will never be dangling references: if you have a reference to some
data, the compiler will ensure that the data will not go out of scope before the
reference to the data does.

#+BEGIN_SRC rust :results output
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
#+END_SRC

Because ~s~ is created inside dangle, when the code of dangle is finished, ~s~
will be deallocated. But we tried to return a reference to it. That means this
reference would be pointing to an invalid ~String~. Rust won’t let us do this.
Instead we could return ~s~ which would also transfer ownership.

*** The Rules of References

Let’s recap what we’ve discussed about references:

- At any given time, you can have either one mutable reference or any number of
  immutable references.
- References must always be valid.

** The slice type

/Slices/ let you reference a contiguous sequence of elements in a collection
rather than the whole collection. A slice is a kind of reference, so it does not
have ownership.

*** String slices

A string slice is a reference to part of a ~String~, and it looks like this:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
    println!("{}", hello);
    println!("{}", world);
}
#+END_SRC

We create slices using a range within brackets by specifying
~[starting_index..ending_index]~. ~starting_index~ is inclusive and
~ending_index~ is exclusive. Internally, the slice data structure stores a
pointer to the starting position and the length of the slice.

With Rust’s ~..~ range syntax, if you want to start at index zero, you can drop
the value before the two periods and if your slice includes the last index, you
can drop the trailing number.

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");

    let len = s.len();

    let start0 = &s[0..2];
    let start1 = &s[..2];

    let end0 = &s[5..len];
    let end1 = &s[5..];

    let full0 = &s[0..len];
    let full1 = &s[..];
}
#+END_SRC

Here's an example to get the first word of a ~String~:

#+BEGIN_SRC rust :results output
fn main() {
    let s = String::from("hello world");
    let fw = first_word(&s);
    println!("{}", fw);
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

This example includes an iteration which there will be more about later.

What if we try to modify the ~String~ which the slice is referencing?

#+BEGIN_SRC rust :results output
fn main() {
    let mut s = String::from("hello world");
    let fw = first_word(&s);
    s.clear();
    println!("{}", fw);
    //s.clear(); // This clear would work since the immutable reference is out of scope
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

It won't compile! Recall from the borrowing rules that if we have an immutable
reference (e.g. a slice) to something, we cannot also take a mutable reference.
Because ~clear~ needs to truncate the ~String~, it needs to get a mutable
reference. The ~println!~ after the call to ~clear~ uses the reference in ~fw~,
so the immutable reference must still be active at that point.

*** String literals are slices

#+BEGIN_SRC rust :noeval
let s = "Hello, world!";
#+END_SRC

The type of ~s~ here is ~&str~: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; ~&str~ is an
immutable reference.

*** String slices as parameters

So a reference to a ~&str~ and a ~String~ are both ~&str~:

#+BEGIN_SRC rust :results output
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}

fn main() {
    let s_slice = "slice";
    let s_string = String::from("string");
    print_type_of(&s_slice);
    print_type_of(&s_string);
    let slice_ref = &s_slice[..];
    let string_ref = &s_string[..];
    print_type_of(&slice_ref);
    print_type_of(&string_ref);
}
#+END_SRC

Knowing that you can take slices of literals and ~String~ values leads us to one
more improvement on ~first_word~, and that’s its signature:

#+BEGIN_SRC rust :noeval
fn first_word(s: &String) -> &str {
// Becomes
fn first_word(s: &str) -> &str {
#+END_SRC

This allows us to use the same function on both ~&String~ values and ~&str~
values. Defining a function to take a string slice instead of a reference to a
~String~ makes our API more general and useful without losing any functionality:

#+BEGIN_SRC rust :results output
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
    println!("{word}")
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..] // If no space is found return the a full slice
}
#+END_SRC

*** Other slices

There’s a more general slice type, too. Consider this array:

#+BEGIN_SRC rust :noeval
let a = [1, 2, 3, 4, 5];
#+END_SRC

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3];
    assert_eq!(slice, &[2, 3]);
}
#+END_SRC

This slice has the type ~&[i32]~. It works the same way as string slices do, by
storing a reference to the first element and a length.

* Structs

Structs are similar to [[*The Tuple Type][tuples]], in that both hold multiple related values but in
a struct you’ll name each piece of data so it’s clear what the values mean.

To define a struct, we enter the keyword ~struct~ and name the entire struct.
Then, inside curly brackets, we define the /fields/. We define an /instance/ of
the struct in the following way (we don’t have to specify the fields in the same
order in which we declared them in the struct):

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
}
#+END_SRC

To get a specific value from a struct, we use dot notation. If the instance is
mutable, we can change a value by using the dot notation and assigning into a
particular field.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
#+END_SRC

Rust doesn’t allow us to mark only certain fields as mutable, so the instance
must be mutable. We can also construct a new instance of a struct as the last
expression of a function.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email: email, // Note the repetition!
        username: username, // Note the repetition!
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"));
}
#+END_SRC

The pattern above, that the parameter names and the struct field names are
exactly the same, we can use the /field init shorthand/ syntax to rewrite
~build_user~. Because the ~email~ field and the ~email~ parameter have the same
name, we only need to write ~email~ rather than ~email: email~.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email, // Repetition gone
        username, // Repetition gone
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"));
}
#+END_SRC

** Struct update syntax

It’s often useful to create a new instance of a struct that includes most of the
values from another instance, but changes some. You can do this using /struct
update syntax/. This how you would create a new instance with an updated ~email~
field without the syntax:

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
#+END_SRC

Using struct update syntax it would look like this (the result is the same
though).

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
#+END_SRC

The ~..user1~ must come last to specify that any remaining fields should get
their values from the corresponding fields in ~user1~, but we can choose to
specify values for as many fields as we want in any order, regardless of the
order of the fields in the struct’s definition.

Why is it called an update when we still use the ~=~ operator like assignments?
It's because we [[*Move][move]] the data. We can no longer use ~user1~ after creating
~user2~ because the ~String~ in the ~username~ field of ~user1~ was moved into
~user2~. If we had given ~user2~ new ~String~ values for both ~email~ and
~username~, and thus only used the ~active~ and ~sign_in_count~ values from
~user1~, then ~user1~ would still be valid after creating ~user2~. The types of
~active~ and ~sign_in_count~ are types that implement the ~Copy~ trait.

** Destruct tuples

Like a tuple you can destruct a struct.

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
}

fn main() {
    let user1 = User {
        username: String::from("someusername123"),
        active: true,
    };

    let User {username: u, active: a} = user1;
}
#+END_SRC

If you don't care about some fields you can omit them and add ~..~ as a
"filler":

#+BEGIN_SRC rust :results output
struct User {
    active: bool,
    username: String,
}

fn main() {
    let user1 = User {
        username: String::from("someusername123"),
        active: true,
    };

    let User {active: a, ..} = user1;
}
#+END_SRC

** Tuple structs

Rust also supports structs that look similar to tuples, called /tuple structs/.
They don’t have names associated with their fields; rather, they just have the
types of the fields. These are useful when you want to give the whole tuple a
name and make the tuple a different type from other tuples.

You define them as a regular ~struct~ but leave out the name of the fields:

#+BEGIN_SRC rust :results output
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
#+END_SRC

Note that the ~black~ and ~origin~ values are different types, because they’re
instances of different tuple structs. A function that takes a parameter of type
~Color~ cannot take a ~Point~ as an argument. If we used regular tuples we could
feed both ~black~ and ~origin~ the the same functions.

Otherwise, tuple struct instances are similar to tuples in that you can
destructure them into their individual pieces, and you can use a ~.~ followed by
the index to access an individual value. ~_~ can be used as a placeholder for
unused values when destructing a struct tuple:

#+BEGIN_SRC rust :results output
struct Color(i32, i32, i32);

fn main() {
    let c = Color(0, 1, 2);
    let Color(r, _, _) = c;
    println!("{}", r);
    println!("{}", c.1);
}
#+END_SRC

** Unit-like structs

You can also define structs that don’t have any fields. These are called
unit-like structs because they behave similarly to ~()~, the unit type.

#+BEGIN_SRC rust :results output
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
#+END_SRC

Unit-like structs can be useful when you need to implement a trait on some type
but don’t have any data that you want to store in the type itself. Traits will
be discussed later.

** Ownerships of struct data

In the examples above we have used the owned ~String~ type instead of the ~&str~
string slice type. This is a deliberate choice because we want each instance of
this struct to own all of its data and for that data to be valid for as long as
the entire struct is valid.

It’s also possible for structs to store references to data owned by something
else, but to do so requires the use of lifetimes.

** An example with structs

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let width = 30;
    let height = 50;
    let rect_tuple = (30, 50);
    let rect_struct = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_variables(width, height)
    );
    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_tuples(rect_tuple)
    );
    println!(
        "The area of the rectangle is {} square pixels.",
        area_with_struct(&rect_struct)
    );
}

// Bad
fn area_with_variables(width: u32, height: u32) -> u32 {
    width * height
}

// Better
fn area_with_tuples(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}

// Best
fn area_with_struct(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
#+END_SRC

In the struct example we want to borrow the struct rather than take ownership of
it. This way, ~main~ retains its ownership and can continue using ~rect_struct~,
which is the reason we use the ~&~ in the function signature and where we call
the function. Note that accessing fields of a borrowed struct instance does not
move the field values, which is why you often see borrows of structs.

** Adding Useful Functionality with Derived Traits

We can't print a ~Rectangle~ directly:

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
#+END_SRC

The code above complains that the ~Display~ trait is not implemented for
~Rectangle~. It suggest to print with ~{:?}~ instead of ~{}~. Let's try that:

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
#+END_SRC

Now it complains that we don't have the ~Debug~ trait implemented. Instead of
manually implementing it we can derive it with ~#[derive(Debug)]~:

#+BEGIN_SRC rust :results output
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
    // Or
    println!("rect1 is {rect1:?}");
    // Or for pretty printing the debug output
    println!("rect1 is {rect1:#?}");
}
#+END_SRC

Another way to debug your code is with the ~dbg!~ macro. It takes ownership of
an expression (as opposed to ~println!~, which takes a reference), prints the
file and line number of where that ~dbg!~ macro call occurs in your code along
with the resultant value of that expression, and returns ownership of the value.

#+BEGIN_SRC rust :results output
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // The ownership is handed back so this is ok
        height: 50,
    };

    // Pass a reference since we don't handle the returned ownership here
    dbg!(&rect1);
}
#+END_SRC

The ~dbg!~ macro prints to ~stderr~ so executing this code in emacs will print
the log in the error output buffer.

** Methods

Rust allows structs, enums and traits to define methods and their first
parameter is always ~self~, which represents the instance of the struct the
method is being called on.

*** Defining methods

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
#+END_SRC

To define the function within the context of ~Rectangle~, we start an ~impl~
(implementation) block for ~Rectangle~. Everything within this ~impl~ block will
be associated with the ~Rectangle~ type.

In the signature for area, we use ~&self~ instead of ~rectangle: &Rectangle~ (as
in the example above). The ~&self~ is actually short for ~self: &Self~. Within
an ~impl~ block, the type ~Self~ is an alias for the type that the ~impl~ block
is for. Methods must have a parameter named ~self~ of type ~Self~ for their
first parameter, so Rust lets you abbreviate this with only the name ~self~ in
the first parameter spot. Note that we still need to use the ~&~ in front of the
self shorthand to indicate this method borrows the ~Self~ instance, just as we
did in ~rectangle: &Rectangle~. Methods can take ownership of ~self~, borrow
~self~ immutably as we’ve done here, or borrow ~self~ mutably, just as they can
any other parameter. If we wanted to change the instance that we’ve called the
method on as part of what the method does, we’d use ~&mut self~ as the first
parameter.

You are also allowed to give a method the same name as a structs fields. E.g.

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() { // The parentheses makes rust use the method and not the field
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
#+END_SRC

*** Automatic referencing and dereferencing

When you call a method with ~object.something()~, Rust automatically adds in
~&~, ~&mut~, or ~*~ so object matches the signature of the method. In other
words, the following are the same:

#+BEGIN_SRC rust :noeval
p1.distance(&p2);
(&p1).distance(&p2);
#+END_SRC

The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver - the type of ~self~.

*** Methods with more parameters

Working with more parameters works as one would expect

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn is_larger_than(&self, other: &Self) -> bool {
        self.area() > other.area()
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("rect1 is larger than rect2? {}", rect1.is_larger_than(&rect2));
    println!("rect1 is larger than rect3? {}", rect1.is_larger_than(&rect3));
}
#+END_SRC

*** Associated functions

All functions defined within an ~impl~ block are called /associated functions/
because they’re associated with the type named after the ~impl~. We can define
associated functions that don’t have ~self~ as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with.

Associated functions that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called ~new~, but
~new~ isn’t a special name and isn’t built into the language.

#+BEGIN_SRC rust :results output
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let squared = Rectangle::square(3);
}
#+END_SRC

To call this associated function, we use the ~::~ syntax with the struct name.
This function is namespaced by the struct

*** Multiple ~impl~ blocks

Each struct is allowed to have multiple ~impl~ blocks. The following blocks are
equivalent. In this case, there’s no reason to separate these methods into
multiple ~impl~ blocks here, but this is valid syntax.

#+BEGIN_SRC rust :noeval
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+END_SRC

and

#+BEGIN_SRC rust :noeval
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+END_SRC

* Enums and pattern matching
** Defining an enum

To define am enum representing the different standards for IP addresses you
would define it like this:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}
#+END_SRC

~IpAddrKind~ is now a custom data type that we can use elsewhere in our code. We
can now create instances of each of the two variants of ~IpAddrKind~ and define
functions that takes any ~IpAddrKind~:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}

fn route(ip_kind: IpAddrKind) {}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(four);
    route(six);
}
#+END_SRC

To define the data associated with the enum you may be tempted to use enums in
combination with a struct, like this:

#+BEGIN_SRC rust :results output
enum IpAddrKind {
    V4,
    V6
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+END_SRC

But you can represent this using only enums. This new definition of the ~IpAddr~
enum says that both ~V4~ and ~V6~ variants will have associated ~String~ values:

#+BEGIN_SRC rust :results output
enum IpAddr {
    V4(String),
    V6(String)
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC

We attach data to each variant of the enum directly, so there is no need for an
extra struct (this is not possible in e.g. Java). Here it’s also easier to see
another detail of how enums work: the name of each enum variant that we define
also becomes a function that constructs an instance of the enum. That is,
~IpAddr::V4()~ is a function call that takes a ~String~ argument and returns an
instance of the ~IpAddr~ type. We automatically get this constructor function
defined as a result of defining the enum.

Each variant can have different types and amounts of associated data. If we
wanted to store ~V4~ addresses as four ~u8~ values but still express ~V6~
addresses as one ~String~ value, we wouldn’t be able to with a struct. Enums
handle this case with ease:

#+BEGIN_SRC rust :results output
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String)
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+END_SRC

You can put any kind of data inside an enum variant: strings, numeric types,
structs, or another enum for example.

A more advanced example could look like this:

#+BEGIN_SRC rust :results output
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+END_SRC

This enum has four variants with different types:

- ~Quit~ has no data associated with it at all.
- ~Move~ has named fields like a struct does.
- ~Write~ includes a single ~String~.
- ~ChangeColor~ includes three ~i32~ values.

There is one more similarity between enums and structs: just as we’re able to
define methods on structs using ~impl~, we’re also able to define methods on
enums. Here’s a method named ~call~ that we could define on our ~Message~ enum:

#+BEGIN_SRC rust :results output
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+END_SRC

*** The ~Option~ enum

There is no ~null~ value in Rust, but it does have an enum that can encode the
concept of a value being present or absent. This enum is ~Option<T>~, and it is
[[https://doc.rust-lang.org/std/option/enum.Option.html][defined by the standard library]] library as follows:

#+BEGIN_SRC rust :results output
enum Option<T> {
    None,
    Some(T)
}
#+END_SRC

The ~Option<T>~ enum is so useful that it’s even included in the prelude. Its
variants are also included in the prelude: you can use ~Some~ and ~None~
directly without the ~Option::~ prefix. The ~Option<T>~ enum is still just a
regular enum, and ~Some(T)~ and ~None~ are still variants of type ~Option<T>~.

The ~<T>~ syntax is a generic type parameter. Here are some examples of using
~Option~ values to hold number types and string types:

#+BEGIN_SRC rust :results output
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
#+END_SRC

The type of ~some_number~ is ~Option<i32>~. The type of ~some_char~ is
~Option<char>~, which is a different type. Rust can infer these types because
we’ve specified a value inside the ~Some~ variant. For ~absent_number~, Rust
requires us to annotate the overall ~Option~ type: the compiler can’t infer the
type that the corresponding ~Some~ variant will hold by looking only at a ~None~
value.

~Option<T>~ is a different type than ~T~ so the following will fail:

#+BEGIN_SRC rust :results output
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;
#+END_SRC

When we have a value of a type like ~i8~ in Rust, the compiler will ensure that
we always have a valid value. We can proceed confidently without having to check
for ~null~ before using that value. Only when we have an ~Option<T>~ do we have
to worry about possibly not having a value, and the compiler will make sure we
handle that case before using the value. In other words, you have to convert an
~Option<T>~ to a ~T~ before you can perform ~T~ operations with it. This can be
done with the ~match~ expression (see below) or with the functions described in
[[https://doc.rust-lang.org/std/option/enum.Option.html][Option's documentation]].

** The ~match~ control flow construct

~match~ allows you to compare a value against a series of patterns and then
execute code based on which pattern matches. The power of ~match~ comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.

Here's an example:

#+BEGIN_SRC rust :results output
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10, // Try remove one option
        Coin::Quarter => 25,
    }
}

let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let penny_cents = value_in_cents(Coin::Penny);
println!("{}", penny_cents);
#+END_SRC

The different options in a ~match~ expression are called the ~match~ arms. An
arm has two parts: a pattern and some code. The first arm here has a pattern
that is the value ~Coin::Penny~ and then the ~=>~ operator that separates the
pattern and the code to run. The code in this case is just the value ~1~. Each
arm is separated from the next with a comma.

The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire ~match~ expression.

We don’t typically use curly brackets if the match arm code is short, but if you
want to run multiple lines of code in a ~match~ arm, you must use curly
brackets, and the comma following the arm is then optional. E.g.

#+BEGIN_SRC rust :results output
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let penny_cents = value_in_cents(Coin::Penny);
println!("{}", penny_cents);
#+END_SRC

*** Patterns that bind to values

~match~ can bind to the parts of the values that match the pattern. This is how
we can extract values out of enum variants.

Let's add a ~UsState~ enum to the ~Quarter~ variant of our ~Coin~ enum:

#+BEGIN_SRC rust :results output
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state); // We use the derive(Debug) functionality here
            25
        }
    }
}
let nickel_cents = value_in_cents(Coin::Nickel);
println!("{}", nickel_cents);
let quarter_cents = value_in_cents(Coin::Quarter(UsState::Alaska));
println!("{}", quarter_cents)
#+END_SRC

*** Matching with ~Option<T>~

The concept above can also be applied to ~Option<T>~. E.g.

#+BEGIN_SRC rust :results output
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
println!("{:?}", five);
let six = plus_one(five);
println!("{:?}", six);
let none = plus_one(None);
println!("{:?}", none);
#+END_SRC

*** Matches are exhaustive

In a ~match~ statement all patterns must be covered, otherwise it won't compile.
E.g.

#+BEGIN_SRC rust :results output
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        //None => None,
        Some(i) => Some(i + 1),
    }
}
#+END_SRC

Try to run the code above and see that the compilation fails.

*** Catch-all patterns and the ~_~ placeholder

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        22..=30 => println!("A value between 20 and 30 (inclusive)"),
        other => println!("Just a {}...", other)
    }
}

print_number(3);
print_number(9);
print_number(7);
print_number(25);
#+END_SRC

The code above compile even though we haven't covered all possible values a ~u8~
can have. This is because the last pattern will match all values not
specifically listed (the variable may be named anything, not just ~other~).

If we don't care about the "catch all" value we can use ~_~. By using this, the
value won't be bound to ~_~ and Rust won't warn us about an unused variable.

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        _ => println!("Just another value...")
    }
}

print_number(3);
print_number(9);
print_number(7);
#+END_SRC

But what if we don't want to do anything in the catch all scenario? Just use the
/unit value/, ~()~ (discussed in [[*The Tuple Type][The Tuple Type]] section).

#+BEGIN_SRC rust :results output
fn print_number(x: u8) {
    match x {
        3 => println!("Three!"),
        7 => println!("Seven!"),
        _ => ()
    }
}

print_number(3);
print_number(9);
print_number(7);
#+END_SRC

** Concise Control Flow with ~if let~

If you only care about one value it may feel unnecessary to write code like
this:

#+BEGIN_SRC rust :results output
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
#+END_SRC

To satisfy the ~match~ expression, we have to add ~_ => ()~ after processing
just one variant, which is annoying boilerplate code to add. Instead we can use
~if let~ when we only want to process one single variant:

#+BEGIN_SRC rust :results output
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
#+END_SRC

Using ~if let~ means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that ~match~ enforces.

In other words, you can think of ~if let~ as syntax sugar for a ~match~ that
runs code when the value matches one pattern and then ignores all other values.

It's also allowed to use ~else~ with ~if let~. The block of code that goes with
the ~else~ is the same as the block of code that would go with the ~_~ case in
the ~match~ expression that is equivalent to the ~if let~ and ~else~.

#+BEGIN_SRC rust :results output
//let config_max = Some(3u8);
let config_max: Option<u8> = None;
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
} else {
    println!("No maximum value is defined");
}
#+END_SRC

* Managing growing projects with packages, crates, and modules

Rust has a number of features that allow you to manage your code’s organization,
including which details are exposed, which details are private, and what names
are in each scope in your programs. These features, sometimes collectively
referred to as the module system, include:

- *Packages:* A Cargo feature that lets you build, test, and share crates
- *Crates:* A tree of modules that produces a library or executable
- *Modules* and *use:* Let you control the organization, scope, and privacy of
  paths
- *Paths:* A way of naming an item, such as a struct, function, or module

** Packages and crates

A /crate/ is the smallest amount of code that the Rust compiler considers at a
time. Even if you run ~rustc~ rather than ~cargo~ and pass a single source code
file, the compiler considers that file to be a crate. Crates can contain
modules, and the modules may be defined in other files that get compiled with
the crate.

A crate can come in one of two forms: a binary crate or a library crate. /Binary
crates/ are programs you can compile to an executable that you can run, such as
a command-line program or a server. Each must have a function called ~main~ that
defines what happens when the executable runs. All the crates we’ve created so
far have been binary crates.

/Library crates/ don’t have a ~main~ function, and they don’t compile to an
executable. Instead, they define functionality intended to be shared with
multiple projects. Most of the time when Rustaceans say “crate”, they mean
library crate, and they use “crate” interchangeably with the general programming
concept of a "library".

The /crate root/ is a source file that the Rust compiler starts from and makes
up the root module of your crate.

A /package/ is a bundle of one or more crates that provides a set of
functionality. A package contains a ~Cargo.toml~ file that describes how to
build those crates. ~cargo~ is actually a package that contains the binary crate
for the command-line tool you’ve been using to build your code. The ~cargo~
package also contains a library crate that the binary crate depends on. Other
projects can depend on the ~cargo~ library crate to use the same logic the
~cargo~ command-line tool uses.

A package can contain as many binary crates as you like, but at most only one
library crate. A package must contain at least one crate, whether that’s a
library or binary crate.

After we run ~cargo new my-project~, we use ~ls~ to see what Cargo creates. In
the project directory, there’s a ~Cargo.toml~ file, giving us a package. There’s
also a ~src~ directory that contains ~main.rs~. Open ~Cargo.toml~ in your text
editor, and note there’s no mention of ~src/main.rs~. Cargo follows a convention
that ~src/main.rs~ is the crate root of a binary crate with the same name as the
package. Likewise, Cargo knows that if the package directory contains
~src/lib.rs~, the package contains a library crate with the same name as the
package, and ~src/lib.rs~ is its crate root. Cargo passes the crate root files
to ~rustc~ to build the library or binary.

Here, we have a package that only contains ~src/main.rs~, meaning it only
contains a binary crate named ~my-project~. If a package contains ~src/main.rs~
and ~src/lib.rs~, it has two crates: a binary and a library, both with the same
name as the package. A package can have multiple binary crates by placing files
in the ~src/bin~ directory: each file will be a separate binary crate.

** Defining modules to control scope and privacy
*** Modules cheat sheet

Here we provide a quick reference on how modules, paths, the ~use~ keyword, and
the ~pub~ keyword work in the compiler, and how most developers organize their
code.

**** Start from the crate root

When compiling a crate, the compiler first looks in the crate root file (usually
~src/lib.rs~ for a library crate or ~src/main.rs~ for a binary crate) for code
to compile.

**** Declaring modules

In the crate root file, you can declare new modules; say, you declare a “garden”
module with ~mod garden;~. The compiler will look for the module’s code in these
places:

- Inline, within curly brackets that replace the semicolon following ~mod garden~
- In the file ~src/garden.rs~
- In the file ~src/garden/mod.rs~

**** Declaring submodules

In any file other than the crate root, you can declare submodules. For example,
you might declare ~mod vegetables;~ in ~src/garden.rs~. The compiler will look
for the submodule’s code within the directory named for the parent module in
these places:

- Inline, directly following ~mod vegetables~, within curly brackets instead of
  the semicolon
- In the file ~src/garden/vegetables.rs~
- In the file ~src/garden/vegetables/mod.rs~

**** Paths to code in modules

Once a module is part of your crate, you can refer to code in that module from
anywhere else in that same crate, as long as the privacy rules allow, using the
path to the code. For example, an ~Asparagus~ type in the ~garden~ ->
~vegetables~ module would be found at ~crate::garden::vegetables::Asparagus~.

**** Private vs public

Code within a module is private from its parent modules by default. To make a
module public, declare it with ~pub mod~ instead of ~mod~. To make items within
a public module public as well, use ~pub~ before their declarations.

**** The ~use~ keyword

Within a scope, the ~use~ keyword creates shortcuts to items to reduce
repetition of long paths. In any scope that can refer to
~crate::garden::vegetables::Asparagus~, you can create a shortcut with
~use crate::garden::vegetables::Asparagus;~ and from then on you only need to
write ~Asparagus~ to make use of that type in the scope.

**** Example

Here we create a binary crate named ~backyard~ that illustrates these rules. The
crate’s directory, also named ~backyard~, contains these files and directories
(all code is located under [[file:004_modules/backyard][004_modules/backyard]]):

#+BEGIN_SRC
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
#+END_SRC

The crate root file in this case is ~src/main.rs~, and it contains:

#+BEGIN_SRC rust :noeval
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
#+END_SRC

The ~pub mod garden;~ line tells the compiler to include the code it finds in
~src/garden.rs~, which is:

#+BEGIN_SRC rust :noeval
pub mod vegetables;
#+END_SRC

Here, ~pub mod vegetables;~ means the code in ~src/garden/vegetables.rs~ is
included too. That code is:

#+BEGIN_SRC rust :noeval
#[derive(Debug)]
pub struct Asparagus {}
#+END_SRC

If you remove ~pub~ from ~pub mod garden;~ the module will be private for
~garden~ and you wouldn't be able to use it in the ~main.rs~ file. Same for
~pub struct Asparagus {}~.

*** Grouping related code in modules

/Modules/ let us organize code within a crate for readability and easy reuse.
Modules also allow us to control the /privacy/ of items, because code within a
module is private by default. We can choose to make modules and the items within
them public, which exposes them to allow external code to use and depend on
them.

We can organize its functions into nested modules. Create a new library named
~restaurant~ by running ~cargo new restaurant --lib~; then enter the code in
into ~src/lib.rs~ to define some modules and function signatures. Here’s the
front of house section:

#+BEGIN_SRC rust :noeval
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
#+END_SRC

We define a module with the ~mod~ keyword followed by the name of the module (in
this case, ~front_of_house~). The body of the module then goes inside curly
brackets. Inside modules, we can place other modules, as in this case with the
modules ~hosting~ and ~serving~. Modules can also hold definitions for other
items, such as structs, enums, constants, traits, and functions. By using
modules, we can group related definitions together and name why they’re related.

Earlier, we mentioned that ~src/main.rs~ and ~src/lib.rs~ are called /crate
roots/. The reason for their name is that the contents of either of these two
files form a module named ~crate~ at the root of the crate’s module structure,
known as the /module tree/.

#+BEGIN_SRC
crate
└── front_of_house
    ├── hosting
    │   ├── add_to_waitlist
    │   └── seat_at_table
    └── serving
        ├── take_order
        ├── serve_order
        └── take_payment
#+END_SRC

The tree above shows how some of the modules nest inside one another; for
example, ~hosting~ nests inside ~front_of_house~. The tree also shows that some
modules are siblings to each other, such as ~hosting~ and ~serving~. If module
~A~ is contained inside module ~B~, we say that module ~A~ is the /child/ of
module ~B~ and that module ~B~ is the /parent/ of module ~A~. Notice that the
entire module tree is rooted under the implicit module named ~crate~.

** Paths for referring to an item in the module tree

To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. To call a function, we need to
know its path.

A path can take two forms:

- An /absolute path/ is the full path starting from a crate root; for code from
  an external crate, the absolute path begins with the crate name, and for code
  from the current crate, it starts with the literal ~crate~.
- A /relative path/ starts from the current module and uses ~self~, ~super~, or
  an identifier in the current module.

Both absolute and relative paths are followed by one or more identifiers
separated by double colons (~::~). Example:

#+BEGIN_SRC rust :noeval
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+END_SRC

Note that the ~hosting~ module and ~add_to_waitlist~ are marked public. In Rust,
all items (functions, methods, structs, enums, modules, and constants) are
private to parent modules by default. If you want to make an item like a
function or struct private, you put it in a module.

Items in a parent module can’t use the private items inside child modules, but
items in child modules can use the items in their ancestor modules. This is
because child modules wrap and hide their implementation details, but the child
modules can see the context in which they’re defined.

*** Exposing paths with the ~pub~ keyword

As mentioned before, in Rust, all items (functions, methods, structs, enums,
modules, and constants) are private to parent modules by default. To make them
available for the parent module, you add the ~pub~ keyword.

When defining a module private (e.g. with ~mod hosting;~) the public items in
that module will be available to this module, but no parent modules. If you
define it with the ~pub~ keyword (~pub mod hosting;~) the public items in that
module will be available to this module and it's parent module (and that modules
parent if this module was declared public).

*** Starting relative paths with ~super~

We can construct relative paths that begin in the parent module, rather than the
current module or the crate root, by using ~super~ at the start of the path.
This is like starting a filesystem path with the ~..~ syntax.

#+BEGIN_SRC rust :noeval
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
#+END_SRC

The ~fix_incorrect_order~ function is in the ~back_of_house~ module, so we can
use ~super~ to go to the parent module of ~back_of_house~, which in this case is
~crate~, the root. From there, we look for ~deliver_order~ and find it.

*** Making structs and enums public

We can also use ~pub~ to designate structs and enums as public, but there are a
few details extra to the usage of ~pub~ with structs and enums. If we use ~pub~
before a struct definition, we make the struct public, but the struct’s fields
will still be private. We can make each field public or not on a case-by-case
basis.

#+BEGIN_SRC rust :results output
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
#+END_SRC

Because the ~toast~ field in the ~back_of_house::Breakfast~ struct is public, in
~eat_at_restaurant~ we can write and read to the ~toast~ field using dot
notation. Notice that we can’t use the ~seasonal_fruit~ field in
~eat_at_restaurant~ because ~seasonal_fruit~ is private.

Also, note that because ~back_of_house::Breakfast~ has a private field, the
struct needs to provide a public associated function that constructs an instance
of ~Breakfast~ (we’ve named it ~summer~ here). If ~Breakfast~ didn’t have such a
function, we couldn’t create an instance of ~Breakfast~ in ~eat_at_restaurant~
because we couldn’t set the value of the private ~seasonal_fruit~ field in
~eat_at_restaurant~.

In contrast, if we make an enum public, all of its variants are then public. We
only need the ~pub~ before the ~enum~ keyword.

#+BEGIN_SRC rust :results output
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
#+END_SRC

** Bringing paths into scope with the ~use~ keyword

Instead of writing out the full parths to use items in other modules we can use
use the ~use~ keyword to create a shortcut to a path, and then use the shorter
name everywhere else in the scope.

#+BEGIN_SRC rust :results output
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting; // Relative path but we could use the absolute path as well
//use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    // instead of
    //front_of_house::hosting::add_to_waitlist();
}
#+END_SRC

~hosting~ is now a valid name in this scope, just as though the ~hosting~ module
had been defined here. Note that ~use~ only creates the shortcut for the
particular scope in which the ~use~ occurs. The code block below moves the
~eat_at_restaurant~ function into a new child module named ~customer~, which is
then a different scope than the ~use~ statement, so the function body won’t
compile:

#+BEGIN_SRC rust :noeval
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
#+END_SRC

To fix this problem, move the ~use~ within the ~customer~ module too, or
reference the shortcut in the parent module with ~super::hosting~ within the
child ~customer~ module.

*** Creating idiomatic ~use~ paths

In the example above you could also specified the ~use~ path all the way down
to the function, like this:

#+BEGIN_SRC rust :results output
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting::add_to_waitlist;


pub fn eat_at_restaurant() {
    add_to_waitlist();
}
#+END_SRC

Although this accomplished the same task the former is the idiomatic way to
bring a function into scope with ~use~. Bringing the function’s parent module
into scope with ~use~ means we have to specify the parent module when calling
the function. Specifying the parent module when calling the function makes it
clear that the function isn’t locally defined while still minimizing repetition
of the full path.

On the other hand, when bringing in structs, enums, and other items with ~use~,
it’s idiomatic to specify the full path. E.g.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
#+END_SRC

*** Providing new names with the ~as~ keyword

In some cases you may try to bring two types of the same name with the ~use~
keyword. We can use the ~as~ keyword to give the type a new local name, or
/alias/.

#+BEGIN_SRC rust :noeval
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
#+END_SRC

In the second ~use~ statement, we chose the new name ~IoResult~ for the
~std::io::Result~ type, which won’t conflict with the ~Result~ from ~std::fmt~
that we’ve also brought into scope.

*** Re-exporting names with ~pub use~

When we bring a name into scope with the ~use~ keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that code’s scope, we can combine ~pub~
and ~use~. This technique is called /re-exporting/ because we’re bringing an
item into scope but also making that item available for others to bring into
their scope.

#+BEGIN_SRC rust :results output
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+END_SRC

Before this change, external code would have to call the ~add_to_waitlist~
function by using the path ~restaurant::front_of_house::hosting::add_to_waitlist()~.
Now that this ~pub use~ has re-exported the ~hosting~ module from the root
module, external code can now use the path ~restaurant::hosting::add_to_waitlist()~
instead.

With ~pub use~, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.

*** Using external packages

In the guessing game we developed earlier ([[file:002_guessing_game][002_guessing_game]]) we used an
external package called ~rand~ to get random numbers. To use ~rand~ in our
project, we added this line to ~Cargo.toml~:

#+BEGIN_SRC toml
rand = "0.8.5"
#+END_SRC

Adding ~rand~ as a dependency in ~Cargo.toml~ tells Cargo to download the ~rand~
package and any dependencies from [[crates.io]] and make ~rand~ available to our
project.

Then, to bring ~rand~ definitions into the scope of our package, we added a
~use~ line starting with the name of the crate, ~rand~, and listed the items we
wanted to bring into scope. In the code block below we bring the ~Rng~ trait
into scope and call the ~rand::thread_rng~ function:

#+BEGIN_SRC rust :noeval
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
#+END_SRC

Members of the Rust community have made many packages available at [[crates.io]],
and pulling any of them into your package involves these same steps: listing
them in your package’s ~Cargo.toml~ file and using ~use~ to bring items from
their crates into scope.

Note that the standard ~std~ library is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change ~Cargo.toml~ to include ~std~. But we do need to refer to
it with ~use~ to bring items from there into our package’s scope. For example,
with ~HashMap~ we would use this line:

#+BEGIN_SRC rust :results output
use std::collections::HashMap;
#+END_SRC

This is an absolute path starting with ~std~, the name of the standard library
crate.

*** Using nested paths to clean up large ~use~ lists

Instead of bringing multiple items into scope in multiple lines like this:

#+BEGIN_SRC rust :results output
use std::cmp::Ordering;
use std::io;
#+END_SRC

We can use nested paths to bring the same items into scope in one line. We do
this by specifying the common part of the path, followed by two colons, and then
curly brackets around a list of the parts of the paths that differ:

#+BEGIN_SRC rust :results output
use std::{cmp::Ordering, io};
#+END_SRC

We can use a nested path at any level in a path, which is useful when combining
two ~use~ statements that share a subpath. E.g.

#+BEGIN_SRC rust :results output
use std::io;
use std::io::Write;
#+END_SRC

The common part of these two paths is ~std::io~, and that’s the complete first
path. To merge these two paths into one ~use~ statement, we can use ~self~ in
the nested path:

#+BEGIN_SRC rust :results output
use std::io::{self, Write};
#+END_SRC

*** The glob operator

If we want to bring /all/ public items defined in a path into scope, we can
specify that path followed by the ~*~ glob operator:

#+BEGIN_SRC rust :results output
use std::collections::*;
#+END_SRC

** Separating modules into different files

When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.

Note that you only need to load a file using a ~mod~ declaration /once/ in your
module tree. Once the compiler knows the file is part of the project (and knows
where in the module tree the code resides because of where you’ve put the ~mod~
statement), other files in your project should refer to the loaded file’s code
using a path to where it was declared. In other words, ~mod~ is not an "include"
operation.

#+BEGIN_SRC rust :noeval
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+END_SRC

This single file has been divided into multiple files (one module per file) in
[[file:005_restaurant][005_restaurant]]. The files are structured like this:

#+BEGIN_SRC
restaurant
├── Cargo.toml
├── Cargo.lock
└── src
    ├── lib.rs
    ├── front_of_house.rs
    └── front_of_house
        └── hosting.rs
#+END_SRC

We’ve moved each module’s code to a separate file, and the module tree remains
the same. The function calls in ~eat_at_restaurant~ will work without any
modification, even though the definitions live in different files.

Note that the ~pub use crate::front_of_house::hosting~ statement in ~src/lib.rs~
also hasn’t changed. The ~mod~ keyword declares modules, and Rust looks in a
file with the same name as the module for the code that goes into that module.

*** Alternate file paths

For a module named ~front_of_house~ declared in the crate root, the compiler
will look for the module’s code in:

- ~src/front_of_house/hosting.rs~
- ~src/front_of_house/hosting/mod.rs~ (older style, still supported path)

For a module named ~hosting~ that is a submodule of ~front_of_house~, the
compiler will look for the module’s code in:

- ~src/front_of_house/hosting.rs~
- ~src/front_of_house/hosting/mod.rs~ (older style, still supported path)

If you use both styles for the same module, you’ll get a compiler error. Using a
mix of both styles for different modules in the same project is allowed, but
might be confusing for people navigating your project.

The main downside to the style that uses files named ~mod.rs~ is that your
project can end up with many files named ~mod.rs~, which can get confusing when
you have them open in your editor at the same time.

* Common collection

We won't mention all collections from the standard library in this section. But
unlike the built-in array and tuple types (that also can store multiple values),
the data these collections point to is stored on the heap, which means the
amount of data does not need to be known at compile time and can grow or shrink
as the program runs.

To learn about the other kinds of collections provided by the standard library,
see [[https://doc.rust-lang.org/std/collections/index.html][the documentation]].

** Vectors

The type ~Vec<T>~, also known as a /vector/, acts like an ~ArrayList<T>~ in
Java.

*** Creating a new vector

To create a new empty vector, we call the ~Vec::new~ function:

#+BEGIN_SRC rust :results output
let v: Vec<i32> = Vec::new();
#+END_SRC

Since we aren’t inserting any values into this vector, we added a type
annotation, otherwise Rust wouldn't know what kind of elements we intend to
store. In this case we’ve told Rust that the ~Vec<T>~ in ~v~ will hold elements
of the ~i32~ type.

You can also create a ~Vec<T>~ with initial values and Rust will infer the type
of value you want to store. Rust provides the ~vec!~ macro, which will create a
new vector that holds the values you give it.

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3];
#+END_SRC

The code block above creates a new ~Vec<i32>~ that holds the values ~1~, ~2~,
and ~3~. The integer type is ~i32~ because that’s the default integer type.

*** Updating a vector

To create a vector and then add elements to it, we can use the ~push~ method:

#+BEGIN_SRC rust :results output
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#+END_SRC

As with any variable, if we want to be able to change its value, we need to make
it mutable using the ~mut~ keyword. The numbers we place inside are all of type
~i32~, and Rust infers this from the data, so we don’t need the ~Vec<i32>~
annotation.

*** Reading elements of vectors

There are two ways to reference a value stored in a vector: via indexing or
using the ~get~ method.

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2]; // Type annotation not needed here
println!("The third element is {third}");

let third: i32 = v[2]; // This is allowed since i32 implements the Copy trait so ownership is not transferred
println!("The third element is {third}");

let third: Option<&i32> = v.get(2); // Type annotation not needed here
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
#+END_SRC

Using ~&~ and ~[]~ gives us a reference to the element at the index value. When
we use the ~get~ method with the index passed as an argument, we get an
~Option<&T>~ that we can use with ~match~.

The difference with using indexing or the ~get~ method is what happens when we
index outside the array (and the return type of course):

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3, 4, 5];
let _does_not_exist = &v[100];
#+END_SRC

The code above panics because it references a nonexistent element. This method
is best used when you want your program to crash if there’s an attempt to access
an element past the end of the vector.

#+BEGIN_SRC rust :results output
let v = vec![1, 2, 3, 4, 5];
let _does_not_exist = v.get(100);
#+END_SRC

When the ~get~ method is passed an index that is outside the vector, it returns
~None~ without panicking. Your code will have logic to handle having either
~Some(&element)~ or ~None~.

When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules to ensure this reference and any other references
to the contents of the vector remain valid. Recall the rule that states you
can’t have mutable and immutable references in the same scope.

#+BEGIN_SRC rust :results output
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6); // Code will work by placing this line last
println!("The first element is: {first}");
#+END_SRC

This code won't compile. We hold an immutable reference to the first element in
a vector and try to add an element to the end. It might look like it should
work: why should a reference to the first element care about changes at the end
of the vector? This error is due to the way vectors work: because vectors put
the values next to each other in memory, adding a new element onto the end of
the vector might require allocating new memory and copying the old elements to
the new space, if there isn’t enough room to put all the elements next to each
other where the vector is currently stored. In that case, the reference to the
first element would be pointing to deallocated memory. The borrowing rules
prevent programs from ending up in that situation.

*** Iterating over the values in a vector

To access each element in a vector in turn, we would iterate through all of the
elements rather than use indices to access one at a time. The code block below
shows how to use a ~for~ loop to get immutable references to each element in a
vector of ~i32~ values and print them.

#+BEGIN_SRC rust :results output
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
#+END_SRC

We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The example below adds ~50~ to
each element.

#+BEGIN_SRC rust :results output
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
for i in &v {
    println!("{i}");
}
#+END_SRC

To change the value that the mutable reference refers to, we have to use the ~*~
dereference operator to get to the value in ~i~ before we can use the ~+=~
operator.

*** Using an enum to store multiple types

Vectors can only store values that are the same type. Fortunately, the variants
of an enum are defined under the same enum type, so when we need one type to
represent elements of different types, we can define and use an enum. E.g.:

#+BEGIN_SRC rust :results output
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
#+END_SRC

Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. We
must also be explicit about what types are allowed in this vector. If Rust
allowed a vector to hold any type, there would be a chance that one or more of
the types would cause errors with the operations performed on the elements of
the vector. Using an enum plus a ~match~ expression means that Rust will ensure
at compile time that every possible case is handled.

*** Dropping a vector drops its elements

Like any other ~struct~, a vector is freed when it goes out of scope. When the
vector gets dropped, all of its contents are also dropped. The borrow checker
ensures that any references to contents of a vector are only used while the
vector itself is valid.

** Strings

Strings in Rust are more complicated than other languages for three reasons:

- Rust's propensity for exposing possible errors
- Strings being a more complicated data structure than many programmers give
  them credit for, and
- UTF-8

We discuss strings in the context of collections because strings are implemented
as a collection of bytes, plus some methods to provide useful functionality when
those bytes are interpreted as text.

Rust has only one string type in the core language, which is the string slice
~str~ that is usually seen in its borrowed form ~&str~. String literals, for
example, are stored in the program’s binary and are therefore string slices.

The ~String~ type, which is provided by Rust's standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. Both ~String~ and string slices are used heavily in Rust’s standard
library, and are both UTF-8 encoded.

*** Creating a new string

Many of the same operations available with ~Vec<T>~ are available with ~String~
as well, because ~String~ is actually implemented as a wrapper around a vector
of bytes with some extra guarantees, restrictions, and capabilities.

This is how you create an empty ~String~:

#+BEGIN_SRC rust :results output
let mut s = String::new();
#+END_SRC

We can load data into this mutable ~String~. Often, we have some initial data
that we want to start the string with. For that, we use the ~to_string~ method,
which is available on any type that implements the ~Display~ trait, as string
literals do.

#+BEGIN_SRC rust :results output
let data = "initial contents";
let s = data.to_string();
// the method also works on a literal directly:
let s = "initial contents".to_string();
#+END_SRC

We can also use the function ~String::from~ to create a ~String~ from a string
literal. This code is equivalent to using the ~to_string~ method:

#+BEGIN_SRC rust :results output
let s = String::from("initial contents");
#+END_SRC

Since strings are UTF-8 encoded we can include any properly encoded data in
them:

#+BEGIN_SRC rust :results output
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
#+END_SRC

*** Updating a string

We can grow a ~String~ by using the ~push_str~ method to append a string slice:

#+BEGIN_SRC rust :results output
let mut s = String::from("foo");
s.push_str("bar");
println!("{s}")
#+END_SRC

The ~push_str~ method takes a string slice because we don’t necessarily want to
take ownership of the parameter. So in the example below we can still use ~s2~
after the call to ~push_str~:

#+BEGIN_SRC rust :results output
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s1 is {s1}");
println!("s2 is {s2}");
#+END_SRC

To add a character instead of a string slice you can use the ~push~ method:

#+BEGIN_SRC rust :results output
let mut s = String::from("lo");
s.push('l');
println!("{s}")
#+END_SRC

**** Concatenation with the ~+~ operator or the ~format!~ macro

Often, you’ll want to combine two existing strings. One way to do so is to use
the ~+~ operator:

#+BEGIN_SRC rust :results output
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
println!("{s3}")
#+END_SRC

The reason ~s1~ is no longer valid after the addition, and the reason we used a
reference to ~s2~, has to do with the signature of the method that’s called when
we use the ~+~ operator. The ~+~ operator uses the ~add~ method, whose signature
looks something like this:

#+BEGIN_SRC rust :noeval
fn add(self, s: &str) -> String {
#+END_SRC

The reason why the code above works even though we called ~+~ with a ~&String~
instead of ~&str~ is that the compiler can /coerce/ the ~&String~ argument into
a ~&str~. Because ~add~ does not take ownership of the ~s~ parameter, ~s2~ will
still be a valid ~String~ after this operation.

If we need to concatenate multiple strings, the behavior of the ~+~ operator
gets unwieldy:

#+BEGIN_SRC rust :results output
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = s1 + "-" + &s2 + "-" + &s3;
println!("{s}");
println!("{s2}"); // Still valid
println!("{s3}"); // Still valid
#+END_SRC

For more complicated string combining, we can instead use the ~format!~ macro:

#+BEGIN_SRC rust :results output
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{s1}-{s2}-{s3}");
println!("{s}");
println!("{s1}"); // All variables still valid
println!("{s2}");
println!("{s3}");
#+END_SRC

The ~format!~ macro works like ~println!~, but instead of printing the output to
the screen, it returns a ~String~ with the contents. The ~format!~ macro uses
references so that this call doesn’t take ownership of any of its parameters.

*** Indexing into strings

If you try to access parts of a ~String~ using indexing syntax in Rust, you’ll
get an error:

#+BEGIN_SRC rust :results output
let s1 = String::from("hello");
let h = s1[0];
#+END_SRC

Because the way a ~String~ is represented internally (UTF-8 character) it's not
suitable to allow indexing.

Another reason Rust doesn’t allow us to index into a ~String~ to get a character
is that indexing operations are expected to always take constant time (O(1)).
But it isn’t possible to guarantee that performance with a ~String~, because
Rust would have to walk through the contents from the beginning to the index to
determine how many valid characters there were.

*** Slicing strings

You can slice a string like this:

#+BEGIN_SRC rust :results output
let hello = "Здравствуйте";
let s = &hello[0..4];
println!("{s}");
#+END_SRC

Note that only the 2 first characters was returned. That is because you index on
the bytes and in this case the first 2 characters are represented internally by
4 bytes.

If we were to try to slice only part of a character’s bytes with something like
~&hello[0..3]~, Rust would panic at runtime in the same way as if an invalid
index were accessed in a vector:

#+BEGIN_SRC rust :results output
let hello = "Здравствуйте";
let s = &hello[0..3];
println!("{s}");
#+END_SRC

You should use ranges to create string slices with caution, because doing so can
crash your program.

*** Iterating over a string

The best way to operate on pieces of strings is to be explicit about whether you
want characters or bytes. For individual Unicode scalar values, use the ~chars~
method. Calling ~chars~ on "Здр" separates out and returns three values of type
~char~, and you can iterate over the result to access each element:

#+BEGIN_SRC rust :results output
for c in "Здр".chars() {
    println!("{c}");
}
#+END_SRC

The ~bytes~ method returns each raw byte:

#+BEGIN_SRC rust :results output
for b in "Здр".bytes() {
    println!("{b}");
}
#+END_SRC

** Hash maps

The type ~HashMap<K, V>~ stores a mapping of keys of type ~K~ to values of type
~V~ using a hashing function, which determines how it places these keys and
values into memory.

*** Creating a new hash map

One way to create an empty hash map is using ~new~ and adding elements with
~insert~.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
#+END_SRC

Note that we need to first ~use~ the ~HashMap~ from the collections portion of
the standard library. It's not included in the features brought into scope
automatically in the prelude.

Like vectors, hash maps are homogeneous: all of the keys must have the same type
as each other, and all of the values must have the same type.

*** Accessing values

We can get a value out of the hash map by providing its key to the ~get~ method:

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
// This seems to work as well
//let score = scores.get(&team_name).unwrap_or(&0);

println!("{score}")
#+END_SRC

The ~get~ method returns an ~Option<&V>~; if there’s no value for that key in
the hash map, get will return ~None~. This program handles the ~Option~ by
calling ~copied~ to get an ~Option<i32>~ rather than an ~Option<&i32>~, then
~unwrap_or~ to set ~score~ to zero if ~scores~ doesn't have an entry for the
key.

We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a ~for~ loop:

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
#+END_SRC

*** Ownership

For types that implement the ~Copy~ trait, like ~i32~, the values are copied
into the hash map. For owned values like ~String~, the values will be moved and
the hash map will be the owner of those values.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
#+END_SRC

If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid.

*** Updating a hash map

When you want to change the data in a hash map, you have to decide how to handle
the case when a key already has a value assigned.

**** Overwriting a value

If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
#+END_SRC

**** Adding a key and value only if a key isn’t present

Hash maps have a special API called ~entry~ that takes the key you want to check
as a parameter. The return value of the ~entry~ method is an enum called ~Entry~
that represents a value that might or might not exist. Let’s say we want to
check whether the key for the ~Yellow~ team has a value associated with it. If
it doesn’t, we want to insert the value ~50~, and the same for the ~Blue~ team.

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
#+END_SRC

The ~or_insert~ method on ~Entry~ is defined to return a mutable reference to
the value for the corresponding ~Entry~ key if that key exists, and if not,
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.

**** Updating a value based on the old value

#+BEGIN_SRC rust :results output
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
#+END_SRC

The ~split_whitespace~ method returns an iterator over sub-slices, separated by
whitespace, of the value in ~text~. The ~or_insert~ method returns a mutable
reference (~&mut V~) to the value for the specified key. Here we store that
mutable reference in the ~count~ variable, so in order to assign to that value,
we must first dereference ~count~ using the asterisk (~*~). The mutable
reference goes out of scope at the end of the ~for~ loop, so all of these
changes are safe and allowed by the borrowing rules.

* Error handling

In many cases, Rust requires you to acknowledge the possibility of an error and
take some action before your code will compile. This requirement makes your
program more robust by ensuring that you’ll discover errors and handle them
appropriately before you’ve deployed your code to production.

Rust groups errors into two major categories: /recoverable/ and /unrecoverable/
errors.

** Unrecoverable Errors with ~panic!~

When a program panics it will print a failure message, unwind, clean up the
stack, and quit. Via an environment variable, you can also have Rust display the
call stack when a panic occurs to make it easier to track down the source of the
panic.

To make a program panic you can use the ~panic!~ macro

#+BEGIN_SRC rust :results output
fn main() {
    panic!("crash and burn");
}
#+END_SRC

*** Using a ~panic!~ backtrace

The following command will panic:

#+BEGIN_SRC rust :results output
fn main() {
    let v = vec![1, 2, 3];
    v[99];
}
#+END_SRC

The output will look something like this:

#+BEGIN_SRC
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', rust-src-f1BHax.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+END_SRC

It only reveals which line in our code that makes a call to a function that
panics. The next note line tells us that we can set the ~RUST_BACKTRACE~
environment variable to get a backtrace of exactly what happened to cause the
error. Then it will look something like this:

#+BEGIN_SRC
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:250:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/alloc/src/vec/mod.rs:2628:9
   6: panic::main                    <---- The project was named panic
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
#+END_SRC

In order to get backtraces with this information, debug symbols must be enabled.
Debug symbols are enabled by default when using ~cargo build~ or ~cargo run~
without the ~--release~ flag.

** Recoverable Errors with ~Result~

For recoverable errors we use the ~Result~ enum instead of causing the program
to panic.

#+BEGIN_SRC rust :results output
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+END_SRC

Because ~Result~ has the generic type parameters ~<T, E>~, we can use the
~Result~ type and the functions defined on it in many different situations where
the successful value and error value we want to return may differ.

The ~File::open~ function will return a ~Result<std::fs::File, std::io::Error>~:

#+BEGIN_SRC rust :results output
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
#+END_SRC

Like the ~Option~ enum, the ~Result~ enum and its variants have been brought
into scope by the prelude, so we don’t need to specify ~Result::~ before the
~Ok~ and ~Err~ variants in the match arms.

*** Matching on different errors

Sometimes we want to take different actions for different failure reasons. If
~File::open~ failed because the file doesn’t exist, we want to create the file
and return the handle to the new file. If ~File::open~ failed for any other
reason we still want the code to ~panic!~.

#+BEGIN_SRC rust :results output
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");
    // Try open a file with no read permissions to see what happens
    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
#+END_SRC

The type of the value that ~File::open~ returns inside the ~Err~ variant is
~io::Error~, which is a struct provided by the standard library. This struct has
a method ~kind~ that we can call to get an ~io::ErrorKind~ value.

**** Alternatives to using ~match~ with ~Result<T, E>~

You can also use closures (more about that later), which are used with many of
the methods defined on ~Result<T, E>~. Here’s another way to write the same
logic as shown in the previous example, this time using closures and the
~unwrap_or_else~ method:

#+BEGIN_SRC rust :results output
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
#+END_SRC

*** Getting the value or panic using ~unwrap~ and ~expect~

If the ~Result~ value is the ~Ok~ variant, ~unwrap~ will return the value inside
the ~Ok~. If the ~Result~ is the ~Err~ variant, ~unwrap~ will call the ~panic!~
macro for us.

#+BEGIN_SRC rust :results output
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
#+END_SRC

Similarly, the ~expect~ method lets us also choose the ~panic!~ error message.
Using ~expect~ instead of ~unwrap~ and providing good error messages can convey
your intent and make tracking down the source of a panic easier.

#+BEGIN_SRC rust :results output
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
#+END_SRC

*** Propagating errors

Instead of handling the error within the function itself, you can return the
error to the calling code.

#+BEGIN_SRC rust :noeval
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
#+END_SRC

If this function succeeds without any problems, the code that calls this
function will receive an ~Ok~ value that holds a ~String~ - the username that
this function read from the file. Both the ~File::open~ function and the
~read_to_string~ method has the error type ~io::Error~ which makes that type
suitable for our function as well. So in the code block above we can see that we
return errors early to the caller if anything fails. Remember that we don't need
to explicitly say ~return~ when the error is the last expression.

The code that calls this code will then handle getting either an ~Ok~ value that
contains a username or an ~Err~ value that contains an ~io::Error~.

**** A shortcut for propagating errors: the ~?~ operator

This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator ~?~ to make this easier.

Let's rewrite the previous code using the ~?~ operator:

#+BEGIN_SRC rust :noeval
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
#+END_SRC

The ~?~ placed after a ~Result~ value is defined to work in almost the same way
as the ~match~ expressions we defined to handle the ~Result~ values before. If
the value of the ~Result~ is an ~Ok~, the value inside the ~Ok~ will get
returned from this expression, and the program will continue. If the value is an
~Err~, the ~Err~ will be returned from the whole function as if we had used the
~return~ keyword so the error value gets propagated to the calling code.

There is a difference between what the ~match~ expression does and what the ~?~
operator does: error values that have the ~?~ operator called on them go through
the ~from~ function, defined in the ~From~ trait in the standard library, which
is used to convert values from one type into another. When the ~?~ operator
calls the ~from~ function, the error type received is converted into the error
type defined in the return type of the current function. This is useful when a
function returns one error type to represent all the ways a function might fail,
even if parts might fail for many different reasons.

For example, we could change the ~read_username_from_file~ function in to return
a custom error type named ~OurError~ that we define. If we also define
~impl From<io::Error> for OurError~ to construct an instance of ~OurError~ from
an ~io::Error~, then the ~?~ operator calls in the body of
~read_username_from_file~ will call ~from~ and convert the error types without
needing to add any more code to the function.

We could actually write an even shorter version of the code above by chaining
method calls immediately after the ~?~:

#+BEGIN_SRC rust :noeval
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
#+END_SRC

Since this is a fairly common operation to read a file into a ~String~, the
standard library provides the convenient ~fs::read_to_string~ function that
opens the file, creates a new ~String~, reads the contents of the file, puts the
contents into that ~String~, and returns it.

#+BEGIN_SRC rust :results output
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
#+END_SRC

**** Where the ~?~ operator can be used

The ~?~ operator can only be used in functions whose return type is compatible
with the value the ~?~ is used on. In addition to that it can only be used in a
function returning a ~Result~, ~Option~, or another type that implements
~FromResidual~.

The behavior of the ~?~ operator when called on an ~Option<T>~ is similar to its
behavior when called on a ~Result<T, E>~: if the value is ~None~, the ~None~
will be returned early from the function at that point. If the value is ~Some~,
the value inside the ~Some~ is the resulting value of the expression and the
function continues. E.g.:

#+BEGIN_SRC rust :noeval
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
#+END_SRC

This code takes the ~text~ string slice argument and calls the ~lines~ method on
it, which returns an iterator over the lines in the string. Because this
function wants to examine the first line, it calls ~next~ on the iterator to get
the first value from the iterator. If ~text~ is the empty string, this call to
~next~ will return ~None~, in which case we use ~?~ to stop and return ~None~
from ~last_char_of_first_line~. If ~text~ is not the empty string, ~next~ will
return a ~Some~ value containing a string slice of the first line in text.

The ~?~ extracts the string slice, and we can call ~chars~ on that string slice
to get an iterator of its characters. We’re interested in the last character in
this first line, so we call ~last~ to return the last item in the iterator. This
is an ~Option~ because it’s possible that the first line is the empty string,
for example if ~text~ starts with a blank line but has characters on other
lines. The ~?~ operator in the middle gives us a concise way to express this
logic, allowing us to implement the function in one line.

So far, all the ~main~ functions we’ve used return ~()~. There are restrictions
on what its return type can be for the programs to behave as expected. ~main~
can also return a ~Result<(), E>~. E.g.:

#+BEGIN_SRC rust :results output
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;
    Ok(())
}
#+END_SRC

The ~Box<dyn Error>~ type is a /trait object/, which we’ll talk more about
later. For now, you can read ~Box<dyn Error>~ to mean "any kind of error".
Using ~?~ on a ~Result~ value in a ~main~ function with the error type
~Box<dyn Error>~ is allowed, because it allows any ~Err~ value to be returned
early.

When a ~main~ function returns a ~Result<(), E>~, the executable will exit with
a value of ~0~ if ~main~ returns ~Ok(())~ and will exit with a nonzero value if
~main~ returns an ~Err~ value. The ~main~ function may return any types that
implement the ~std::process::Termination~ trait, which contains a function
~report~ that returns an ~ExitCode~.

** Which one to use

When code panics, there’s no way to recover. You could call ~panic!~ for any
error situation, whether there’s a possible way to recover or not, but then
you’re making the decision that a situation is unrecoverable on behalf of the
calling code.

* Generic types, traits, and lifetimes
** Generic data type
*** In function definitions

When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.

#+BEGIN_SRC rust :results output
//fn largest<T>(list: &[T]) -> &T { // This won't work as we need to be able to
                                    // compare the elements in the slice. We
                                    // must add that T must support the PartialOrd
                                    // trait. More about traits soon
fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+END_SRC

*** In struct definitions

We can also define structs to use a generic type parameter in one or more fields
using the ~<>~ syntax.

#+BEGIN_SRC rust :results output
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
#+END_SRC

Note that because we’ve used only one generic type to define ~Point<T>~, this
definition says that the ~Point<T>~ struct is generic over some type ~T~, and
the fields ~x~ and ~y~ are both that same type, whatever that type may be. To
define a ~Point~ struct where ~x~ and ~y~ are both generics but could have
different types, we can use multiple generic type parameters.

#+BEGIN_SRC rust :results output
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+END_SRC

*** In enum definitions

As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the ~Option<T>~ enum that the standard
library provides:

#+BEGIN_SRC rust :results output
enum Option<T> {
    Some(T),
    None,
}
#+END_SRC

Enums can use multiple generic types as well. The definition of the ~Result~
enum is one example:

#+BEGIN_SRC rust :results output
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+END_SRC

*** In method definitions

We can implement methods on structs and enums and use generic types in their
definitions, too.

#+BEGIN_SRC rust :results output
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
#+END_SRC

Here, we’ve defined a method named ~x~ on ~Point<T>~ that returns a reference to
the data in the field ~x~.

Note that we have to declare ~T~ just after ~impl~ so we can use ~T~ to specify
that we’re implementing methods on the type ~Point<T>~. By declaring ~T~ as a
generic type after ~impl~, Rust can identify that the type in the angle brackets
in ~Point~ is a generic type rather than a concrete type. We could have chosen a
different name for this generic parameter than the generic parameter declared in
the struct definition, but using the same name is conventional.

We can also specify constraints on generic types when defining methods on the
type. We could, for example, implement methods only on ~Point<f32>~ instances
rather than on ~Point<T>~ instances with any generic type. In the example below
we use the concrete type ~f32~, meaning we don’t declare any types after ~impl~.

#+BEGIN_SRC rust :results output
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// My own example to see if different types can have different implementations
// This works
impl Point<char> {
    fn distance_from_origin(&self) -> u8 {
        0
    }
}

fn main() {
    let integer_point = Point { x: 5, y: 10 };
    println!("integer_point.x = {}", integer_point.x());
    // The following is not valid as distance_from_origin is only defined for Point<f32>
    //println!("integer_point.distance_from_origin() = {}", integer_point.distance_from_origin());

    let float_point = Point { x: 5.0, y: 10.0 };
    println!("float_point.x = {}", float_point.x());
    println!("float_point.distance_from_origin() = {}", float_point.distance_from_origin());

    let char_point = Point { x: 'a', y: 'b' };
    println!("char_point.x = {}", char_point.x());
    println!("char_point.distance_from_origin() = {}", char_point.distance_from_origin());
}
#+END_SRC

Generic type parameters in a struct definition aren’t always the same as those
you use in that same struct’s method signatures. The example below uses the
generic types ~X1~ and ~Y1~ for the ~Point~ struct and ~X2~ and ~Y2~ for the
~mixup~ method signature to make the example clearer. The method creates a new
~Point~ instance with the ~x~ value from the ~self~ ~Point~ (of type ~X1~) and
the ~y~ value from the passed-in ~Point~ (of type ~Y2~).

#+BEGIN_SRC rust :results output
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+END_SRC

The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with ~impl~ and some are declared with the method
definition. Here, the generic parameters ~X1~ and ~Y1~ are declared after ~impl~
because they go with the struct definition. The generic parameters ~X2~ and ~Y2~
are declared after ~fn mixup~, because they’re only relevant to the method.

*** Performance of code using generics

Using generics won't make your code run any slower. The compiler does the
opposite of the steps we used to create the generic code: the compiler looks at
all the places where generic code is called and generates code for the concrete
types the generic code is called with.

Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand.

** Traits: defining shared behavior

Traits are similar to a feature often called /interfaces/ in other languages,
(such as Java) although with some differences.

*** Defining a trait

Let’s say we have multiple structs that hold various kinds and amounts of text:
a ~NewsArticle~ and a ~Tweet~. We want to make a media aggregator library crate
that can display summaries of data that might be stored in a ~NewsArticle~ or
~Tweet~ instance. To do this, we need a summary from each type, and we’ll
request that summary by calling a ~summarize~ method on an instance. This code
shows the definition of a public ~Summary~ trait that expresses this behavior.

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize(&self) -> String;
}
#+END_SRC

Here, we declare a trait using the ~trait~ keyword and then the trait’s name,
which is ~Summary~ in this case. We’ve also declared the trait as ~pub~ so that
crates depending on this crate can make use of this trait too. Inside the curly
brackets, we declare the method signatures that describe the behaviors of the
types that implement this trait.

After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide its
own custom behavior for the body of the method.

A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.

*** Implementing a trait on a type

The following code block shows how to implement the ~Summary~ trait for our
~NewsArticle~ and ~Tweet~ structs.

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
#+END_SRC

Implementing a trait on a type is similar to implementing regular methods. The
difference is that after ~impl~, we put the trait name we want to implement,
then use the ~for~ keyword, and then specify the name of the type we want to
implement the trait for. Within the ~impl~ block, we put the method signatures
that the trait definition has defined. Instead of adding a semicolon after each
signature, we use curly brackets and fill in the method body with the specific
behavior that we want the methods of the trait to have for the particular type.

To call the trait methods you have to bring the trait into scope as well as the
types. E.g.

#+BEGIN_SRC rust :noeval
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+END_SRC

Other crates can also bring the ~Summary~ trait into scope to implement
~Summary~ on their own types. One restriction to note is that we can implement a
trait on a type only if at least one of the trait or the type is local to our
crate. But we can’t implement external traits on external types. For example, we
can’t implement the ~Display~ trait on ~Vec<T>~ within our crate. Without the
rule, two crates could implement the same trait for the same type, and Rust
wouldn’t know which implementation to use.

*** Default implementations

In the code block below we specify a default string for the ~summarize~ method
of the ~Summary~ trait instead of only defining the method signature.

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+END_SRC

To use a default implementation to summarize instances of ~NewsArticle~, we
specify an empty ~impl~ block with ~impl Summary for NewsArticle {}~. The syntax
for overriding a default implementation is the same as the syntax for
implementing a trait method that doesn’t have a default implementation.

Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify a
small part of it. For example, we could define the ~Summary~ trait to have a
~summarize_author~ method whose implementation is required, and then define a
~summarize~ method that has a default implementation that calls the
~summarize_author~ method:

#+BEGIN_SRC rust :results output
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
#+END_SRC

To use this version of ~Summary~, we only need to define ~summarize_author~ when
we implement the trait.

*** Traits as parameters

Let's define a ~notify~ function that calls the ~summarize~ method on its ~item~
parameter, which is of some type that implements the ~Summary~ trait. To do
this, we use the ~impl Trait~ syntax:

#+BEGIN_SRC rust :noeval
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+END_SRC

Instead of a concrete type for the ~item~ parameter, we specify the ~impl~
keyword and the trait name. This parameter accepts any type that implements the
specified trait.

**** Trait bound syntax

The ~impl Trait~ syntax works for straightforward cases but is actually syntax
sugar for a longer form known as a /trait bound/:

#+BEGIN_SRC rust :noeval
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+END_SRC

We place trait bounds with the declaration of the generic type parameter after a
colon and inside angle brackets.

We can have two parameters that implement ~Summary~. Doing so with the
~impl Trait~ syntax looks like this:

#+BEGIN_SRC rust :noeval
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
#+END_SRC

In this case ~item1~ and ~item2~ may be of different types as long as they both
implement the ~Summary~ trait. If we want to force both parameters to have the
same type, however, we must use a trait bound, like this:

#+BEGIN_SRC rust :noeval
pub fn notify<T: Summary>(item1: &T, item2: &T) {
#+END_SRC

In this case we define that ~item1~ and ~item2~ must be of the generic type ~T~
which will be a single type, hence ~item1~ and ~item2~ will be of the same type.

**** Specifying multiple trait bounds with the ~+~ syntax

We can also specify more than one trait bound. If we wanted ~notify~ to accept
an ~item~ that both implements the ~Display~ and ~Summary~ trait we can do that
the following way:

#+BEGIN_SRC rust :noeval
pub fn notify(item: &(impl Summary + Display)) {
#+END_SRC

This can also be done using the trait bound syntax:

#+BEGIN_SRC rust :results output
pub fn notify<T: Summary + Display>(item: &T) {
#+END_SRC

**** Clearer trait bounds with ~where~ clause

Rust has alternate syntax for specifying trait bounds inside a ~where~ clause
after the function signature. So instead of writing this:

#+BEGIN_SRC rust :noeval
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
#+END_SRC

you can write like this:

#+BEGIN_SRC rust :noeval
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
#+END_SRC

*** Returning types that implements traits

The ~impl Trait~ syntax can also be used for the return type

#+BEGIN_SRC rust :noeval
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
#+END_SRC

The function above returns some type that implements the ~Summary~ trait without
naming the concrete type. In this case, the function returns a ~Tweet~.

However, you can only use ~impl Trait~ if you’re returning a single type. For
example, a function that returns either a ~NewsArticle~ or a ~Tweet~ (based on
some condition) with the return type specified as ~impl Summary~ wouldn’t work.
This restriction exists due to how the ~impl Trait~ is implemented in compiler.

*** Using trait bounds to conditionally implement methods

By using a trait bound with an ~impl~ block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits.

#+BEGIN_SRC rust :results output
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

// Implemented for all Pairs
impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

// Only implemented for Pairs of Ts where T implements Display and PartialOrd
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
#+END_SRC

We can also conditionally implement a trait for any type that implements another
trait. Implementations of a trait on any type that satisfies the trait bounds
are called /blanket implementations/. For example, the standard library
implements the ~ToString~ trait on any type that implements the ~Display~ trait.
The ~impl~ block in the standard library looks similar to this code:

#+BEGIN_SRC rust :noeval
impl<T: Display> ToString for T {
    // --snip--
}
#+END_SRC

This means that we can call the ~to_string~ method defined by the ~ToString~
trait on any type that implements the ~Display~ trait. For example, we can turn
integers into their corresponding ~String~ values like this because integers
implement ~Display~:

#+BEGIN_SRC rust :results output
let s = 3.to_string();
#+END_SRC

** Validating References with Lifetimes

Lifetimes are another kind of generic that we’ve already been using. Rather than
ensuring that a type has the behavior we want, lifetimes ensure that references
are valid as long as we need them to be.

Every reference in Rust has a lifetime, which is the scope for which that
reference is valid. Most of the time, lifetimes are implicit and inferred. But
sometimes we must annotate lifetimes when the lifetimes of references could be
related in a few different ways.

*** The Borrow Checker

The following code won't compile:

#+BEGIN_SRC rust :results output
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
#+END_SRC

You can clearly see the the scope (or lifetime) of ~x~ (~'b~) is smaller than
the scope of ~r~ (~'a~). And ~r~ is holding a reference to a ~x~ which is out of
scope when it's being referred to, meaning that r actually holds a dangling
reference. This is not allowed in Rust.

The following code fixes that:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
}                         // --+-------+
#+END_SRC

Here, ~x~ has the lifetime ~'b~, which in this case is larger than ~'a~. This
means ~r~ can reference ~x~ because Rust knows that the reference in ~r~ will
always be valid while ~x~ is valid.

*** Generic Lifetimes in Functions

We’ll write a function that returns the longer of two string slices. This
function will take two string slices and return a single string slice:

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

This code looks correct but won't compile. The error text reveals that the
return type needs a generic lifetime parameter on it because Rust can’t tell
whether the reference being returned refers to ~x~ or ~y~ (and we don't know
that in the general case either).

Basically the borrow checker don't know how the lifetime of ~x~ and ~y~ relate
to the lifetime of the return value. The returned value can only live as long as
the value it is referencing.

*** Lifetime Annotation Syntax

Lifetime annotations don’t change how long any of the references live. Rather,
they describe the relationships of the lifetimes of multiple references to each
other without affecting the lifetimes. I see them as part of the contract of the
function.

The names of lifetime parameters must start with an apostrophe (~'~) and are
usually all lowercase and very short, like generic types. Most people use the
name ~'a~ for the first lifetime annotation. We place lifetime parameter
annotations after the ~&~ of a reference, using a space to separate the
annotation from the reference’s type. E.g.:

#+BEGIN_SRC rust :noeval
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
#+END_SRC

One lifetime annotation by itself doesn’t have much meaning because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other.

*** Lifetime Annotations in Function Signatures

To use lifetime annotations in function signatures, we need to declare the
generic /lifetime/ parameters inside angle brackets between the function name
and the parameter list, just as we did with generic /type/ parameters (after all
lifetime annotations is a type of generics).

The following code will compile and the lifetime parameter ~'a~ expresses the
following constraint: the returned reference will be valid as long as both the
parameters are valid.

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints.

In the example above both ~string1~ and ~string2~ scope ends after the
~println!~ expression so the program is valid. The following program is also
valid:

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

~string1~ has a larger lifetime but both lifetimes are still valid when the
~result~ variable is printed.

The following program is not valid though:

#+BEGIN_SRC rust :results output
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

Even though as humans can see that ~string1~ is longer and is still valid at the
point where ~result~ is printed it still breaks the contract saying that the
lifetime of the reference returned by the ~longest~ function is the same as the
smaller of the lifetimes of the references passed in.

*** Thinking in Terms of Lifetimes

If we changed the implementation of the ~longest~ function to always return the
first parameter rather than the longest string slice, we wouldn’t need to
specify a lifetime on the ~y~ parameter.

When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does /not/ refer to one of the parameters, it must refer
to a value created within this function. However, this would be a dangling
reference because the value will go out of scope at the end of the function.
This is not allowed in Rust. One way to fix that would be to return an owned
data type rather than a reference so the calling function is then responsible
for cleaning up the value.

*** Lifetime Annotations in Struct Definitions

We can define structs to hold references, but in that case we would need to add
a lifetime annotation on every reference in the struct’s definition. E.g:

#+BEGIN_SRC rust :results output
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
#+END_SRC

As with generic data types, we declare the name of the generic lifetime
parameter inside angle brackets after the name of the struct so we can use the
lifetime parameter in the body of the struct definition. This annotation means
an instance of ~ImportantExcerpt~ can’t outlive the reference it holds in its
~part~ field.

In the example above the ~ImportantExcerpt~ struct that holds a reference to the
first sentence of the ~String~ owned by the variable ~novel~. ~novel~ doesn’t go
out of scope until after the ~ImportantExcerpt~ goes out of scope, so the
reference in the ~ImportantExcerpt~ instance is valid.

*** Lifetime Elision

How come the following program works even though we haven't defined any explicit
lifetimes?

#+BEGIN_SRC rust :results output
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

fn main() {
    let s = String::from("Hello world");
    let fw = first_word(&s);
    println!("{}", fw)
}
#+END_SRC

We could expect that the proper signature would look like this:

#+BEGIN_SRC rust :noeval
fn first_word<'a>(s: &'a str) -> &'a str {
#+END_SRC

This was the case in very early versions of Rust but some patterns have been
found to be predictable so this can be added automatically. These patterns are
known as /lifetime elision rules/ and they’re a set of particular cases that the
compiler will consider, and if your code fits these cases, you don’t need to
write the lifetimes explicitly. If there is still ambiguity as to what lifetimes
the references have after Rust applies the rules, the compiler will give you an
error that you can resolve by adding the lifetime annotations.

Lifetimes on function or method parameters are called /input lifetimes/, and
lifetimes on return values are called /output lifetimes/.

The compiler uses three rules to figure out the lifetimes of the references when
there aren’t explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it can’t
figure out lifetimes, the compiler will stop with an error. These rules apply to
~fn~ definitions as well as ~impl~ blocks. The rules are:

- The compiler assigns a lifetime parameter to each parameter that’s a
  reference. In other words, a function with one parameter gets one lifetime
  parameter: ~fn foo<'a>(x: &'a i32);~ a function with two parameters gets two
  separate lifetime parameters: ~fn foo<'a, 'b>(x: &'a i32, y: &'b i32);~ and so
  on.
- If there is exactly one input lifetime parameter, that lifetime is assigned to
  all output lifetime parameters: ~fn foo<'a>(x: &'a i32) -> &'a i32~.
- If there are multiple input lifetime parameters, but one of them is ~&self~ or
  ~&mut self~ because this is a method, the lifetime of ~self~ is assigned to
  all output lifetime parameters. This third rule makes methods much nicer to
  read and write because fewer symbols are necessary.

E.g.:

#+BEGIN_SRC rust :noeval
fn first_word(s: &str) -> &str {
#+END_SRC

Apply rule 1 and 2 and we get:

#+BEGIN_SRC rust :noeval
fn first_word<'a>(s: &'a str) -> &'a str {
#+END_SRC

Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.

Another example:

#+BEGIN_SRC rust :noeval
fn longest(x: &str, y: &str) -> &str {
#+END_SRC

We can apply rule 1 but rule 2 and 3 can't be applied so it becomes:

#+BEGIN_SRC rust :noeval
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
#+END_SRC

After working through all three rules, we still haven’t figured out what the
return type’s lifetime is. The compilation will fail and you will have to
provide lifetime annotations yourself.

*** Lifetime Annotations in Method Definitions

When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters.  Where we declare and use the lifetime
parameters depends on whether they’re related to the struct fields or the method
parameters and return values.

Lifetime names for struct fields always need to be declared after the ~impl~
keyword and then used after the struct’s name because those lifetimes are part
of the struct’s type.

#+BEGIN_SRC rust :results output
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
#+END_SRC

The lifetime parameter declaration after ~impl~ and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to ~self~ because of the first elision rule.

Here is an example where the third lifetime elision rule applies:

#+BEGIN_SRC rust :results output
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
#+END_SRC

There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both ~&self~ and ~announcement~ their own lifetimes. Then, because one
of the parameters is ~&self~, the return type gets the lifetime of ~&self~, and
all lifetimes have been accounted for.

*** The Static Lifetime

The special lifetime ~'static~ is a lifetime which denotes that the affected
reference /can/ live for the entire duration of the program. All string literals
have the ~'static~ lifetime, which we can annotate as follows:

#+BEGIN_SRC rust :noeval
let s: &'static str = "I have a static lifetime.";
#+END_SRC

The text of this string is stored directly in the program’s binary, which is
always available. Therefore, the lifetime of all string literals is ~'static~.

Most of the time, an error message suggesting the ~'static~ lifetime results
from attempting to create a dangling reference or a mismatch of the available
lifetimes. In such cases, the solution is to fix those problems, not to specify
the ~'static~ lifetime.

TODO: When do I use this myself or is it an implicit lifetime used?

*** Generic Type Parameters, Trait Bounds, and Lifetimes Together

Let's put everything together:

#+BEGIN_SRC rust :results output
use std::fmt::Display;

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        "Today is someone's birthday!",
    );
    println!("The longest string is {result}");
}

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+END_SRC

* Writing Automated Tests

A project with provided test is already available in the [[file:006_testing][006_testing directory]].

** How to Write Tests
*** The Anatomy of a Test Function

At its simplest, a test in Rust is a function that’s annotated with the ~test~
attribute. Attributes are metadata about pieces of Rust code. To change a
function into a test function, add ~#[test]~ on the line before ~fn~. When you
run your tests with the ~cargo test~ command, Rust builds a test runner binary
that runs the annotated functions and reports on whether each test function
passes or fails.

Whenever we make a new library project with Cargo (~cargo new proj_name --lib~),
a test module with a test function in it is automatically generated for us. The
code looks like this (comments added by me):

#+BEGIN_SRC rust :noeval
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    // This indicates that the function is a test. We can also add non test
    // functions
    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
#+END_SRC

The test can be run with ~cargo test~. The output is pretty self explanatory but
there is a section called ~Doc-tests proj_name~ and this is for the result for
documentation tests. Basically Rust can compile and test code examples that
appear in the API documentation (if we had documenation).

Tests fail when something in the test function panics. Each test is run in a new
thread, and when the main thread sees that a test thread has died, the test is
marked as failed. In the test result output, two new sections appear between the
individual results and the summary when a test fails. The first displays the
detailed reason for each test failure.  The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output.

*** Checking Results with the ~assert!~ macro

The ~assert!~ macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to ~true~. If the value is
~false~, the ~assert!~ macro calls ~panic!~ to cause the test to fail.

Used like:

#+BEGIN_SRC rust :noeval
assert!(larger.can_hold(&smaller));
#+END_SRC

*** Testing Equality with the ~assert_eq!~ and ~assert_ne!~ macros

Used like:

#+BEGIN_SRC rust :noeval
assert_eq!(4, add_two(2));
#+END_SRC

The order of arguments doesn't matter as they are just called ~left~ and ~right~
in Rust and not something like ~expected~ and ~actual~.

Under the surface, the ~assert_eq!~ and ~assert_ne!~ macros use the operators
~==~ and ~!=~, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the ~PartialEq~ and ~Debug~ traits. Because both traits are derivable
traits this is usually as straightforward as adding the
~#[derive(PartialEq, Debug)]~ annotation to your struct or enum definition.

*** Adding Custom Failure Messages

You can also add a custom message to be printed with the failure message as
optional arguments to the ~assert!~, ~assert_eq!~, and ~assert_ne!~ macros. Any
arguments specified after the required arguments are passed along to the
~format!~ macro, so you can pass a format string that contains ~{}~ placeholders
and values to go in those placeholders. E.g.

#+BEGIN_SRC rust :noeval
assert!(
    result.contains("Carol"),
    "Greeting did not contain name, value was `{}`",
    result
);
#+END_SRC

*** Checking for Panics with ~should_panic~

Adding the attribute ~should_panic~ to our test function. The test passes if the
code inside the function panics; the test fails if the code inside the function
doesn’t panic. E.g.

#+BEGIN_SRC rust :noeval
#[test]
#[should_panic]
fn greater_than_100() {
    Guess::new(200);
}
#+END_SRC

Tests that use ~should_panic~ can be imprecise. A ~should_panic~ test would pass
even if the test panics for a different reason from the one we were expecting.
To make ~should_panic~ tests more precise, we can add an optional ~expected~
parameter to the ~should_panic~ attribute. The test harness will make sure that
the failure message contains the provided text.

#+BEGIN_SRC rust :noeval
#[test]
#[should_panic(expected = "less than or equal to 100")]
fn greater_than_100() {
    Guess::new(200);
}
#+END_SRC

We could have specified the entire panic message that we expect, but what you
choose to specify depends on how much of the panic message is unique or dynamic
and how precise you want your test to be.

*** Using ~Result<T, E>~ in Tests

Our tests so far all panic when they fail. We can also write tests that use
~Result<T, E>~. E.g.

#+BEGIN_SRC rust :noeval
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
#+END_SRC

In the body of the function, rather than calling the ~assert_eq!~ macro, we
return ~Ok(())~ when the test passes and an ~Err~ with a ~String~ inside when
the test fails.

Writing tests so they return a ~Result<T, E>~ enables you to use the question
mark operator in the body of tests, which can be a convenient way to write tests
that should fail if any operation within them returns an ~Err~ variant.

You can’t use the ~#[should_panic]~ annotation on tests that use ~Result<T, E>~.
To assert that an operation returns an ~Err~ variant, don’t use the question
mark operator on the ~Result<T, E>~ value. Instead, use
~assert!(value.is_err())~.

** Controlling how tests are run

~cargo test~ compiles your code in test mode and runs the resulting test binary.
The default behavior of the binary produced by ~cargo test~ is to run all the
tests in parallel and capture output generated during test runs, preventing the
output from being displayed and making it easier to read the output related to
the test results.

Some command line options go to ~cargo test~, and some go to the resulting test
binary. To separate these two types of arguments, you list the arguments that go
to ~cargo test~ followed by the separator ~--~ and then the ones that go to the
test binary. Running ~cargo test --help~ displays the options you can use with
~cargo test~, and running ~cargo test -- --help~ displays the options you can
use after the separator.

*** Running Tests in Parallel or Consecutively

When you run multiple tests, by default they run in parallel using threads,
meaning they finish running faster and you get feedback quicker. Because the
tests are running at the same time, you must make sure your tests don’t depend
on each other or on any shared state, including a shared environment, such as
the current working directory or environment variables.

If you don’t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the ~--test-threads~ flag
and the number of threads you want to use to the test binary. E.g.

#+BEGIN_SRC bash :noeval
cargo test -- --test-threads=1
#+END_SRC

Running the tests using one thread will take longer than running them in
parallel, but the tests won’t interfere with each other if they share state.

*** Showing Function Output

By default, if a test passes, Rust’s test library captures anything printed to
standard output. For example, if we call ~println!~ in a test and the test
passes, we won’t see the ~println!~ output in the terminal; we’ll see only the
line that indicates the test passed. If a test fails, we’ll see whatever was
printed to standard output with the rest of the failure message.

If we want to see printed values for passing tests as well, we can tell Rust to
also show the output of successful tests with ~--show-output~.

#+BEGIN_SRC bash :noeval
cargo test -- --show-output
#+END_SRC

*** Running a Subset of Tests by Name

If you’re working on code in a particular area, you might want to run only the
tests pertaining to that code. You can choose which tests to run by passing
~cargo test~ the name or names of the test(s) you want to run as an argument.

If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel.

**** Running Single Tests

We can pass the name of any test function to cargo test to run only that test:

#+BEGIN_SRC bash :noeval
cargo test greater_than_100
#+END_SRC

We can’t specify the names of multiple tests in this way; only the first value
given to ~cargo test~ will be used.

**** Filtering to Run Multiple Tests

We can specify part of a test name, and any test whose name matches that value
will be run. Note that the module in which a test appears becomes part of the
test’s name, so we can run all the tests in a module by filtering on the
module’s name.

*** Ignoring Some Tests Unless Specifically Requested

You can ignore a test with the ~#[ignore]~ attribute:

#+BEGIN_SRC rust :noeval
#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
#+END_SRC

This test will now not be run unless specifically requested. If we want to run
only the ignored tests, we can use ~cargo test -- --ignored~. If you want to run
all tests whether they’re ignored or not, you can run
~cargo test -- --include-ignored~.

** Test Organization

The Rust community thinks about tests in terms of two main categories: unit
tests and integration tests. /Unit tests/ are small and more focused, testing
one module in isolation at a time, and can test private interfaces. /Integration
tests/ are entirely external to your library and use your code in the same way
any other external code would, using only the public interface and potentially
exercising multiple modules per test.

*** Unit Tests

You’ll put unit tests in the src directory in each file with the code that
they’re testing. The convention is to create a module named ~tests~ in each file
to contain the test functions and to annotate the module with ~cfg(test)~.

**** The Tests Module and #[cfg(test)]

The ~#[cfg(test)]~ annotation on the tests module tells Rust to compile and run
the test code only when you run ~cargo test~. Because unit tests go in the same
files as the code, you’ll use ~#[cfg(test)]~ to specify that they shouldn’t be
included in the compiled result.

The attribute ~cfg~ stands for /configuration/ and tells Rust that the following
item should only be included given a certain configuration option. In this case,
the configuration option is ~test~, which is provided by Rust for compiling and
running tests. By using the ~cfg~ attribute, Cargo compiles our test code only
if we actively run the tests with ~cargo test~.

**** Testing Private Functions

Rust’s privacy rules do allow you to test private functions. E.g.

#+BEGIN_SRC rust :noeval
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#+END_SRC

Note that the ~internal_adder~ function is not marked as ~pub~. Tests are just
Rust code, and the ~tests~ module is just another module. Items in child modules
can use the items in their ancestor modules. In this test, we bring all of the
~tests~ module’s parent’s items into scope with ~use super::*~, and then the
test can call ~internal_adder~.

*** Integration Tests

In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
whether many parts of your library work together correctly.

**** The /tests/ Directory

We create a /tests/ directory at the top level of our project directory, next to
/src/. Cargo knows to look for integration test files in this directory. We can
then make as many test files as we want, and Cargo will compile each of the
files as an individual crate.

Since each file in the ~tests~ directory is a separate crate, we need to bring
our library into each test crate’s scope. This is not needed when writing unit
tests of course. E.g.:

#+BEGIN_SRC rust :noeval
use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}
#+END_SRC

We don’t need to annotate any code in any integration tests file with
~#[cfg(test)]~. Cargo treats the ~tests~ directory specially and compiles files
in this directory only when we run ~cargo test~.

Running ~cargo test~ now you will see a new section for integration tests as
well. Note that if any test in a section fails, the following sections will not
be run. For example, if a unit test fails, there won’t be any output for
integration and doc tests because those tests will only be run if all unit tests
are passing.

Each integration test file has its own section, so if we add more files in the
~tests~ directory, there will be more integration test sections.

We can still run a particular integration test function by specifying the test
function’s name as an argument to ~cargo test~. To run all the tests in a
particular integration test file, use the ~--test~ argument of ~cargo test~
followed by the name of the file. To run all tests in
~tests/integration_test.rs~ you would run:

#+BEGIN_SRC bash :noveal
cargo test --test integration_test
#+END_SRC

**** Submodules in Integration Tests

As mentioned earlier, each file in the ~tests~ directory is compiled as its own
separate crate, which is useful for creating separate scopes to more closely
imitate the way end users will be using your crate. However, this means files in
the ~tests~ directory don’t share the same behavior as files in ~src~ do.

The different behavior of tests directory files is most noticeable when you have
a set of helper functions to use in multiple integration test files and you try
to extract them into a common module. When we run the tests again, we’ll see a
new section in the test output for the common module even though this file
doesn’t contain any test functions. This is not what we wanted.

To avoid having this module appear in the test output, instead of creating e.g.
/tests/common.rs/, we’ll create /tests/common/mod.rs/. This is the older naming
convention that Rust also understands. Files in subdirectories of the ~tests~
directory don’t get compiled as separate crates or have sections in the test
output.

After we’ve created /tests/common/mod.rs/, we can use it from any of the
integration test files as a module by defining it with ~mod common;~

**** Integration Tests for Binary Crates

If our project is a binary crate that only contains a ~src/main.rs~ file and
doesn’t have a ~src/lib.rs~ file, we can’t create integration tests in the
~tests~ directory and bring functions defined in the ~src/main.rs~ file into
scope with a ~use~ statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.

This is one of the reasons Rust projects that provide a binary have a
straightforward ~src/main.rs~ file that calls logic that lives in the
~src/lib.rs~ file. Using that structure, integration tests can test the library
crate with ~use~ to make the important functionality available. If the important
functionality works, the small amount of code in the ~src/main.rs~ file will
work as well, and that small amount of code doesn’t need to be tested.

* An I/O Project: Building a Command Line Program

In this section we will implement a command line tool called ~minigrep~. The
program is already available in [[file:007_minigrep][007_minigrep]].

** Accepting Command Line Arguments

Create the new project with:

#+BEGIN_SRC bash :results output
cargo new minigrep
#+END_SRC

*** Reading the Argument Values

To enable ~minigrep~ to read the values of command line arguments we pass to it,
we’ll need the ~std::env::args~ function provided in Rust’s standard library.
This function returns an iterator of the command line arguments passed to
~minigrep~. We can call the ~collect~ method on an iterator to turn it into a
collection, such as a vector, that contains all the elements the iterator
produces.

#+BEGIN_SRC rust :results output
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    dbg!(args);
    println!("{:?}", args); // Added by me so it can be printed in emacs
}
#+END_SRC

Notice that the ~std::env::args~ function is nested in two levels of modules. In
cases where the desired function is nested in more than one module, we’ve chosen
to bring the parent module into scope rather than the function. By doing so, we
can easily use other functions from ~std::env~. It’s also less ambiguous than
adding ~~use std::env::args~ and then calling the function with just ~args~,
because ~args~ might easily be mistaken for a function that’s defined in the
current module.

On the first line of ~main~, we call ~env::args~, and we immediately use
~collect~ to turn the iterator into a vector containing all the values produced
by the iterator. We can use the ~collect~ function to create many kinds of
collections, so we explicitly annotate the type of ~args~ to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, ~collect~ is one function you do often need to annotate because Rust isn’t
able to infer the kind of collection you want.

You can now run the program with:

#+BEGIN_SRC bash :noeval
cargo run -- needle haystack
#+END_SRC

It will print the name of the binary followed by ~needle~ and ~haystack~.

*** Saving the Argument Values in Variables

#+BEGIN_SRC rust :noeval
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let file_path = &args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}
#+END_SRC

As we saw when we printed the vector, the program’s name takes up the first
value in the vector at ~args[0]~, so we’re starting arguments at index ~1~.

** Reading a File

Now we’ll add functionality to read the file specified in the ~file_path~
argument. First, we need a sample file to test it with. A file called [[file:007_minigrep/minigrep/poem.txt][poem.txt]]
has already been created at the root of the project.

#+BEGIN_SRC rust :noeval
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let file_path = &args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}
#+END_SRC

First, we bring in a relevant part of the standard library with a ~use~
statement: we need ~std::fs~ to handle files.

In ~main~, the new statement ~fs::read_to_string~ takes the ~file_path~, opens
that file, and returns a ~std::io::Result<String>~ of the file’s contents.

Now run the program again and see what happens:

#+BEGIN_SRC bash :noeval
cargo run -- random_word poem.txt
#+END_SRC

** Refactoring to Improve Modularity and Error Handling
*** Separation of Concerns for Binary Projects

The organizational problem of allocating responsibility for multiple tasks to
the ~main~ function is common to many binary projects. As a result, the Rust
community has developed guidelines for splitting the separate concerns of a
binary program when ~main~ starts getting large. This process has the following
steps:

- Split your program into a ~main.rs~ and a ~lib.rs~ and move your program’s
  logic to ~lib.rs~.
- As long as your command line parsing logic is small, it can remain in
  ~main.rs~.
- When the command line parsing logic starts getting complicated, extract it
  from ~main.rs~ and move it to ~lib.rs~.

The responsibilities that remain in the ~main~ function after this process
should be limited to the following:

- Calling the command line parsing logic with the argument values
- Setting up any other configuration
- Calling a run function in ~lib.rs~
- Handling the error if ~run~ returns an error

This pattern is about separating concerns: ~main.rs~ handles running the
program, and ~lib.rs~ handles all the logic of the task at hand. Because you
can’t test the ~main~ function directly, this structure lets you test all of
your program’s logic by moving it into functions in ~lib.rs~. The code that
remains in ~main.rs~ will be small enough to verify its correctness by reading
it.

**** Extracting the Argument Parser

#+BEGIN_SRC rust :noeval
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, file_path) = parse_config(&args);

    println!("Searching for {query}");
    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let file_path = &args[2];

    (query, file_path)
}
#+END_SRC

We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index ~1~ to the variable ~query~ and the
argument value at index ~2~ to the variable ~file_path~ within the ~main~
function, we pass the whole vector to the ~parse_config~ function. The
~parse_config~ function then holds the logic that determines which argument goes
in which variable and passes the values back to ~main~.

**** Grouping Configuration Values

At the moment, we’re returning a tuple, but then we immediately break that tuple
into individual parts again. This is a sign that perhaps we don’t have the right
abstraction yet. We’ll instead put the two values into one struct and give each
of the struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.

#+BEGIN_SRC rust :noeval
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}
#+END_SRC

The signature of ~parse_config~ now indicates that it returns a ~Config~ value.
In the body of ~parse_config~, where we used to return string slices that
reference ~String~ values in ~args~, we now define ~Config~ to contain owned
~String~ values. The ~args~ variable in ~main~ is the owner of the argument
values and is only letting the ~parse_config~ function borrow them, which means
we’d violate Rust’s borrowing rules if ~Config~ tried to take ownership of the
values in ~args~.

There are a number of ways we could manage the ~String~ data; the easiest,
though somewhat inefficient, route is to call the ~clone~ method on the values.
This will make a full copy of the data for the ~Config~ instance to own, which
takes more time and memory than storing a reference to the string data. We don't
care about that right now.

**** Creating a Constructor for Config

The purpose of the ~parse_config~ function is to create a ~Config~ instance but
we can change ~parse_config~ from a plain function to a function named ~new~
that is associated with the ~Config~ struct. Making this change will make the
code more idiomatic. We can create instances of types in the standard library,
such as ~String~, by calling ~String::new~.

#+BEGIN_SRC rust :noeval
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

struct Config {
    query: String,
    file_path: String,
}

impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}
#+END_SRC

*** Fixing the Error Handling

If we run the command without any arguments the program will panic because we
are trying to read outside the arguments vector. The error message is not very
helpful for the user.

**** Improving the Error Message

Update ~Config::new~ so it panics with a better message if the input slice is
not long enough.

#+BEGIN_SRC rust :noeval
impl Config {
    fn new(args: &[String]) -> Config {
        if args.len() < 3 {
            panic!("not enough arguments");
        }
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}
#+END_SRC

But is still prints quite a lot of information. ~panic!~ is more appropriate for
a programming problem than a usage problem.

**** Returning a ~Result~ Instead of Calling ~panic!~

We can instead return a ~Result~ value that will contain a ~Config~ instance in
the successful case and will describe the problem in the error case. We’re also
going to change the function name from ~new~ to ~build~ because many programmers
expect ~new~ functions to never fail.

#+BEGIN_SRC rust :results output
use std::env;
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

struct Config {
    query: String,
    file_path: String,
}

impl Config {
    fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}
#+END_SRC

Using ~unwrap_or_else~ allows us to define some custom, non-~panic!~ error
handling. If the ~Result~ is an ~Ok~ value, this method’s behavior is similar to
~unwrap~: it returns the inner value ~Ok~ is wrapping. However, if the value is
an ~Err~ value, this method calls the code in the /closure/, which is an
anonymous function we define and pass as an argument to ~unwrap_or_else~.

*** Extracting Logic from ~main~

We’ll extract a function named ~run~ that will hold all the logic currently in
the ~main~ function that isn’t involved with setting up configuration or
handling errors. When we’re done, ~main~ will be concise and easy to verify by
inspection, and we’ll be able to write tests for all the other logic.

With the remaining program logic separated into the ~run~ function, we can
improve the error handling, as we did with ~Config::build~. Instead of allowing
the program to panic by calling ~expect~, the ~run~ function will return a
~Result<T, E>~ when something goes wrong.

#+BEGIN_SRC rust :results output
use std::env;
use std::error::Error;
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}

fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}

struct Config {
    query: String,
    file_path: String,
}

impl Config {
    fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}
#+END_SRC

We’ve made three significant changes here. First, we changed the return type of
the run function to ~Result<(), Box<dyn Error>>~. This function previously
returned the unit type, ~()~, and we keep that as the value returned in the ~Ok~
case.

For the error type, we used the /trait object/ ~Box<dyn Error>~ (more about
trait objects later). For now, just know that ~Box<dyn Error>~ means the
function will return a type that implements the ~Error~ trait, but we don’t have
to specify what particular type the return value will be. This gives us
flexibility to return error values that may be of different types in different
error cases. The ~dyn~ keyword is short for "dynamic".

Second, we’ve removed the call to ~expect~ in favor of the ~?~ operator.

Third, the ~run~ function now returns an ~Ok~ value in the success case. We’ve
declared the ~run~ function’s success type as ~()~ in the signature, which means
we need to wrap the unit type value in the ~Ok~ value. Using ~Ok(())~ like this
is the idiomatic way to indicate that we’re calling run for its side effects
only.

Then we use ~if let~ rather than ~unwrap_or_else~ to check whether ~run~ returns
an ~Err~ value and call ~process::exit(1)~ if it does. The ~run~ function
doesn’t return a value that we want to ~unwrap~ in the same way that
~Config::build~ returns the ~Config~ instance. Because run returns ~()~ in the
success case, we only care about detecting an error, so we don’t need
~unwrap_or_else~ to return the unwrapped value, which would only be ~()~.

The bodies of the ~if let~ and the ~unwrap_or_else~ functions are the same in
both cases: we print the error and exit.

*** Splitting Code into a Library Crate

Let’s move all the code that isn’t the ~main~ function from ~src/main.rs~ to
~src/lib.rs~:

- The ~run~ function definition
- The relevant ~use~ statements
- The definition of ~Config~
- The ~Config::build~ function definition

The ~src/lib.rs~ file will look like this:

#+BEGIN_SRC rust :noeval
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
#+END_SRC

Note how we have added the ~pub~ keyword to make the functions available for
the ~main.rs~ file.

The ~src/main.rs~ file will look like this:

#+BEGIN_SRC rust :noeval
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = minigrep::run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
#+END_SRC

** Writing the ~search~ function

Let's start with writing a failing test in the ~lib.rs~ file:

#+BEGIN_SRC rust :noeval
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
#+END_SRC

Then add a function that makes the test pass:

#+BEGIN_SRC rust :noeval
fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
#+END_SRC

Notice that we need to define an explicit lifetime ~'a~ in the signature of
~search~ and use that lifetime with the ~contents~ argument and the return
value. We indicate that the returned vector should contain string slices that
reference slices of the argument ~contents~ (rather than the argument ~query~).

In other words, we tell Rust that the data returned by the ~search~ function
will live as long as the data passed into the ~search~ function in the
~contents~ argument.

Now that the ~search~ function is working and tested, we need to call ~search~
from our run function. We need to pass the ~config.query~ value and the
~contents~ that ~run~ reads from the file to the ~search~ function.

#+BEGIN_SRC rust :noeval
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&config.query, &contents) {
        println!("{line}");
    }

    Ok(())
}
#+END_SRC

We’re still using a ~for~ loop to return each line from ~search~ and print it.

Run the test with:

#+BEGIN_SRC bash :noeval
cargo test
#+END_SRC

Then test the program:

#+BEGIN_SRC bash :noeval
cargo run -- frog poem.txt
cargo run -- body poem.txt
cargo run -- monomorphization poem.txt
#+END_SRC

** Working with Environment Variables

Now we will make it possible to do case-insensitive searching that the user can
turn on via an environment variable. Start with writing a failing test case:

#+BEGIN_SRC rust :noeval
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape."; // This line is new and should not be matched by case sensitive search

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}
#+END_SRC

Then we implement the new function:

#+BEGIN_SRC rust :noeval
pub fn search_case_insensitive<'a>(
    query: &str,
    contents: &'a str,
) -> Vec<&'a str> {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&query) {
            results.push(line);
        }
    }

    results
}
#+END_SRC

First, we lowercase the ~query~ string and store it in a shadowed variable with
the same name. Note that ~query~ is now a ~String~ rather than a string slice,
because calling ~to_lowercase~ creates new data rather than referencing existing
data. When we pass ~query~ as an argument to the ~contains~ method now, we need
to add an ampersand because the signature of ~contains~ is defined to take a
string slice.

Next, we add a call to ~to_lowercase~ on each ~line~ to lowercase all
characters.

Now, let’s call the new ~search_case_insensitive~ function from the ~run~
function. Update the ~Config~ struct:

#+BEGIN_SRC rust :noeval
pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
#+END_SRC

Then update ~run~ to check the variable:

#+BEGIN_SRC rust :noeval
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&config.query, &contents)
    } else {
        search(&config.query, &contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
#+END_SRC

Then we’ll use the ~var~ function from the ~env~ module to check if any value
has been set for an environment variable named ~IGNORE_CASE~ in the
~Config::build~ function:

#+BEGIN_SRC rust :noeval
use std::env;

impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
#+END_SRC

The ~env::var~ function returns a ~Result~ that will be the successful ~Ok~
variant that contains the value of the environment variable if the environment
variable is set to any value. It will return the ~Err~ variant if the
environment variable is not set. We don’t care about the value of the
environment variable, just whether it’s set or unset, so we’re checking ~is_ok~
rather than using ~unwrap~, ~expect~, or any of the other methods we’ve seen on
~Result~.

Test the program with:

#+BEGIN_SRC bash :noeval
IGNORE_CASE=1 cargo run -- to poem.txt
# and
cargo run -- to poem.txt
#+END_SRC

** Writing Error Messages to Standard Error Instead of Standard Output

At the moment, we’re writing all of our output to the terminal using the
~println!~ macro. All the code that prints error messages is in one function,
~main~. The standard library provides the ~eprintln!~ macro that prints to the
standard error stream, so let’s change the two places we were calling ~println!~
to print errors to use ~eprintln!~ instead.

#+BEGIN_SRC rust :noeval
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
#+END_SRC

* Functional Language Features: Iterators and Closures
** Closures: Anonymous Functions that Capture Their Environment

Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure elsewhere to evaluate it in a different context. Unlike
functions, closures can capture values from the scope in which they’re defined.
We’ll demonstrate how these closure features allow for code reuse and behavior
customization.

*** Capturing the Environment with Closures

#+BEGIN_SRC rust :results output
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked()) // <--- Closure here
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
#+END_SRC

The ~store~ defined in ~main~ has two blue shirts and one red shirt remaining to
distribute for this limited-edition promotion. We call the ~giveaway~ method for
a user with a preference for a red shirt and a user without any preference.

In the ~giveaway~ method, we get the user preference as a parameter of type
~Option<ShirtColor>~ and call the ~unwrap_or_else~ method on ~user_preference~.
It takes one argument: a closure without any arguments that returns a value ~T~
(the same type stored in the ~Some~ variant of the ~Option<T>~, in this case
~ShirtColor~). If the ~Option<T>~ is the ~Some~ variant, ~unwrap_or_else~
returns the value from within the ~Some~. If the ~Option<T>~ is the ~None~
variant, ~unwrap_or_else~ calls the closure and returns the value returned by
the closure.

We specify the closure expression ~|| self.most_stocked()~ as the argument to
~unwrap_or_else~. This is a closure that takes no parameters itself (if the
closure had parameters, they would appear between the two vertical bars). The
body of the closure calls ~self.most_stocked()~. We’re defining the closure
here, and the implementation of ~unwrap_or_else~ will evaluate the closure later
if the result is needed.

One interesting aspect here is that we’ve passed a closure that calls
~self.most_stocked()~ on the current ~Inventory~ instance. The standard library
didn’t need to know anything about the ~Inventory~ or ~ShirtColor~ types we
defined, or the logic we want to use in this scenario. The closure captures an
immutable reference to the ~self~ ~Inventory~ instance and passes it with the
code we specify to the ~unwrap_or_else~ method. Functions, on the other hand,
are not able to capture their environment in this way.

*** Closure Type Inference and Annotation

Closures don’t usually require you to annotate the types of the parameters or
the return value like ~fn~ functions do. Closures aren’t used in an exposed
interface like functions: they’re stored in variables and used without naming
them and exposing them to users of our library.

Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).

As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Here we’re defining a closure and storing it in a variable rather
than defining the closure in the spot we pass it as an argument:

#+BEGIN_SRC rust :noeval
let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
#+END_SRC

With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Compare these equivalent examples:

#+BEGIN_SRC rust :noeval
fn  add_one_v1   (x: u32) -> u32 { x + 1 }  // Function definition
let add_one_v2 = |x: u32| -> u32 { x + 1 }; // Fully annotated closure definition
let add_one_v3 = |x|             { x + 1 }; // Closure definition without type annotations
let add_one_v4 = |x|               x + 1  ; // Closure definition with removed brackets
                                            // which are optional when the body only has
                                            // one expression
#+END_SRC

The ~add_one_v3~ and ~add_one_v4~ lines require the closures to be evaluated to
be able to compile because the types will be inferred from their usage.

For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. The following example will not
compile. Note that we haven’t added any type annotations to the definition.
Because there are no type annotations, we can call the closure with any type,
which we’ve done here with ~String~ the first time. If we then try to call
~example_closure~ with an integer, we’ll get an error.

#+BEGIN_SRC rust :results output
fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
}
#+END_SRC

The first time we call ~example_closure~ with the ~String~ value, the compiler
infers the type of ~x~ and the return type of the closure to be ~String~. Those
types are then locked into the closure in ~example_closure~, and we get a type
error when we next try to use a different type with the same closure.

*** Capturing References or Moving Ownership

Closures can capture values from their environment in three ways, which directly
map to the three ways a function can take a parameter: borrowing immutably,
borrowing mutably, and taking ownership. The closure will decide which of these
to use based on what the body of the function does with the captured values.

Here we define a closure that captures an immutable reference to the vector
named ~list~ because it only needs an immutable reference to print the value:

#+BEGIN_SRC rust :results output
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows(); // Note how we call the variable as if it was a function
    println!("After calling closure: {list:?}");
}
#+END_SRC

Because we can have multiple immutable references to ~list~ at the same time,
~list~ is still accessible from the code before the closure definition, after
the closure definition but before the closure is called, and after the closure
is called.

We mpw change the closure body so that it adds an element to the ~list~ vector.
The closure now captures a mutable reference:

#+BEGIN_SRC rust :results output
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    // An immutable borrow to print isn’t allowed here because no other borrows
    // are allowed when there’s a mutable borrow.
    //println!("Before calling closure: {list:?}");

    borrows_mutably();
    // Here the mutable borrow has ended so we can borrow it immutable again
    println!("After calling closure: {list:?}");
}
#+END_SRC

If you want to force the closure to take ownership of the values it uses in the
environment even though the body of the closure doesn’t strictly need ownership,
you can use the ~move~ keyword before the parameter list. This technique is
mostly useful when passing a closure to a new thread to move the data so that
it’s owned by the new thread. E.g.:

#+BEGIN_SRC rust :results output
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}
#+END_SRC

In this example, even though the closure body still only needs an immutable
reference, we need to specify that ~list~ should be moved into the closure by
putting the ~move~ keyword at the beginning of the closure definition. The new
thread might finish before the rest of the main thread finishes, or the main
thread might finish first. If the main thread maintained ownership of ~list~ but
ended before the new thread did and dropped ~list~, the immutable reference in
the thread would be invalid. Therefore, the compiler requires that ~list~ be
moved into the closure given to the new thread so the reference will be valid.

*** Moving Captured Values Out of Closures and the ~Fn~ Traits

Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved into the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved out of the closure). A closure body can do
any of the following: move a captured value out of the closure, mutate the
captured value, neither move nor mutate the value, or capture nothing from the
environment to begin with.

The way a closure captures and handles values from the environment affects which
traits the closure implements, and traits are how functions and structs can
specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these ~Fn~ traits, in an additive fashion,
depending on how the closure’s body handles the values:

1. ~FnOnce~ applies to closures that can be called once. All closures implement
   at least this trait, because all closures can be called. A closure that moves
   captured values out of its body will only implement ~FnOnce~ and none of the
   other ~Fn~ traits, because it can only be called once.
2. ~FnMut~ applies to closures that don’t move captured values out of their
   body, but that might mutate the captured values. These closures can be called
   more than once.
3. ~Fn~ applies to closures that don’t move captured values out of their body
    and that don’t mutate captured values, as well as closures that capture
    nothing from their environment. These closures can be called more than once
    without mutating their environment, which is important in cases such as
    calling a closure multiple times concurrently.

Let’s look at the definition of the ~unwrap_or_else~ method on ~Option<T>~:

#+BEGIN_SRC rust :noeval
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
#+END_SRC

Notice that the ~unwrap_or_else~ function has the additional generic type
parameter ~F~. The ~F~ type is the type of the parameter named ~f~, which is the
closure we provide when calling ~unwrap_or_else~.

The trait bound specified on the generic type ~F~ is ~FnOnce() -> T~, which
means ~F~ must be able to be called once, take no arguments, and return a ~T~.
Using ~FnOnce~ in the trait bound expresses the constraint that ~unwrap_or_else~
is only going to call ~f~ at most one time. Because all closures implement
~FnOnce~, ~unwrap_or_else~ accepts all three kinds of closures and is as
flexible as it can be.

Note: Functions can implement all three of the ~Fn~ traits too. If what we want
to do doesn’t require capturing a value from the environment, we can use the
name of a function rather than a closure where we need something that implements
one of the ~Fn~ traits. For example, on an ~Option<Vec<T>>~ value, we could call
~unwrap_or_else(Vec::new)~ to get a new, empty vector if the value is ~None~.

Let's look at the standard library method ~sort_by_key~ defined on slices where
~FnMut~ is used. The closure gets one argument in the form of a reference to the
current item in the slice being considered, and returns a value of type ~K~ that
can be ordered. This function is useful when you want to sort a slice by a
particular attribute of each item. Here we sort a list of ~Rectangle~ instances
by their ~width~ attribute:

#+BEGIN_SRC rust :results output
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}
#+END_SRC

The reason ~sort_by_key~ is defined to take an ~FnMut~ closure is that it calls
the closure multiple times: once for each item in the slice. The closure
~|r| r.width~ doesn’t capture, mutate, or move out anything from its
environment, so it meets the trait bound requirements.

Here's an example of a closure that implements just the ~FnOnce~ trait, because
it moves the ~value~ out of the environment. The compiler won’t let us use this
closure with ~sort_by_key~:

#+BEGIN_SRC rust :results output
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value); // <-- Ownership changes here so it can only be called once
                                     // The second time called ~value~ will no longer be in the
                                     // calling environment
        r.width
    });
    println!("{list:#?}");
}
#+END_SRC

To fix this, we need to change the closure body so that it doesn’t move values
out of the environment. To count the number of times the closure is called,
keeping a counter in the environment and incrementing its value in the closure
body is a more straightforward way to calculate that. Here the closure is only
capturing a mutable reference to the ~num_sort_operations~ counter and can
therefore be called more than once:

#+BEGIN_SRC rust :results output
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}
#+END_SRC

** Processing a Series of Items with Iterators

An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished.

In Rust, iterators are lazy, meaning they have no effect until you call methods
that consume the iterator to use it up.

In the following example we loop over both a vector and an iterator. Under the
hood an iterator is implicitly created and then consumed when looping over the
vector. So the two cases are equivalent:

#+BEGIN_SRC rust :results output
fn main() {
    let v0 = vec![1, 2, 3];
    for val in v0 {
        println!("Vector loop: {val}");
    }

    let v1 = vec![4, 5, 6];
    let v1_iter = v1.iter();
    for val in v1_iter {
        println!("Iterator loop: {val}");
    }
}
#+END_SRC

Iterators give you more flexibility to use the same logic with many different
kinds of sequences, not just data structures you can index into, like vectors.

*** The ~Iterator~ Trait and the ~next~ Method

All iterators implement a trait named ~Iterator~ that is defined in the standard
library. The definition of the trait looks like this:

#+BEGIN_SRC rust :noeval
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
#+END_SRC

Notice this definition uses some new syntax: ~type Item~ and ~Self::Item~, which
are defining an /associated type/ with this trait. For now, all you need to know
is that this code says implementing the ~Iterator~ trait requires that you also
define an ~Item~ type, and this ~Item~ type is used in the return type of the
~next~ method.

The ~Iterator~ trait only requires implementors to define one method: the ~next~
method, which returns one item of the iterator at a time wrapped in ~Some~ and,
when iteration is over, returns ~None~.

#+BEGIN_SRC rust :results output
fn main() {
    let v1 = vec![1, 2, 3];
    let mut v1_iter = v1.iter();
    //let mut v1_iter = v1.into_iter();
    //let mut v1_iter = v1.iter_mut();
    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
#+END_SRC

Note that we needed to make ~v1_iter~ mutable: calling the ~next~ method on an
iterator changes internal state that the iterator uses to keep track of where it
is in the sequence. In other words, this code /consumes/, or uses up, the
iterator. We didn’t need to make ~v1_iter~ mutable when we used a ~for~ loop
because the loop took ownership of ~v1_iter~ and made it mutable behind the
scenes. It works because the new owner of a value can change mutability:

#+BEGIN_SRC rust :results output
let x = "hello".to_string();
// Won't work as x is not mutable
//x.push_str(" world");
let mut y = x; // When moving a value the new owner can do what they want
y.push_str(" world");
println!("{}", y)
#+END_SRC

Also note that the values we get from the calls to ~next~ are immutable
references to the values in the vector. The ~iter~ method produces an iterator
over immutable references. If we want to create an iterator that takes ownership
of ~v1~ and returns owned values, we can call ~into_iter~ instead of ~iter~.
Similarly, if we want to iterate over mutable references, we can call ~iter_mut~
instead of ~iter~.

*** Methods that Consume the Iterator

The ~Iterator~ trait has a number of different methods with default
implementations provided by the standard library. Some of these methods call the
~next~ method in their definition, which is why you’re required to implement the
~next~ method when implementing the ~Iterator~ trait.

Methods that call ~next~ are called /consuming adaptors/, because calling them
uses up the iterator. One example is the ~sum~ method, which takes ownership of
the iterator and iterates through the items by repeatedly calling ~next~, thus
consuming the iterator.

#+BEGIN_SRC rust :results output
fn main() {
    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();
    let total: i32 = v1_iter.sum();
    println!("{}", total);
}
#+END_SRC

We aren’t allowed to use ~v1_iter~ after the call to ~sum~ because ~sum~ takes
ownership of the iterator we call it on.

*** Methods that Produce Other Iterators

/Iterator adaptors/ are methods defined on the ~Iterator~ trait that don’t
consume the iterator. Instead, they produce different iterators by changing some
aspect of the original iterator.

The iterator adaptor method ~map~, which takes a closure to call on each item as
the items are iterated through. The ~map~ method returns a new iterator that
produces the modified items.

#+BEGIN_SRC rust :results output
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];
    v1.iter().map(|x| x + 1);
}
#+END_SRC

The closure we’ve specified never gets called. Remember that iterators are lazy,
and we need to consume the iterator here. So in the example above, no work is
actually done by the iterator (a warning is printed if you try to compile the
code).

To fix this we need to consume the iterator. We’ll use the ~collect~ method,
which consumes the iterator and collects the resulting values into a collection
data type.

#+BEGIN_SRC rust :results output
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}

fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];
    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
    print_type_of(&v2); // v2 is also of type Vec<i32>
    println!("{:?}", v2)
}
#+END_SRC

You can chain multiple calls to iterator adaptors to perform complex actions in
a readable way. But because all iterators are lazy, you have to call one of the
consuming adaptor methods to get results from calls to iterator adaptors.

*** Using Closures that Capture Their Environment

The ~filter~ method takes a closure that gets an item from the iterator and
returns a ~bool~. If the closure returns ~true~, the value will be included in
the iteration produced by ~filter~. If the closure returns ~false~, the value
won’t be included.

Here we use ~filter~ with a closure that captures the ~shoe_size~ variable from
its environment to iterate over a collection of ~Shoe~ struct instances. It will
return only shoes that are the specified size.

#+BEGIN_SRC rust :results output
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

fn main() {
    let shoes = vec![
        Shoe {
            size: 10,
            style: String::from("sneaker"),
        },
        Shoe {
            size: 13,
            style: String::from("sandal"),
        },
        Shoe {
            size: 10,
            style: String::from("boot"),
        },
    ];

    let in_my_size = shoes_in_size(shoes, 10);
    println!("{:#?}", in_my_size)
}
#+END_SRC

The ~shoes_in_size~ function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size. In the body of ~shoes_in_size~, we call ~into_iter~ to create an iterator
that takes ownership of the vector. Then we call ~filter~ to adapt that iterator
into a new iterator that only contains elements for which the closure returns
~true~.

The closure captures the ~shoe_size~ parameter from the environment and compares
the value with each shoe’s size, keeping only shoes of the size specified.
Finally, calling ~collect~ gathers the values returned by the adapted iterator
into a vector that’s returned by the function.

** Improving ~minigrep~

For the improved code see [[file:008_improved_minigrep][008_improved_minigrep]].

Let’s look at how iterators can improve our implementation of the
~Config::build~ function and the ~search~ function of the ~minigrep~ project.

*** Removing a ~clone~ Using an Iterator

Here's the current implementation of the ~Config::build~ function:

#+BEGIN_SRC rust :noeval
impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
#+END_SRC

We needed ~clone~ here because we have a slice with ~String~ elements in the
parameter ~args~, but the ~build~ function doesn’t own ~args~. To return
ownership of a ~Config~ instance, we had to ~clone~ the values from the ~query~
and ~file_path~ fields of ~Config~ so the ~Config~ instance can own its values.
But calls to ~clone~ is inefficient (in this case it's small and should really
affect performace, but still).

We can change the ~build~ function to take ownership of an iterator as its
argument instead of borrowing a slice. We’ll use the iterator functionality
instead of the code that checks the length of the slice and indexes into
specific locations. This will clarify what the ~Config::build~ function is doing
because the iterator will access the values.

Once ~Config::build~ takes ownership of the iterator and stops using indexing
operations that borrow, we can move the ~String~ values from the iterator into
~Config~ rather than calling ~clone~ and making a new allocation.

**** Using the Returned Iterator Directly

In the ~main~ method we converted the ~env::args()~ iterator to a vector and
passed a reference to this vector:

#+BEGIN_SRC rust :noeval
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
#+END_SRC

Now we want to use the iterator and pass ownership of it to ~Config::build~ so
change the code above to:

#+BEGIN_SRC rust :noeval
fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
#+END_SRC

The standard library documentation for the ~env::args~ function shows that the
type of the iterator it returns is ~std::env::Args~, and that type implements
the ~Iterator~ trait and returns ~String~ values.

**** Using ~Iterator~ Trait Methods Instead of Indexing

Now change the implementation of ~Config::build~ to:

#+BEGIN_SRC rust :noeval
impl Config {
    pub fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
        args.next();

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"), // The iterator ran out of items
        };

        let file_path = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file path"), // The iterator ran out of items
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
#+END_SRC

We’ve updated the signature of the ~Config::build~ function so the parameter
~args~ has a generic type with the trait bounds ~impl Iterator<Item = String>~
instead of ~&[String]~. Basically it means that ~args~ can be any type that
implements the ~Iterator~ trait which returns ~String~ items.

Because we’re taking ownership of ~args~ and we’ll be mutating ~args~ by
iterating over it, we add the ~mut~ keyword into the specification of the ~args~
parameter to make it mutable.

Remember that the first value in the return value of ~env::args~ is the name of
the program. We want to ignore that and get to the next value, so first we call
~next~ and do nothing with the return value.

*** Making Code Clearer with Iterator Adaptors

We can also take advantage of iterators in the ~search~ function. The current
implementation looks like this:

#+BEGIN_SRC rust :noeval
fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
#+END_SRC

We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate ~results~ vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn’t have to manage
concurrent access to the ~results~ vector.

#+BEGIN_SRC rust :results output
fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
#+END_SRC

** A comment about performance between loops vs iterators

Most Rust programmers prefer to use the iterator style. It’s a bit tougher to
get the hang of at first, but once you get a feel for the various iterator
adaptors and what they do, iterators can be easier to understand. Instead of
fiddling with the various bits of looping and building new vectors, the code
focuses on the high-level objective of the loop.

The iterator version is slightly faster. Iterators, although a high-level
abstraction, get compiled down to roughly the same code as if you’d written the
lower-level code yourself. Iterators are one of Rust’s /zero-cost abstractions/,
by which we mean using the abstraction imposes no additional runtime overhead.

* More About Cargo and Crates.io

For full documentation about Cargo, see [[https://doc.rust-lang.org/cargo/][The Cargo Book]].

** Customizing Builds with Release Profiles

In Rust, /release profiles/ are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.

Cargo has two main profiles: the ~dev~ profile Cargo uses when you
~run cargo build~ and the ~release~ profile Cargo uses when you run
~cargo build --release~. The ~dev~ profile is defined with good defaults for
development, and the ~release~ profile has good defaults for release builds.

Cargo has default settings for each of the profiles that apply when you haven’t
explicitly added any ~[profile.*]~ sections in the project’s ~Cargo.toml~ file.
By adding ~[profile.*]~ sections for any profile you want to customize, you
override any subset of the default settings. For example, here are the default
values for the opt-level setting for the ~dev~ and ~release~ profiles:

#+BEGIN_SRC toml :noeval
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
#+END_SRC

The ~opt-level~ setting controls the number of optimizations Rust will apply to
your code, with a range of 0 to 3. You can override a default setting by adding
a different value for it in ~Cargo.toml~. You can override more values. Read
more about [[https://doc.rust-lang.org/cargo/reference/profiles.html][profiles in The Cargo Book]].

** Improving a Crate before Publishing to Crates.io

The code for this section is available at [[file:009_documentation][009_documentation]].

*** Making Useful Documentation Comments

Rust has a particular kind of comment for documentation, known conveniently as a
/documentation comment/, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to use your crate as opposed to how
your crate is implemented.

Documentation comments use three slashes, ~///~, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item they’re documenting.

#+BEGIN_SRC rust :noeval
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+END_SRC

We can generate the HTML documentation from this documentation comment by
running ~cargo doc~. This command runs the ~rustdoc~ tool distributed with Rust
and puts the generated HTML documentation in the ~target/doc~ directory.

For convenience, running ~cargo doc --open~ will build the HTML for your current
crate’s documentation (as well as the documentation for all of your crate’s
dependencies) and open the result in a web browser.

**** Commonly Used Sections

In the example above we used the ~# Examples~ markdown heading to create a
section in the HTML with the title "Examples". Other commonly used sections are:

- *Panics*: The scenarios in which the function being documented could panic.
  Callers of the function who don’t want their programs to panic should make
  sure they don’t call the function in these situations.
- *Errors*: If the function returns a ~Result~, describing the kinds of errors
  that might occur and what conditions might cause those errors to be returned
  can be helpful to callers so they can write code to handle the different kinds
  of errors in different ways.
- *Safety*: If the function is ~unsafe~ to call (more about unsafety later),
  there should be a section explaining why the function is unsafe and covering
  the invariants that the function expects callers to uphold.

**** Documentation Comments as Tests

Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running
~cargo test~ will run the code examples in your documentation as tests.

The test result for the tests in the documentation will appear under a section
called ~Doc-tests proj_name~ om the output of ~cargo test~.

**** Commenting Contained Items

The style of doc comment ~//!~ adds documentation to the item that contains the
comments rather than to the items following the comments. We typically use these
doc comments inside the crate root file (~src/lib.rs~ by convention) or inside a
module to document the crate or the module as a whole.

To add documentation that describes the purpose of the ~my_crate~ crate, we add
documentation comments that start with ~//!~ to the beginning of the
~src/lib.rs~ file:

#+BEGIN_SRC rust :noeval
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+END_SRC

The new comments will display on the front page of the documentation for
~my_crate~ above the list of public items in the crate, when running
~cargo doc --open~.

*** Exporting a Convenient Public API with ~pub use~

The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.

The structure that makes sense to you while you’re developing a crate might not
be very convenient for your users. You might want to organize your structs in a
hierarchy containing multiple levels, but then people who want to use a type
you’ve defined deep in the hierarchy might have trouble finding out that type
exists. They might also be annoyed at having to enter
~use my_crate::some_module::another_module::UsefulType;~ rather than
~use my_crate::UsefulType;~.

You can re-export items to make a public structure that’s different from your
private structure by using ~pub use~. Re-exporting takes a public item in one
location and makes it public in another location, as if it were defined in the
other location instead.

Look at the following example:

#+BEGIN_SRC rust :noeval
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
    }
}
#+END_SRC

When running ~cargo doc --open~, ~PrimaryColor~ and ~SecondaryColor~ types
aren’t listed on the front page, nor is the ~mix~ function. We have to click
~kinds~ and ~utils~ in the /Modules/ section to see them.

Another crate that depends on this library would need ~use~ statements that
bring the items from ~art~ into scope, specifying the module structure that’s
currently defined.

#+BEGIN_SRC rust :noeval
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
#+END_SRC

The module structure of the ~art~ crate is more relevant to developers working
on the art crate than to those using it. To remove the internal organization
from the public API, we can modify the ~art~ crate code and add ~pub use~
statements to re-export the items at the top level:

#+BEGIN_SRC rust :noeval
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
#+END_SRC

The API documentation that ~cargo doc~ generates for this crate will now list
and link re-exports on the front page under the /Re-exports/ section.

The ~art~ crate users can still see and use the internal structure or they can
use the more convenient re-exported structure:

#+BEGIN_SRC rust :noeval
use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
}
#+END_SRC

Another common use of ~pub use~ is to re-export definitions of a dependency in
the current crate to make that crate’s definitions part of your crate’s public
API.

** Cargo Workspaces

Previously we built a package that included a binary crate and a library crate.
As your project develops, you might find that the library crate continues to get
bigger and you want to split your package further into multiple library crates.
Cargo offers a feature called /workspaces/ that can help manage multiple related
packages that are developed in tandem.

*** Creating a Workspace

A /workspace/ is a set of packages that share the same ~Cargo.lock~ and output
directory. There are multiple ways to structure a workspace, so we’ll just show
one common way. We’ll have a workspace containing a binary and two libraries.
The binary, which will provide the main functionality, will depend on the two
libraries. One library will provide an ~add_one~ function, and a second library
an ~add_two~ function. These three crates will be part of the same workspace.

We have already create a workspace in [[file:010_workspaces][010_workspaces]] with the following file
structure:

#+BEGIN_SRC
010_workspaces
└── add
    ├── adder
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── add_one
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    ├── add_two
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    └── Cargo.toml
#+END_SRC

To create this structure start creating new directory for the workspace:

#+BEGIN_SRC bash :noeval
mkdir add
cd add
#+END_SRC

Create the ~Cargo.toml~ file that will configure the entire workspace. This file
won’t have a ~[package]~ section. Instead, it will start with a ~[workspace]~
section that will allow us to add members to the workspace by specifying the
path to the package with our binary crate; in this case, that path is ~adder~:

#+BEGIN_SRC toml :noeval
[workspace]

members = [
    "adder",
]
#+END_SRC

Next, we’ll create the ~adder~ binary crate by running ~cargo new adder~ within
the ~add~ directory. If we only had created ~Cargo.toml~ with the content:

#+BEGIN_SRC toml :noeval
[workspace]
#+END_SRC

The ~adder~ member would have been added automatically to the ~members~ list
when it was created (discover by myself).

At this point, we can build the workspace by running ~cargo build~. The
workspace has one target directory at the top level that the compiled artifacts
will be placed into; the ~adder~ package doesn’t have its own ~target~
directory. Even if we were to run ~cargo build~ from inside the ~adder~
directory, the compiled artifacts would still end up in ~add/target~ rather than
~add/adder/target~.

*** Creating the Second Package in the Workspace

Let’s create another member package in the workspace and call it ~add_one~.
Change the top-level ~Cargo.toml~ to specify the ~add_one~ path in the members
list (this step is optional as discovered above):

#+BEGIN_SRC toml :noeval
[workspace]

members = [
    "adder",
    "add_one"
]
#+END_SRC

Generate a new library crate named ~add_one~ by running
~cargo new add_one --lib~.

In the ~add_one/src/lib.rs~ file, let’s add an ~add_one~ function:

#+BEGIN_SRC rust :results output
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+END_SRC

Now we can have the ~adder~ package with our binary depend on the ~add_one~
package that has our library. First, we’ll need to add a path dependency on
~add_one~ to ~adder/Cargo.toml~.

#+BEGIN_SRC toml :noeval
[dependencies]
add_one = { path = "../add_one" }
#+END_SRC

Cargo doesn’t assume that crates in a workspace will depend on each other, so we
need to be explicit about the dependency relationships.

Next, let’s use the ~add_one~ function in the ~adder~ crate. Open the
~adder/src/main.rs~ file and add a ~use~ line at the top to bring the new
~add_one~ library crate into scope. Then change the ~main~ function to call the
~add_one~ function:

#+BEGIN_SRC rust :noeval
use add_one;

fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}
#+END_SRC

Let’s build the workspace by running ~cargo build~ in the top-level ~add~
directory.

To run the binary crate from the ~add~ directory, we can specify which package
in the workspace we want to run by using the ~-p~ argument and the package name
with ~cargo run~. In this case: ~cargo run -p adder~ (actually it looks like as
if ~cargo run~ works as well in this case).

*** Depending on an External Package in a Workspace

After building, notice that the workspace has only one ~Cargo.lock~ file at the
top level, rather than having a ~Cargo.lock~ in each crate’s directory. This
ensures that all crates are using the same version of all dependencies. If we
add the ~rand~ package to the ~adder/Cargo.toml~ and ~add_one/Cargo.toml~ files,
Cargo will resolve both of those to one version of ~rand~ and record that in the
one ~Cargo.lock~. Making all crates in the workspace use the same dependencies
means the crates will always be compatible with each other. Let’s add the ~rand~
crate to the ~[dependencies]~ section in the ~add_one/Cargo.toml~ file so we can
use the ~rand~ crate in the ~add_one~ crate:

#+BEGIN_SRC toml :noeval
[dependencies]
rand = "0.8.5"
#+END_SRC

We can now add ~use rand;~ to the ~add_one/src/lib.rs~ file and it will compile
just fine. The top-level ~Cargo.lock~ now contains information about the
dependency of ~add_one~ on ~rand~. However, even though ~rand~ is used somewhere
in the workspace, we can’t use it in other crates in the workspace unless we add
~rand~ to their ~Cargo.toml~ files as well. So we can't use ~rand~ in the
~adder~ crate.

If we add ~rand~ as a dependency for ~adder~ as well and build it, the list of
dependencies for ~adder~ in ~Cargo.lock~ will be updated, but no additional
copies of ~rand~ will be downloaded. Cargo will ensure that every crate in every
package in the workspace using the ~rand~ package will be using the same version
as long as they specify compatible versions of ~rand~, saving us space and
ensuring that the crates in the workspace will be compatible with each other.

If crates in the workspace specify incompatible versions of the same dependency,
Cargo will resolve each of them, but will still try to resolve as few versions
as possible.

*** Adding a Test to a Workspace

If you run ~cargo test~ in the top-level ~add~ directory, will run the tests for
all the crates in the workspace. Each crate will get its own unit test section,
and each library crate will get it's own Doc-tests section.

We can also run tests for one particular crate in a workspace from the top-level
directory by using the ~-p~ flag and specifying the name of the crate we want to
test. E.g. ~cargo test -p add_one~.

If you publish the crates in the workspace to [[https://crates.io/][crates.io]], each crate in the
workspace will need to be published separately. Like ~cargo test~, we can
publish a particular crate in our workspace by using the ~-p~ flag and
specifying the name of the crate we want to publish.

** Installing Binaries with ~cargo install~

The cargo install command allows you to install and use binary crates locally.
Note that you can only install packages that have binary targets. A /binary
target/ is the runnable program that is created if the crate has a ~src/main.rs~
file or another file specified as a binary, as opposed to a library target that
isn’t runnable on its own but is suitable for including within other programs.

All binaries installed with ~cargo install~ are stored in the installation
root’s ~bin~ folder. If you installed Rust using /rustup.rs/ and don’t have any
custom configurations, this directory will be ~$HOME/.cargo/bin~.

To install the crate ~ripgrep~, run ~cargo install ripgrep~. The last couple of
lines in the output shows the location and the name of the installed binary,
which in the case of ~ripgrep~ is ~rg~. Run ~rg --help~ to verify.

To uninstall the crate, run ~cargo uninstall ripgrep~.

** Extending Cargo with Custom Commands

Cargo is designed so you can extend it with new subcommands without having to
modify Cargo. If a binary in your ~$PATH~ is named ~cargo-something~, you can
run it as if it was a Cargo subcommand by running ~cargo something~. Custom
commands like this are also listed when you run ~cargo --list~. You can then use
~cargo install~ to install extensions and then run them just like the built-in
Cargo tools.

* Smart Pointers

The most common kind of pointer in Rust is a reference. References are indicated
by the ~&~ symbol and borrow the value they point to. They don’t have any
special capabilities other than referring to data, and have no overhead.

~Smart pointers~, on the other hand, are data structures that act like a pointer
but also have additional metadata and capabilities. Rust has a variety of smart
pointers defined in the standard library that provide functionality beyond that
provided by references.

Rust, with its concept of ownership and borrowing, has an additional difference
between references and smart pointers: while references only borrow data, in
many cases, smart pointers own the data they point to.

We’ve already encountered a few smart pointers, including ~String~ and ~Vec<T>~.
Both these types count as smart pointers because they own some memory and allow
you to manipulate it. They also have metadata and extra capabilities or
guarantees.

Smart pointers are usually implemented using structs. Unlike an ordinary struct,
smart pointers implement the ~Deref~ and ~Drop~ traits. The ~Deref~ trait allows
an instance of the smart pointer struct to behave like a reference so you can
write your code to work with either references or smart pointers. The ~Drop~
trait allows you to customize the code that’s run when an instance of the smart
pointer goes out of scope.

We’ll cover the most common smart pointers in the standard library:

- ~Box<T>~ for allocating values on the heap
- ~Rc<T>~, a reference counting type that enables multiple ownership
- ~Ref<T>~ and ~RefMut<T>~, accessed through ~RefCell<T>~, a type that enforces
  the borrowing rules at runtime instead of compile time

In addition, we’ll cover the /interior mutability/ pattern where an immutable
type exposes an API for mutating an interior value. We’ll also discuss
/reference cycles/: how they can leak memory and how to prevent them.

** Using ~Box<T>~ to Point to Data on the Heap

The most straightforward smart pointer is a /box/, whose type is written
~Box<T>~. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data.

Boxes don’t have performance overhead, other than storing their data on the heap
instead of on the stack. You’ll use them most often in these situations:

- When you have a type whose size can’t be known at compile time and you want to
  use a value of that type in a context that requires an exact size
- When you have a large amount of data and you want to transfer ownership but
  ensure the data won’t be copied when you do so
- When you want to own a value and you care only that it’s a type that
  implements a particular trait rather than being of a specific type (known as
  /trait object/)

*** Using a ~Box<T>~ to Store Data on the Heap

#+BEGIN_SRC rust :results output
fn main() {
    let b = Box::new(5);
    println!("b = {b}"); // b = 5
}
#+END_SRC

We define the variable ~b~ to have the value of a ~Box~ that points to the value
~5~, which is allocated on the heap. In this case, we can access the data in the
box similar to how we would if this data were on the stack. Just like any owned
value, when a box goes out of scope, as ~b~ does at the end of ~main~, it will
be deallocated. The deallocation happens both for the box (stored on the stack)
and the data it points to (stored on the heap).

*** Enabling Recursive Types with Boxes

A value of /recursive type/ can have another value of the same type as part of
itself. Recursive types pose an issue because at compile time Rust needs to know
how much space a type takes up. However, the nesting of values of recursive
types could theoretically continue infinitely, so Rust can’t know how much space
the value needs. Because boxes have a known size, we can enable recursive types
by inserting a box in the recursive type definition.

**** The Cons list

Let's implement a [[https://en.wikipedia.org/wiki/Cons][cons list]] (which is not a commonly used data structure in
Rust).

The following will not compile:

#+BEGIN_SRC rust :results output
enum List {
    Cons(i32, List),
    Nil,
}
#+END_SRC

The compiler will complain that this type "has infinite size". Rust can’t figure
out how much space it needs to store a ~List~ value.

**** Computing the Size of a Non-Recursive Type

To determine how much space to allocate for an enum value, Rust goes through
each of the variants to see which variant needs the most space. Because only one
variant will be used, the most space an enum value will need is the space it
would take to store the largest of its variants.

In the case of the ~List~ enum, the compiler starts by looking at the ~Cons~
variant, which holds a value of type ~i32~ and a value of type ~List~.
Therefore, ~Cons~ needs an amount of space equal to the size of an ~i32~ plus
the size of a ~List~. To figure out how much memory the ~List~ type needs, the
compiler looks at the variants, starting with the ~Cons~ variant. We're back at
square one and this process continues infinitely.

**** Using ~Box<T>~ to Get a Recursive Type with a Known Size

Because a ~Box<T>~ is a pointer, Rust always knows how much space a ~Box<T>~
needs: a pointer’s size doesn’t change based on the amount of data it’s pointing
to. This means we can put a ~Box<T>~ inside the ~Cons~ variant instead of
another ~List~ value directly. The ~Box<T>~ will point to the next ~List~ value
that will be on the heap rather than inside the ~Cons~ variant.

#+BEGIN_SRC rust :results output
#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); // The list [1, 2, 3]
    println!("{:?}", list)
}
#+END_SRC

The ~Cons~ variant needs the size of an ~i32~ plus the space to store the box’s
pointer data. The ~Nil~ variant stores no values, so it needs less space than
the ~Cons~ variant. We now know that any ~List~ value will take up the size of
an ~i32~ plus the size of a box’s pointer data.

Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have the performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need.

** Treating Smart Pointers Like Regular References with the ~Deref~ Trait

Implementing the ~Deref~ trait allows you to customize the behavior of the
/dereference operator/ ~*~ (not to be confused with the multiplication or glob
operator). By implementing ~Deref~ in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on references
and use that code with smart pointers too.

*** Following the Pointer to the Value

A regular reference is a type of pointer.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
#+END_SRC


The variable ~x~ holds an ~i32~ value ~5~. We set ~y~ equal to a reference to
~x~. To make an assertion about the value in ~y~, we have to use ~*y~ to follow
the reference to the value it’s pointing to (hence ~dereference~) so the
compiler can compare the actual value. Once we dereference ~y~, we have access
to the integer value ~y~ is pointing to that we can compare with ~5~.

Using ~assert_eq!(5, y);~ wouldn't work as comparing a number and a reference to
a number isn’t allowed because they’re different types.

*** Using ~Box<T>~ Like a Reference

We can also use a ~Box<T>~ instead of a reference; the dereference operator used
on the ~Box<T>~ functions in the same way as the dereference operator used on a
reference:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
#+END_SRC

Note that the ~Box<T>~ ~y~ is pointing to a copied value of ~x~ rather than a
reference pointing to the value of ~x~.

*** Defining Our Own Smart Pointer

Let's define our own ~Box<T>~. It's defined as a [[*Tuple structs][tuple struct]] with one element.

#+BEGIN_SRC rust :results output
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
#+END_SRC

Note that ~Box<T>~ stores data on the heap while ~MyBox<T>~ does not.

This current version of ~MyBox<T>~ can't be dereferenced using the ~*~ operator
because it's not a referencs.

*** Treating a Type Like a Reference by Implementing the ~Deref~ Trait

Let's implement the ~Deref~ trait.  The ~Deref~ trait, provided by the standard
library, requires us to implement one method named ~deref~ that borrows ~self~
and returns a reference to the inner data.

#+BEGIN_SRC rust :results output
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
#+END_SRC

The ~type Target = T;~ syntax defines an associated type for the ~Deref~ trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don’t need to worry about them for now; more about that
later.

We fill in the body of the ~deref~ method with ~&self.0~ so deref returns a
reference to the value we want to access with the ~*~ operator.

Without the ~Deref~ trait, the compiler can only dereference ~&~ references. The
~deref~ method gives the compiler the ability to take a value of any type that
implements ~Deref~ and call the ~deref~ method to get a ~&~ reference that it
knows how to dereference.

When we entere ~*y~ , behind the scenes Rust actually runs ~*(y.deref())~. The
reason the ~deref~ method returns a reference to a value, and that the plain
dereference outside the parentheses in ~*(y.deref())~ is still necessary, is to
do with the ownership system. If the ~deref~ method returned the value directly
instead of a reference to the value, the value would be moved out of ~self~.

*** Implicit Deref Coercions with Functions and Methods

/Deref coercion/ converts a reference to a type that implements the ~Deref~
trait into a reference to another type. For example, deref coercion can convert
~&String~ to ~&str~ because ~String~ implements the ~Deref~ trait such that it
returns ~&str~. It happens automatically when we pass a reference to a
particular type’s value as an argument to a function or method that doesn’t
match the parameter type in the function or method definition. A sequence of
calls to the ~deref~ method converts the type we provided into the type the
parameter needs.

The deref coercion feature also lets us write code that can work for either
references or smart pointers.

#+BEGIN_SRC rust :results output
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn hello(name: &str) {
    println!("Hello, {name}!");
}

fn main() {
    let s = String::from("Rust");
    hello(&s); // One level deref coercion
    let m = MyBox::new(String::from("Rust"));
    hello(&m);        // Two levels deref coercion
    hello(&(*m)[..]); // Without deref coercion
}
#+END_SRC

Here we’re calling the ~hello~ function with the argument ~&m~, which is a
reference to a ~MyBox<String>~ value. Because we implemented the ~Deref~ trait
on ~MyBox<T>~, Rust can turn ~&MyBox<String>~ into ~&String~ by calling deref.
The standard library provides an implementation of ~Deref~ on ~String~ that
returns a string slice, and this is in the API documentation for ~Deref~. Rust
calls ~deref~ again to turn the ~&String~ into ~&str~, which matches the ~hello~
function’s definition. In the example above you see how it looks like without
deref coercion.

When the ~Deref~ trait is defined for the types involved, Rust will analyze the
types and use ~Deref::deref~ as many times as necessary to get a reference to
match the parameter’s type. The number of times that ~Deref::deref~ needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!

*** How Deref Coercion Interacts with Mutability

Similar to how you use the ~Deref~ trait to override the ~*~ operator on
immutable references, you can use the ~DerefMut~ trait to override the ~*~
operator on mutable references.

Rust does deref coercion when it finds types and trait implementations in three
cases:

- From ~&T~ to ~&U~ when ~T: Deref<Target=U>~
- From ~&mut T~ to ~&mut U~ when ~T: DerefMut<Target=U>~
- From ~&mut T~ to ~&U~ when ~T: Deref<Target=U>~

The first case states that if you have a ~&T~, and ~T~ implements ~Deref~ to
some type ~U~, you can get a ~&U~ transparently. The second case states that the
same deref coercion happens for mutable references.

Third case states that Rust will also coerce a mutable reference to an immutable
one. But the reverse is not possible: immutable references will never coerce to
mutable references.

** Running Code on Cleanup with the ~Drop~ Trait

The ~Drop~ trait lets you customize what happens when a value is about to go out
of scope. You can provide an implementation for the ~Drop~ trait on any type,
and that code can be used to release resources like files or network
connections. For example, when a ~Box<T>~ is dropped it will deallocate the
space on the heap that the box points to.

You specify the code to run when a value goes out of scope by implementing the
~Drop~ trait. The ~Drop~ trait requires you to implement one method named ~drop~
that takes a mutable reference to ~self~. E.g:

#+BEGIN_SRC rust :results output
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
#+END_SRC

The ~Drop~ trait is included in the prelude, so we don’t need to bring it into
scope.

In ~main~, we create two instances of ~CustomSmartPointer~ and then print
~CustomSmartPointers created~. At the end of ~main~, our instances of
~CustomSmartPointer~ will go out of scope, and Rust will call the code we put in
the ~drop~ method, printing our final message. Note that we didn’t need to call
the ~drop~ method explicitly. Variables are dropped in the reverse order of
their creation, so ~d~ will be dropped before ~c~.

*** Dropping a Value Early with ~std::mem::drop~

Disabling ~drop~ isn’t usually necessary; the whole point of the ~Drop~ trait is
that it’s taken care of automatically. Occasionally, however, you might want to
clean up a value early. One example is when using smart pointers that manage
locks: you might want to force the ~drop~ method that releases the lock so that
other code in the same scope can acquire the lock. Rust doesn’t let you call the
~Drop~ trait’s ~drop~ method manually; instead you have to call the
~std::mem::drop~ function provided by the standard library if you want to force
a value to be dropped before the end of its scope.

The following code will not compile:

#+BEGIN_SRC rust :results output
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}
#+END_SRC

Rust doesn’t let us call ~drop~ explicitly because Rust would still
automatically call ~drop~ on the value at the end of ~main~. This would cause a
/double free/ error.

We can’t disable the automatic insertion of ~drop~ when a value goes out of
scope, and we can’t call the ~drop~ method explicitly. So, if we need to force a
value to be cleaned up early, we use the ~std::mem::drop~ function.

The ~std::mem::drop~ function is different from the ~drop~ method in the ~Drop~
trait. The function is in the prelude, so we can modify ~main~ to call the
~drop~ function.

#+BEGIN_SRC rust :results output
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c); // Value is moved here so c will not be accessible after this
    //println!("{}", c.data);
    println!("CustomSmartPointer dropped before the end of main.");
}
#+END_SRC

** ~Rc<T>~, the Reference Counted Smart Pointer

In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node. A node shouldn’t be cleaned up unless it doesn’t have
any edges pointing to it and so has no owners.

You have to enable multiple ownership explicitly by using the Rust type ~Rc<T>~,
which is an abbreviation for /reference counting/. The ~Rc<T>~ type keeps track
of the number of references to a value to determine whether or not the value is
still in use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.

We use the ~Rc<T>~ type when we want to allocate some data on the heap for
multiple parts of our program /to read/ and we can’t determine at compile time
which part will finish using the data last.

*Note* that ~Rc<T>~ is only for use in single-threaded scenarios.

*** Using ~Rc<T>~ to Share Data

Let's look at the cons list again. This time, we’ll create two lists that both
share ownership of a third list. In the example below, list ~b~ and ~c~ will
both own ~a~.

#+BEGIN_SRC rust :results output
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a)); // <-- a is moved here
    let c = Cons(4, Box::new(a));
}
#+END_SRC

This will of course not work since ~a~ is moved to ~b~ and ~a~ is no longer
valid when assigning it to ~c~.

We could change the definition of ~Cons~ to hold references instead, but then we
would have to specify lifetime parameters. By specifying lifetime parameters, we
would be specifying that every element in the list will live at least as long as
the entire list.

Instead, we’ll change our definition of ~List~ to use ~Rc<T>~ in place of
~Box<T>~. When we create ~b~, instead of taking ownership of ~a~, we’ll clone
the ~Rc<List>~ that ~a~ is holding, thereby increasing the number of references
from one to two and letting ~a~ and ~b~ share ownership of the data in that
~Rc<List>~. We’ll also clone ~a~ when creating ~c~, increasing the number of
references from two to three. Every time we call ~Rc::clone~, the reference
count to the data within the ~Rc<List>~ will increase, and the data won’t be
cleaned up unless there are zero references to it.

#+BEGIN_SRC rust :results output
#[derive(Debug)]
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
    println!("{:?}", b);
    println!("{:?}", c);
}
#+END_SRC

We need to add a ~use~ statement to bring ~Rc<T>~ into scope because it’s not in
the prelude.

We could have called ~a.clone()~ rather than ~Rc::clone(&a)~, but Rust’s
convention is to use ~Rc::clone~ in this case. The implementation of ~Rc::clone~
doesn’t make a deep copy of all the data like most types’ implementations of
~clone~ do. The call to ~Rc::clone~ only increments the reference count, which
doesn’t take much time. Deep copies of data can take a lot of time. By using
~Rc::clone~ for reference counting, we can visually distinguish between the
deep-copy kinds of clones and the kinds of clones that increase the reference
count. When looking for performance problems in the code, we only need to
consider the deep-copy clones and can disregard calls to ~Rc::clone~.

*** Cloning an ~Rc<T>~ Increases the Reference Count

In the following example, ~main~ has an inner scope around list ~c~; then we can
see how the reference count changes when c goes out of scope:

#+BEGIN_SRC rust :results output
#[derive(Debug)]
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a)); // 1
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a)); // 2
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a)); // 3
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a)); //2
}
#+END_SRC

At each point in the program where the reference count changes, we print the
reference count, which we get by calling the ~Rc::strong_count~ function. This
function is named ~strong_count~ rather than ~count~ because the ~Rc<T>~ type
also has a ~weak_count~ (more about that later).

We don’t have to call a function to decrease the reference count like we have to
call ~Rc::clone~ to increase the reference count: the implementation of the
~Drop~ trait decreases the reference count automatically when an ~Rc<T>~ value
goes out of scope.

When ~b~ and then ~a~ go out of scope at the end of ~main~, the count is then 0,
and the ~Rc<List>~ is cleaned up completely. Using ~Rc<T>~ allows a single value
to have multiple owners, and the count ensures that the value remains valid as
long as any of the owners still exist.

Via immutable references, ~Rc<T>~ allows you to share data between multiple
parts of your program for reading only. If ~Rc<T>~ allowed you to have multiple
mutable references too, you might violate one of the borrowing rules.

** ~RefCell<T>~ and the Interior Mutability Pattern

/Interior mutability/ is a design pattern in Rust that allows you to mutate data
even when there are immutable references to that data; normally, this action is
disallowed by the borrowing rules. To mutate data, the pattern uses ~unsafe~
code inside a data structure to bend Rust’s usual rules that govern mutation and
borrowing. Unsafe code indicates to the compiler that we’re checking the rules
manually instead of relying on the compiler to check them for us.

We can use types that use the interior mutability pattern only when we can
ensure that the borrowing rules will be followed at runtime, even though the
compiler can’t guarantee that. The ~unsafe~ code involved is then wrapped in a
safe API, and the outer type is still immutable.

*** Enforcing Borrowing Rules at Runtime with ~RefCell<T>~

Unlike ~Rc<T>~, the ~RefCell<T>~ type represents single ownership over the data
it holds. So, what makes ~RefCell<T>~ different from a type like ~Box<T>~?
Recall the borrowing rules:

- At any given time, you can have either (but not both) one mutable reference or
  any number of immutable references.
- References must always be valid.

With references and ~Box<T>~, the borrowing rules’ invariants are enforced at
compile time. With ~RefCell<T>~, these invariants are enforced at /runtime/.
With references, if you break these rules, you’ll get a compiler error. With
~RefCell<T>~, if you break these rules, your program will panic and exit.

Checking the borrowing rules at compile time is the best choice in the majority
of cases, which is why this is Rust’s default. You will catch errors during
compile time and there is no impact on runtime performace.

The advantage of checking the borrowing rules at runtime instead is that certain
memory-safe scenarios are then allowed, where they would’ve been disallowed by
the compile-time checks. Some properties of code are impossible to detect by
analyzing the code. Because some analysis is impossible, if the Rust compiler
can’t be sure the code complies with the ownership rules, it might reject a
correct program. The ~RefCell<T>~ type is useful when you’re sure your code
follows the borrowing rules but the compiler is unable to understand and
guarantee that.

Similar to ~Rc<T>~, ~RefCell<T>~ is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context.

Here is a recap of the reasons to choose ~Box<T>~, ~Rc<T>~, or ~RefCell<T>~:

- ~Rc<T>~ enables multiple owners of the same data; ~Box<T>~ and ~RefCell<T>~
  have single owners.
- ~Box<T>~ allows immutable or mutable borrows checked at compile time; ~Rc<T>~
  allows only immutable borrows checked at compile time; ~RefCell<T>~ allows
  immutable or mutable borrows checked at runtime.
- Because ~RefCell<T>~ allows mutable borrows checked at runtime, you can mutate
  the value inside the ~RefCell<T>~ even when the ~RefCell<T>~ is immutable.

Mutating the value inside an immutable value is the /interior mutability
pattern/.

*** Interior Mutability: A Mutable Borrow to an Immutable Value

A consequence of the borrowing rules is that when you have an immutable value,
you can’t borrow it mutably. For example, this code won’t compile:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let y = &mut x;
}
#+END_SRC

However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value’s methods would not be able to mutate the value. Using ~RefCell<T>~ is one
way to get the ability to have interior mutability, but ~RefCell<T>~ doesn’t get
around the borrowing rules completely: the borrow checker in the compiler allows
this interior mutability, and the borrowing rules are checked at runtime
instead. If you violate the rules, you’ll get a ~panic!~ instead of a compiler
error.

**** A Use Case for Interior Mutability: Mock Objects

Rust doesn’t have objects in the same sense as other languages have objects, and
Rust doesn’t have mock object functionality built into the standard library as
some other languages do. However, you can definitely create a struct that will
serve the same purposes as a mock object.

Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is.

Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages. All the library needs is something that implements a trait we’ll
provide called ~Messenger~:

#+BEGIN_SRC rust :results output
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
#+END_SRC

One important part of this code is that the ~Messenger~ trait has one method
called ~send~ that takes an immutable reference to ~self~ and the text of the
message. The other important part is that we want to test the behavior of the
~set_value~ method on the ~LimitTracker~. We can change what we pass in for the
~value~ parameter, but ~set_value~ doesn’t return anything for us to make
assertions on. We want to be able to say that if we create a ~LimitTracker~ with
something that implements the ~Messenger~ trait and a particular value for
~max~, when we pass different numbers for ~value~, the messenger is told to send
the appropriate messages.

We need a mock object that, instead of sending an email or text message when we
call ~send~, will only keep track of the messages it’s told to send. Then we can
check that the mock object has the messages we expect after calling the
~set_value~ method.

#+BEGIN_SRC rust :noeval
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
#+END_SRC

This test code defines a ~MockMessenger~ struct that has a ~sent_messages~ field
with a ~Vec~ of ~String~ values to keep track of the messages it’s told to send.
We also define an associated function ~new~ to make it convenient to create new
~MockMessenger~ values that start with an empty list of messages. We then
implement the ~Messenger~ trait for ~MockMessenger~ so we can give a
~MockMessenger~ to a ~LimitTracker~. In the definition of the ~send~ method, we
take the message passed in as a parameter and store it in the ~MockMessenger~
list of ~sent_messages~.

But there's a problem. We can’t modify the ~MockMessenger~ to keep track of the
messages, because the send method takes an immutable reference to self. This is
a situation in which interior mutability can help.

We’ll store the ~sent_messages~ within a ~RefCell<T>~, and then the ~send~
method will be able to modify ~sent_messages~ to store the messages we’ve seen.
The following example is also available under [[file:011_refcell_mock][011_refcell_mock]] (run the test
with ~cargo test~):

#+BEGIN_SRC rust :noeval
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
#+END_SRC

The ~sent_messages~ field is now of type ~RefCell<Vec<String>>~ instead of
~Vec<String>~. In the ~new~ function, we create a new ~RefCell<Vec<String>>~
instance around the empty vector.

For the implementation of the ~send~ method, the first parameter is still an
immutable borrow of ~self~, which matches the trait definition. We call
~borrow_mut~ on the ~RefCell<Vec<String>>~ in ~self.sent_messages~ to get a
mutable reference to the value inside the ~RefCell<Vec<String>>~, which is the
vector. Then we can call ~push~ on the mutable reference to the vector to keep
track of the messages sent during the test.

The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call ~borrow~ on the ~RefCell<Vec<String>>~ to get an
immutable reference to the vector.

**** Keeping Track of Borrows at Runtime with RefCell<T>

When creating immutable and mutable references, we use the ~&~ and ~&mut~
syntax, respectively. With ~RefCell<T>~, we use the ~borrow~ and ~borrow_mut~
methods, which are part of the safe API that belongs to ~RefCell<T>~. The
~borrow~ method returns the smart pointer type ~Ref<T>~, and ~borrow_mut~
returns the smart pointer type ~RefMut<T>~. Both types implement ~Deref~, so we
can treat them like regular references.

The ~RefCell<T>~ keeps track of how many ~Ref<T>~ and ~RefMut<T>~ smart pointers
are currently active. Every time we call ~borrow~, the ~RefCell<T>~ increases
its count of how many immutable borrows are active. When a ~Ref<T>~ value goes
out of scope, the count of immutable borrows goes down by one. Just like the
compile-time borrowing rules, ~RefCell<T>~ lets us have many immutable borrows
or one mutable borrow at any point in time.

If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of ~RefCell<T>~ will panic at runtime.

#+BEGIN_SRC rust :results output
use std::cell::RefCell;

fn main() {
    let rc: RefCell<Vec<String>> = RefCell::new(vec![]);

    let mut one_borrow = rc.borrow_mut();
    let mut two_borrow = rc.borrow_mut();

    one_borrow.push(String::from("First message"));
    two_borrow.push(String::from("Second message"));
}
#+END_SRC

The code above has two mutable references in the same scope, which isn’t
allowed. The code will compile without any errors, but will panic during
runtime with the message ~already borrowed: BorrowMutError~.

Choosing to catch borrowing errors at runtime rather than compile time, as we’ve
done here, means you’d potentially be finding mistakes in your code later in the
development process: possibly not until your code was deployed to production.
Also, your code would incur a small runtime performance penalty as a result of
keeping track of the borrows at runtime rather than compile time. You can use
~RefCell<T>~ despite its trade-offs to get more functionality than regular
references provide.

*** Having Multiple Owners of Mutable Data by Combining ~Rc<T>~ and ~RefCell<T>~

A common way to use ~RefCell<T>~ is in combination with ~Rc<T>~. Recall that
~Rc<T>~ lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an ~Rc<T>~ that holds a ~RefCell<T>~, you can
get a value that can have multiple owners /and/ that you can mutate!

Let's go back to the cons list. In the last example we used ~Rc<T>~ to allow
multiple lists to share ownership of another list. Because ~Rc<T>~ holds only
immutable values, we can’t change any of the values in the list once we’ve
created them. Let’s add in ~RefCell<T>~ to gain the ability to change the values
in the lists.

#+BEGIN_SRC rust :results output
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    println!("a before = {a:?}");
    println!("b before = {b:?}");
    println!("c before = {c:?}");

    *value.borrow_mut() += 10;
    //*(value.borrow_mut()) += 10; // Same as above but for clarity

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}
#+END_SRC

We create a value that is an instance of ~Rc<RefCell<i32>>~ and store it in a
variable named ~value~ so we can access it directly later. Then we create a
~List~ in ~a~ with a ~Cons~ variant that holds ~value~. We need to clone ~value~
so both ~a~ and ~value~ have ownership of the inner ~5~ value rather than
transferring ownership from value to ~a~ or having ~a~ borrow from ~value~.

We wrap the list ~a~ in an ~Rc<T>~ so when we create lists ~b~ and ~c~, they can
both refer to ~a~.

After we’ve created the lists in ~a~, ~b~, and ~c~, we want to add 10 to the
value in ~value~. We do this by calling ~borrow_mut~ on value, which uses the
automatic dereferencing feature to dereference the ~Rc<T>~ to the inner
~RefCell<T>~ value.

By using ~RefCell<T>~, we have an outwardly immutable ~List~ value. But we can
use the methods on ~RefCell<T>~ that provide access to its interior mutability
so we can modify our data when we need to. The runtime checks of the borrowing
rules protect us from data races, and it’s sometimes worth trading a bit of
speed for this flexibility in our data structures. Note that ~RefCell<T>~ does
not work for multithreaded code!

** Reference Cycles Can Leak Memory

Rust’s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a memory leak). We
can see that Rust allows memory leaks by using ~Rc<T>~ and ~RefCell<T>~: it’s
possible to create references where items refer to each other in a cycle. This
creates memory leaks because the reference count of each item in the cycle will
never reach 0, and the values will never be dropped.

*** Creating a Reference Cycle

Let's look at the following example:

#+BEGIN_SRC rust :results output
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}
#+END_SRC

We’re using another variation of the ~List~ definition. The second element in
the ~Cons~ variant is now ~RefCell<Rc<List>>~, meaning that instead of having
the ability to modify the ~i32~ value, we want to modify the ~List~ value a
~Cons~ variant is pointing to. We’re also adding a ~tail~ method to make it
convenient for us to access the second item if we have a ~Cons~ variant.

The ~main~ function creates a list in ~a~ and a list in ~b~ that points to the
list in ~a~. Then it modifies the list in ~a~ to point to ~b~, creating a
reference cycle.

The reference count of the ~Rc<List>~ instances in both ~a~ and ~b~ are 2 after
we change the list in ~a~ to point to ~b~. At the end of ~main~, Rust drops the
variable ~b~, which decreases the reference count of the ~b~ ~Rc<List>~ instance
from 2 to 1. The memory that ~Rc<List>~ has on the heap won’t be dropped at this
point, because its reference count is 1, not 0. Then Rust drops ~a~, which
decreases the reference count of the a ~Rc<List>~ instance from 2 to 1 as well.
This instance’s memory can’t be dropped either, because the other ~Rc<List>~
instance still refers to it. The memory allocated to the list will remain
uncollected forever.

If you uncomment the last ~println!~ and run the program, Rust will try to print
this cycle with ~a~ pointing to ~b~ pointing to ~a~ and so forth until it
overflows the stack.

*** Preventing Reference Cycles: Turning an ~Rc<T>~ into a ~Weak<T>~

So far, we’ve demonstrated that calling ~Rc::clone~ increases the ~strong_count~
of an ~Rc<T>~ instance, and an ~Rc<T>~ instance is only cleaned up if its
~strong_count~ is 0. You can also create a /weak reference/ to the value within
an ~Rc<T>~ instance by calling ~Rc::downgrade~ and passing a reference to the
~Rc<T>~. Strong references are how you can share ownership of an ~Rc<T>~
instance. Weak references don’t express an ownership relationship, and their
count doesn’t affect when an ~Rc<T>~ instance is cleaned up. They won’t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.

When you call ~Rc::downgrade~, you get a smart pointer of type ~Weak<T>~.
Instead of increasing the ~strong_count~ in the ~Rc<T>~ instance by 1, calling
~Rc::downgrade~ increases the ~weak_count~ by 1. The difference is the
~weak_count~ doesn’t need to be 0 for the ~Rc<T>~ instance to be cleaned up.

Because the value that ~Weak<T>~ references might have been dropped, to do
anything with the value that a ~Weak<T>~ is pointing to, you must make sure the
value still exists. Do this by calling the ~upgrade~ method on a ~Weak<T>~
instance, which will return an ~Option<Rc<T>>~. You’ll get a result of ~Some~ if
the ~Rc<T>~ value has not been dropped yet and a result of ~None~ if the ~Rc<T>~
value has been dropped.

**** Creating a Tree Data Structure: a Node with Child Nodes

To start, we’ll build a tree with nodes that know about their child nodes. We’ll
create a struct named ~Node~ that holds its own ~i32~ value as well as
references to its children ~Node~ values:

#+BEGIN_SRC rust :results output
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
#+END_SRC

We want a ~Node~ to own its children, and we want to share that ownership with
variables so we can access each ~Node~ in the tree directly. To do this, we
define the ~Vec<T>~ items to be values of type ~Rc<Node>~. We also want to
modify which nodes are children of another node, so we have a ~RefCell<T>~ in
~children~ around the ~Vec<Rc<Node>>~.

We clone the ~Rc<Node>~ in ~leaf~ and store that in ~branch~, meaning the ~Node~
in ~leaf~ now has two owners: ~leaf~ and ~branch~. We can get from ~branch~ to
~leaf~ through ~branch.children~, but there’s no way to get from ~leaf~ to
~branch~. The reason is that ~leaf~ has no reference to ~branch~ and doesn’t
know they’re related. We want ~leaf~ to know that ~branch~ is its parent.

**** Adding a Reference from a Child to Its Parent

To make the child node aware of its parent, we need to add a ~parent~ field to
our ~Node~ struct definition. The trouble is in deciding what the type of
~parent~ should be. We know it can’t contain an ~Rc<T>~, because that would
create a reference cycle with ~leaf.parent~ pointing to ~branch~ and
~branch.children~ pointing to ~leaf~, which would cause their ~strong_count~
values to never be 0.

Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references.

So instead of ~Rc<T>~, we’ll make the type of parent use ~Weak<T>~, specifically
a ~RefCell<Weak<Node>>~. Now our ~Node~ struct example looks like this:

#+BEGIN_SRC rust :results output
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:#?}", leaf.parent.borrow().upgrade());
}
#+END_SRC

A node will be able to refer to its parent node but doesn’t own its parent.

Creating the ~leaf~ node looks similar to before with the exception of the
~parent~ field: ~leaf~ starts out without a parent, so we create a new, empty
~Weak<Node>~ reference instance. Then to refer to the parent, we use the
~borrow_mut~ method on the ~RefCell<Weak<Node>>~ in the ~parent~ field of
~leaf~, and then we use the ~Rc::downgrade~ function to create a ~Weak<Node>~
reference to branch from the ~Rc<Node>~ in branch.

Note that the ~Weak<Node>~ references are printed as ~(Weak)~ when running the
example above. Otherwise we would again have ended in an infinite cycle that
eventually would have ended in a stack overflow.

**** Visualizing Changes to ~strong_count~ and ~weak_count~

#+BEGIN_SRC rust :results output
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }
    // branch (parent) is gone here

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
#+END_SRC

* Fearless Concurrency
** Using Threads to Run Code Simultaneously

Programming languages implement threads in a few different ways, and many
operating systems provide an API the language can call for creating new threads.
The Rust standard library uses a /1:1/ model of thread implementation, whereby a
program uses one operating system thread per one language thread. There are
crates that implement other models of threading that make different tradeoffs to
the 1:1 model.

*** Creating a New Thread with spawn

To create a new thread, we call the thread::spawn function and pass it a closure
containing the code we want to run in the new thread.

#+BEGIN_SRC rust :results output
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}
#+END_SRC

Note that when the main thread of a Rust program completes, all spawned threads
are shut down, whether or not they have finished running. The calls to
~thread::sleep~ force a thread to stop its execution for a short duration,
allowing a different thread to run. Even though we told the spawned thread to
print until ~i~ is 9, the main thread will most likely shut down before that and
terminate the program.

*** Waiting for All Threads to Finish Using ~join~ Handles

The return type of ~thread::spawn~ is ~JoinHandle~. A ~JoinHandle~ is an owned
value that, when we call the ~join~ method on it, will wait for its thread to
finish.

#+BEGIN_SRC rust :results output
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
#+END_SRC

Calling ~join~ on the handle blocks the thread currently running until the
thread represented by the handle terminates.

*** Using ~move~ Closures with Threads

We’ll often use the ~move~ keyword with closures passed to ~thread::spawn~
because the closure will then take ownership of the values it uses from the
environment, thus transferring ownership of those values from one thread to
another.

To use data from the main thread in the spawned thread, the spawned thread’s
closure must capture the values it needs.

#+BEGIN_SRC rust :results output
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}
#+END_SRC

The code above won't work. Rust /infers/ how to capture ~v~, and because
~println!~ only needs a reference to ~v~, the closure tries to borrow ~v~.
However, Rust can’t tell how long the spawned thread will run, so it doesn’t
know if the reference to v will always be valid.

By adding the ~move~ keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values.

#+BEGIN_SRC rust :results output
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}
#+END_SRC

By telling Rust to move ownership of ~v~ to the spawned thread, we’re
guaranteeing Rust that the main thread won’t use ~v~ anymore.

** Using Message Passing to Transfer Data Between Threads

To accomplish message-sending concurrency, Rust’s standard library provides an
implementation of /channels/. A channel is a general programming concept by
which data is sent from one thread to another.

#+BEGIN_SRC rust :results output
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
#+END_SRC

We create a new channel using the ~mpsc::channel~ function; ~mpsc~ stands for
/multiple producer, single consumer/. In the example above we only have one
producer though.

The ~mpsc::channel~ function returns a tuple, the first element of which is the
sending end - the transmitter - and the second element is the receiving end -
the receiver.

Then we move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread. The spawned
thread needs to own the transmitter to be able to send messages through the
channel, that's why we use the ~move~ keyword. The ~send~ method returns a
~Result<T, E>~ type, so if the receiver has already been dropped and there’s
nowhere to send a value, the send operation will return an error. In this
example, we’re calling ~unwrap~ to panic in case of an error.

The receiver has two useful methods: ~recv~ and ~try_recv~. We’re using ~recv~,
which will block the main thread’s execution and wait until a value is sent down
the channel. Once a value is sent, ~recv~ will return it in a ~Result<T, E>~.
When the transmitter closes, ~recv~ will return an error to signal that no more
values will be coming.

The ~try_recv~ method doesn’t block, but will instead return a ~Result<T, E>~
immediately: an ~Ok~ value holding a message if one is available and an ~Err~
value if there aren’t any messages this time.

*** Channels and Ownership Transference

The ~send~ function takes ownership of its parameter, and when the value is
moved, the receiver takes ownership of it. This stops us from accidentally using
the value again after sending it; the ownership system checks that everything is
okay. So the following code is not ok:

#+BEGIN_SRC rust :results output
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap(); // <-- val is moved here
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
#+END_SRC

*** Sending Multiple Values and Seeing the Receiver Waiting

#+BEGIN_SRC rust :results output
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            // thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}
#+END_SRC

The spawned thread has a vector of strings that we want to send to the main
thread. We iterate over them, sending each individually.

In the main thread, we’re not calling the ~recv~ function explicitly: instead,
we’re treating ~rx~ as an iterator. For each value received, we’re printing it.
When the channel is closed, iteration will end.

*** Creating Multiple Producers by Cloning the Transmitter

~mpsc~ is an acronym for /multiple producer, single consumer/. Let's create an
example with multiple producers.

#+BEGIN_SRC rust :results output
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_millis(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_millis(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}
#+END_SRC

Before we create the first spawned thread, we call ~clone~ on the transmitter.
This will give us a new transmitter we can pass to the first spawned thread. We
pass the original transmitter to a second spawned thread. This gives us two
threads, each sending different messages to the one receiver.

** Shared-State Concurrency
*** Using Mutexes to Allow Access to Data from One Thread at a Time

To access the data in a mutex, a thread must first signal that it wants access
by asking to acquire the mutex’s /lock/. The lock is a data structure that is
part of the mutex that keeps track of who currently has exclusive access to the
data. Therefore, the mutex is described as /guarding/ the data it holds via the
locking system.

Mutexes have a reputation for being difficult to use because you have to
remember two rules:

- You must attempt to acquire the lock before using the data.
- When you’re done with the data that the mutex guards, you must unlock the data
  so other threads can acquire the lock.

**** The API of Mutex<T>

Let’s start by using a mutex in a single-threaded context.

#+BEGIN_SRC rust :results output
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}
#+END_SRC

As with many types, we create a ~Mutex<T>~ using the associated function ~new~.
To access the data inside the mutex, we use the ~lock~ method to acquire the
lock. This call will block the current thread so it can’t do any work until it’s
our turn to have the lock.

The call to ~lock~ would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
~unwrap~ and have this thread panic if we’re in that situation.

After we’ve acquired the lock, we can treat the return value, named ~num~ in
this case, as a mutable reference to the data inside. The type of ~m~ is
~Mutex<i32>~, not ~i32~, so we /must/ call ~lock~ to be able to use the ~i32~
value.

~Mutex<T>~ is a smart pointer. More accurately, the call to ~lock~ returns a
smart pointer called ~MutexGuard~, wrapped in a ~LockResult~ that we handled
with the call to ~unwrap~. The ~MutexGuard~ smart pointer implements ~Deref~ to
point at our inner data; the smart pointer also has a ~Drop~ implementation that
releases the lock automatically when a ~MutexGuard~ goes out of scope, which
happens at the end of the inner scope. As a result, we don’t risk forgetting to
release the lock.

**** Sharing a Mutex<T> Between Multiple Threads

When sharing a ~Mutex<T>~ between multiple threads we will again run into the
problem that we will have to move the value into the closure. The following code
won't compile since we try to use the same mutex in many threads (it is moved
during the first iteration):

#+BEGIN_SRC rust :results output
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
#+END_SRC

Rust won't let us move the ownership of ~counter~ into multiple threads.

**** Multiple Ownership with Multiple Threads

We may be tempted to use the smart pointer ~Rc<T>~ to create a reference counted
value and cloning it before creating each thread. But replacting the ~counter~
value with ~Rc::new(Mutex::new(0))~ won't help as ~Rc<T>~ is only for single
threaded uses. The code will not compile.

The compile will complain with ~`Rc<Mutex<i32>>` cannot be sent between threads
safely~ and inform is that ~the trait `Send` is not implemented for
`Rc<Mutex<i32>>`~.

When ~Rc<T>~ manages the reference count, it adds to the count for each call to
~clone~ and subtracts from the count when each clone is dropped. But it doesn’t
use any concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts.

**** Atomic Reference Counting with ~Arc<T>~

~Arc<T>~ is a type like ~Rc<T>~ that is safe to use in concurrent situations.
The ~a~ stands for /atomic/, meaning it’s an ~atomically reference counted~
type.

~Arc<T>~ and ~Rc<T>~ have the same API. The code below looks similar to the
code in the previous example but now it makes use of ~Arc<Mutex<i32>>~. It
compiles and runs successfully.

#+BEGIN_SRC rust :results output
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0)); // Code changed here
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter); // Code changed here
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
#+END_SRC

Note that if you are doing simple numerical operations, there are types simpler
than ~Mutex<T>~ types provided by the
[[https://doc.rust-lang.org/std/sync/atomic/index.html][std::sync::atomic module of the standard library]]. These types provide safe,
concurrent, atomic access to primitive types.

*** Similarities Between ~RefCell<T>~/~Rc<T>~ and ~Mutex<T>~/~Arc<T>~

You might have noticed that ~counter~ is immutable but we could get a mutable
reference to the value inside it; this means ~Mutex<T>~ provides interior
mutability, as the ~Cell~ family does. In the same way we used ~RefCell<T>~
earlier to allow us to mutate contents inside an ~Rc<T>~, we use ~Mutex<T>~ to
mutate contents inside an ~Arc<T>~.

** Extensible Concurrency with the Sync and Send Traits

Interestingly, the Rust language has very few concurrency features. Almost every
concurrency feature discussed so far has been part of the standard library, not
the language. Your options for handling concurrency are not limited to the
language or the standard library; you can write your own concurrency features or
use those written by others.

However, two concurrency concepts are embedded in the language: the
~std::marker~ traits ~Sync~ and ~Send~.

*** Allowing Transference of Ownership Between Threads with ~Send~

The ~Send~ marker trait indicates that ownership of values of the type
implementing ~Send~ can be transferred between threads. Almost every Rust type
is ~Send~, but there are some exceptions, including ~Rc<T>~: this cannot be
~Send~ because if you cloned an ~Rc<T>~ value and tried to transfer ownership of
the clone to another thread, both threads might update the reference count at
the same time. For this reason, ~Rc<T>~ is implemented for use in
single-threaded situations where you don’t want to pay the thread-safe
performance penalty.

Therefore, Rust’s type system and trait bounds ensure that you can never
accidentally send a type that is not implementing ~Send~.

Any type composed entirely of ~Send~ types is automatically marked as ~Send~ as
well. Almost all primitive types are ~Send~, aside from raw pointers (more about
that later).

*** Allowing Access from Multiple Threads with ~Sync~

The ~Sync~ marker trait indicates that it is safe for the type implementing
~Sync~ to be referenced from multiple threads. In other words, any type ~T~ is
~Sync~ if ~&T~ (an immutable reference to ~T~) is ~Send~, meaning the reference
can be sent safely to another thread. Similar to ~Send~, primitive types are
~Sync~, and types composed entirely of types that are ~Sync~ are also ~Sync~.

*** Implementing ~Send~ and ~Sync~ Manually Is Unsafe

Because types that are made up of ~Send~ and ~Sync~ traits are automatically
also ~Send~ and ~Sync~, we don’t have to implement those traits manually. As
marker traits, they don’t even have any methods to implement. They’re just
useful for enforcing invariants related to concurrency.

Manually implementing these traits involves implementing unsafe Rust code.

** Ending notes

Because very little of how Rust handles concurrency is part of the language,
many concurrency solutions are implemented as crates. These evolve more quickly
than the standard library, so be sure to search online for the current,
state-of-the-art crates to use in multithreaded situations.

* Object-Oriented Programming Features of Rust
** Characteristics of Object-Oriented Languages

There is no consensus in the programming community about what features a
language must have to be considered object-oriented. Rust is influenced by many
programming paradigms, including OOP. Arguably, OOP languages share certain
common characteristics, namely objects, encapsulation, and inheritance.

** Using Trait Objects That Allow for Values of Different Types

Sometimes we want our library user to be able to extend the set of types that
are valid in a particular situation. We’ll create a library crate called ~gui~
that contains the structure of a GUI library. This crate might include some
types for people to use, such as ~Button~ or ~TextField~. In addition, ~gui~
users will want to create their own types that can be drawn: for instance, one
programmer might add an ~Image~ and another might add a ~SelectBox~.

At the time of writing the library, we can’t know and define all the types other
programmers might want to create. But we do know that ~gui~ needs to keep track
of many values of different types, and it needs to call a ~draw~ method on each
of these differently typed values. It doesn’t need to know exactly what will
happen when we call the ~draw~ method, just that the value will have that method
available for us to call.

*** Defining a Trait for Common Behavior

To implement the behavior we want ~gui~ to have, we’ll define a trait named
~Draw~ that will have one method named ~draw~. Then we can define a vector that
takes a /trait object/. A trait object points to both an instance of a type
implementing our specified trait and a table used to look up trait methods on
that type at runtime. We create a trait object by specifying some sort of
pointer, such as a ~&~ reference or a ~Box<T>~ smart pointer, then the ~dyn~
keyword, and then specifying the relevant trait. We can use trait objects in
place of a generic or concrete type. Wherever we use a trait object, Rust’s type
system will ensure at compile time that any value used in that context will
implement the trait object’s trait. Consequently, we don’t need to know all the
possible types at compile time.

In Rust, we refrain from calling structs and enums "objects" to distinguish them
from other languages’ objects. In a struct or enum, the data in the struct
fields and the behavior in ~impl~ blocks are separated, whereas in other
languages, the data and behavior combined into one concept is often labeled an
object. However, trait objects /are/ more like objects in other languages in the
sense that they combine data and behavior. But trait objects differ from
traditional objects in that we can’t add data to a trait object. Trait objects
aren’t as generally useful as objects in other languages: their specific purpose
is to allow abstraction across common behavior.

#+BEGIN_SRC rust :results output
pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}

impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#+END_SRC

The example above defines the ~Draw~ trait as one would expect. It also defines
a struct named ~Screen~ that holds a vector named ~components~. This vector is
of type ~Box<dyn Draw>~, which is a trait object; it’s a stand-in for any type
inside a ~Box~ that implements the ~Draw~ trait.

On the ~Screen~ struct, we have also defined a method named ~run~ that will call
the draw method on each of its components.

This works differently from defining a struct that uses a generic type parameter
with trait bounds. A generic type parameter can only be substituted with one
concrete type at a time, whereas trait objects allow for multiple concrete types
to fill in for the trait object at runtime. For example, we could have defined
the ~Screen~ struct using a generic type and a trait bound:

#+BEGIN_SRC rust :results output
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#+END_SRC

This restricts us to a ~Screen~ instance that has a list of components all of
type ~Button~ or all of type ~TextField~. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.

On the other hand, with the method using trait objects, one ~Screen~ instance
can hold a ~Vec<T>~ that contains a ~Box<Button>~ as well as a ~Box<TextField>~.

*** Implementing the Trait

Now we’ll add some types that implement the Draw trait. We’ll provide the
~Button~ type. The ~draw~ function will not to anything useful except printing
a message to stdout. We also define a ~SelectBox~ type. Note how both these
types both implement ~Draw~, but they have different fields available in the
structs. The different types can also implement more methods that only makes
sense for the own type (such as ~activate~ for ~Button~ below).

#+BEGIN_SRC rust :results output
pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}

impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}

#[derive(Debug)]
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // code to actually draw a select box
        println!("Drawing Button: {self:?}")
    }
}

impl Button {
    fn activate(&self) {
        println!("Button clicked")
    }
}

#[derive(Debug)]
struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // code to actually draw a select box
        println!("Drawing SelectBox: {self:?}")
    }
}

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
#+END_SRC

In the ~main~ function we add a ~SelectBox~ and a ~Button~ by putting each in a
~Box<T>~ to become a trait object. Then we call the ~run~ method on the ~Screen~
instance, which will call draw on each of the components.

A user using out lib can later add their own types which implements the ~Draw~
trait and it will still work. ~run~ doesn’t check whether a component is an
instance of a ~Button~ or a ~SelectBox~, it just calls the ~draw~ method on the
component. By specifying ~Box<dyn Draw>~ as the type of the values in the
~components~ vector, we’ve defined ~Screen~ to need values that we can call the
~draw~ method on.

*** Trait Objects Perform Dynamic Dispatch

In the generics section we discussed about the monomorphization process
performed by the compiler when we use trait bounds on generics: the compiler
generates nongeneric implementations of functions and methods for each concrete
type that we use in place of a generic type parameter. The code that results
from monomorphization is doing /static dispatch/, which is when the compiler
knows what method you’re calling at compile time. This is opposed to /dynamic
dispatch/, which is when the compiler can’t tell at compile time which method
you’re calling. In dynamic dispatch cases, the compiler emits code that at
runtime will figure out which method to call.

When we use trait objects, Rust must use dynamic dispatch. At runtime, Rust uses
the pointers inside the trait object to know which method to call. This lookup
incurs a runtime cost that doesn’t occur with static dispatch. Dynamic dispatch
also prevents the compiler from choosing to inline a method’s code, which in
turn prevents some optimizations. However, we did get extra flexibility in the
code that we wrote so it’s a trade-off to consider.

** Implementing an Object-Oriented Design Pattern

The /state pattern/ is an object-oriented design pattern. The crux of the
pattern is that we define a set of states a value can have internally. The
states are represented by a set of /state objects/, and the value’s behavior
changes based on its state. We’re going to work through an example of a blog
post struct that has a field to hold its state, which will be a state object
from the set "draft", "review", or "published".

The final functionality will look like this:

1. A blog post starts as an empty draft.
2. When the draft is done, a review of the post is requested.
3. When the post is approved, it gets published.
4. Only published blog posts return content to print, so unapproved posts can’t
   accidentally be published.

Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should remain an unpublished draft.

*** Defining Post and Creating a New Instance in the Draft State

We know we need a public ~Post~ struct that holds some content, so we’ll start
with the definition of the struct and an associated public ~new~ function to
create an instance of ~Post~. We’ll also make a private ~State~ trait that will
define the behavior that all state objects for a ~Post~ must have.

#+BEGIN_SRC rust :results output
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
#+END_SRC

~Post~ will hold a trait object of ~Box<dyn State>~ inside an ~Option<T>~ in a
private field named ~state~ to hold the state object. You’ll see why the
~Option<T>~ is necessary in a bit.

When we create a new ~Post~, we set its ~state~ field to a ~Some~ value that
holds a ~Box~. This ~Box~ points to a new instance of the ~Draft~ struct. This
ensures whenever we create a new instance of ~Post~, it will start out as a
draft. Because the ~state~ field of ~Post~ is private, there is no way to create
a ~Post~ in any other state!

We have also added a method named ~add_text~ which we can pass a ~&str~ that is
then added as the text content of the blog post. The ~add_text~ method takes a
mutable reference to ~self~, because we’re changing the ~Post~ instance that
we’re calling ~add_text~ on. This behavior doesn’t depend on the state the post
is in, so it’s not part of the state pattern.

*** Requesting a Review of the Post Changes Its State

Next, we need to add functionality to request a review of a post, which should
change its state from ~Draft~ to ~PendingReview~.

#+BEGIN_SRC rust :results output
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
#+END_SRC

We give ~Post~ a public method named ~request_review~ that will take a mutable
reference to ~self~. Then we call an internal ~request_review~ method on the
current state of ~Post~, and this second ~request_review~ method consumes the
current state and returns a new state.

We add the ~request_review~ method to the ~State~ trait. Note that rather than
having ~self~, ~&self~, or ~&mut self~ as the first parameter of the method, we
have ~self: Box<Self>~. This syntax means the method is only valid when called
on a ~Box~ holding the type. This syntax takes ownership of ~Box<Self>~,
invalidating the old state so the state value of the ~Post~ can transform into
a new state.

To consume the old state, the ~request_review~ method needs to take ownership of
the state value. This is where the ~Option~ in the ~state~ field of ~Post~ comes
in: we call the ~take~ method to take the ~Some~ value out of the ~state~ field
and leave a ~None~ in its place, because Rust doesn’t let us have unpopulated
fields in structs. This lets us move the ~state~ value out of ~Post~ rather than
borrowing it. Removing the ~take~ call would move the value and invalidate
~self.state~. ~take~ basically works like this:

#+BEGIN_SRC rust :results output
let mut x = Some(2);
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, Some(2));

let mut x: Option<u32> = None;
let y = x.take();
assert_eq!(x, None);
assert_eq!(y, None);
#+END_SRC

We need to set ~state~ to ~None~ temporarily rather than setting it directly
with code like ~self.state = self.state.request_review();~ to get ownership of
the ~state~ value. This ensures ~Post~ can’t use the old ~state~ value after
we’ve transformed it into a new state.

The ~request_review~ method on ~Draft~ returns a new, boxed instance of a new
~PendingReview~ struct, which represents the state when a post is waiting for a
review. The ~PendingReview~ struct also implements the ~request_review~ method
but doesn’t do any transformations. Rather, it returns itself, because when we
request a review on a post already in the ~PendingReview~ state, it should stay
in the PendingReview state.

*** Ensuring the Content of a Draft Post Is Empty

Even after we’ve called ~add_text~ and added some content to our post, we still
want the ~content~ method to return an empty string slice because the post is
still in the draft state.

*** Adding ~approve~ and ~content~ methods

The ~approve~ method will be similar to the ~request_review~ method: it will set
~state~ to the value that the current state says it should have when that state
is approved.

We add the ~approve~ method to the ~State~ trait and add a new struct that
implements ~State~, the ~Published~ state. The ~approve~ method will have to be
defined for the other states as well of course. The implementation is very
similar to ~request_review~.

We have also added a ~content~ method on ~Post~. We want the value returned from
~content~ to depend on the current state of the ~Post~, so we’re going to have
the ~Post~ delegate to a ~content~ method defined on its ~state~.

Because the goal is to keep all these rules inside the structs that implement
~State~, we call a ~content~ method on the value in ~state~ and pass the post
instance (that is, ~self~) as an argument. Then we return the value that’s
returned from using the ~content~ method on the ~state~ value.

We call the ~as_ref~ method on the ~Option~ because we want a reference to the
value inside the ~Option~ rather than ownership of the value. Because ~state~ is
an ~Option<Box<dyn State>>~, when we call ~as_ref~, an ~Option<&Box<dyn State>>~
is returned. If we didn’t call ~as_ref~, we would get an error because we can’t
move ~state~ out of the borrowed ~&self~ of the function parameter. We then call
the ~unwrap~ method, which we know will never panic because ~state~ will never
be ~None~.

At this point, when we call ~content~ on the ~&Box<dyn State>~, deref coercion
will take effect on the ~&~ and the ~Box~ so the ~content~ method will
ultimately be called on the type that implements the ~State~ trait. That means
we need to add ~content~ to the ~State~ trait definition, and that is where
we’ll put the logic for what content to return depending on which state we have:

#+BEGIN_SRC rust :results output
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

    pub fn content(&self) -> &str { // <--- Added content method
        self.state.as_ref().unwrap().content(self)
    }

    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }

    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;

    fn content<'a>(&self, post: &'a Post) -> &'a str { // <--- Added content method
        "" // <--- With default implementation
    }
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn content<'a>(&self, post: &'a Post) -> &'a str { // <--- Content overridden here
        &post.content
    }
}

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
#+END_SRC

We add a default implementation for the ~content~ method that returns an empty
string slice. That means we don’t need to implement ~content~ on the ~Draft~ and
~PendingReview~ structs.

Note that we need lifetime annotations on this method. We’re taking a reference
to a ~post~ as an argument and returning a reference to part of that ~post~, so
the lifetime of the returned reference is related to the lifetime of the ~post~
argument.

*** Implementation with enums instead

TODO

*** Encoding States and Behavior as Types

We’ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we’ll encode the states into different
types. Consequently, Rust’s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.

In the example below you can only call ~add_text~ on a ~DraftPost~ and call the
~content~ method on a ~Post~. Also the ~request_review~ and ~approve~ methods
can only be called at the appropriate stages.

Also note how ~Post::new~ returns a ~DraftPost~ instead of a ~Post~. From
outside this module the only way to get a ~Post~ instance is by calling the
~Post::new~ and then call ~request_review~ to get a ~PendingReviewPost~ which
you then have to ~approve~ in order to get a ~Post~.

#+BEGIN_SRC rust :results output
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
#+END_SRC

* Patterns and Matching

/Patterns/ are a special syntax in Rust for matching against the structure of
types, both complex and simple. A pattern consists of some combination of the
following:

- Literals
- Destructured arrays, enums, structs, or tuples
- Variables
- Wildcards
- Placeholders

Some example patterns include ~x~, ~(a, 3)~, and ~Some(Color::Red)~.

** All the Places Patterns Can Be Used

This section discusses all the places where patterns are valid.

*** ~match~ Arms

Formally, ~match~ expressions are defined as the keyword ~match~, a value to
match on, and one or more match arms that consist of a pattern and an expression
to run if the value matches that arm’s pattern:

#+BEGIN_SRC
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
#+END_SRC

E.g.

#+BEGIN_SRC rust :results output
let mut o: Option<i32> = Some(5);

o = match o {
    None => None,
    Some(i) => Some(i + 1),
};

println!("{:?}", o)
#+END_SRC

One requirement for ~match~ expressions is that they need to be /exhaustive/ in
the sense that all possibilities for the value in the match expression must be
accounted for. One way to ensure you’ve covered every possibility is to have a
catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.

*** Conditional ~if let~ Expressions

~if let~ expressions can be used as a shorter way to write the equivalent of a
~match~ that only matches one case. Optionally, ~if let~ can have a
corresponding ~else~ containing code to run if the pattern in the ~if let~
doesn’t match.

You are allowed to mix and match ~if let~, ~else if~, and ~else if let~
expressions. Rust doesn’t require that the conditions in such a sequence relate
to each other. E.g.:

#+BEGIN_SRC rust :results output
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age { // <--- age becomes shadowed here
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
#+END_SRC

The downside of using ~if let~ expressions is that the compiler doesn’t check
for exhaustiveness.

*** The ~let else~ expression

With ~let~-~else~, a refutable pattern can match and bind variables in the
surrounding scope like a normal ~let~, or else diverge (e.g. ~break~, ~return~,
~panic!~) when the pattern doesn't match.

#+BEGIN_SRC rust :results output
use std::str::FromStr;

fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    (count, item)
}

fn main() {
    assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
}
#+END_SRC

*** ~while let~ Conditional Loops

The ~while let~ conditional loop allows a while loop to run for as long as a
pattern continues to match.

#+BEGIN_SRC rust :results output
fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{top}");
    }
}
#+END_SRC

The ~pop~ method takes the last element out of the vector and returns
~Some(value)~. If the vector is empty, ~pop~ returns ~None~. When ~pop~ returns
~None~, the loop stops.

*** ~for~ Loops

In a ~for~ loop, the value that directly follows the keyword ~for~ is a pattern.
Here the ~for~ loop destructure, or break apart, a tuple as part of the for
loop:

#+BEGIN_SRC rust :results output
fn main() {
    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
}
#+END_SRC

We adapt an iterator using the ~enumerate~ method so it produces a value and the
index for that value, placed into a tuple. The first value produced is the tuple
~(0, 'a')~. When this value is matched to the pattern ~(index, value)~, index
will be ~0~ and value will be ~'a'~, printing the first line of the output.

*** ~let~ Statements

Consider this straightforward variable assignment with let:

#+BEGIN_SRC rust :results output
let x = 5;
#+END_SRC

Actually, a ~let~ statement looks like this:

#+BEGIN_SRC
let PATTERN = EXPRESSION;
#+END_SRC

So in the ~let x = 5;~ example, ~x~ is a pattern that means "bind what matches
here to the variable ~x~".

To see the pattern matching aspect of ~let~ more clearly the following example
uses a pattern with ~let~ to destructure a tuple.

#+BEGIN_SRC rust :results output
fn main() {
    let (x, y, z) = (1, 2, 3);
    println!("{x}");
    println!("{y}");
    println!("{z}");
}
#+END_SRC

Rust binds ~1~ to ~x~, ~2~ to ~y~, and ~3~ to ~z~.

*** Function Parameters

Function parameters can also be patterns:

#+BEGIN_SRC rust :results output
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
#+END_SRC

We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions.

** Refutability: Whether a Pattern Might Fail to Match

Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are /irrefutable/. An example would be ~x~ in the
statement ~let x = 5;~ because ~x~ matches anything and therefore cannot fail to
match. Patterns that can fail to match for some possible value are /refutable/.
An example would be ~Some(x)~ in the expression ~if let Some(x) = a_value~
because if the value in the ~a_value~ variable is ~None~ rather than ~Some~, the
~Some(x)~ pattern will not match.

Function parameters, ~let~ statements, and ~for~ loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values don’t match. The ~if let~ and ~while let~ expressions accept refutable
and irrefutable patterns, but the compiler warns against irrefutable patterns
because by definition they’re intended to handle possible failure: the
functionality of a conditional is in its ability to perform differently
depending on success or failure.

~match~ arms must use refutable patterns, except for the last arm, which should
match any remaining values with an irrefutable pattern. Rust allows us to use an
irrefutable pattern in a ~match~ with only one arm, but this syntax isn’t
particularly useful and could be replaced with a simpler let statement.

In general, you shouldn’t have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message.

** Pattern Syntax

*** Matching Literals

#+BEGIN_SRC rust :results output
fn main() {
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
}
#+END_SRC

This syntax is useful when you want your code to take an action if it gets a
particular concrete value.

*** Matching Named Variables

#+BEGIN_SRC rust :results output
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {y}"),  // <-- Doesn't mean Some(10) as y here shadows y above
                                                  // This is the arm that will match
        _ => println!("Default case, x = {x:?}"), // Only None will match this case
    }

    println!("at the end: x = {x:?}, y = {y}");
}
#+END_SRC

*** Multiple Patterns

In ~match~ expressions, you can match multiple patterns using the ~|~ syntax,
which is the pattern or operator.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
}
#+END_SRC

*** Matching Ranges of Values with ~..=~

The ~..=~ syntax allows us to match to an inclusive range of values. Exclusive
range of values doesn't seem to exist.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;

    match x {
        0..=5 => println!("one through five"),
        _ => println!("something else"),
    }
}
#+END_SRC

Leaving one end blank seems to be allowed as well:

#+BEGIN_SRC rust :results output
fn main() {
    let x = -5;

    match x {
        ..=0 => println!("Smaller than or equal to 0"),
        100.. => println!("Greater than or equal to 100"),
        _ => println!("something else"),
    }
}
#+END_SRC

The compiler checks that the range isn’t empty at compile time, and because the
only types for which Rust can tell if a range is empty or not are ~char~ and
numeric values, ranges are only allowed with numeric or ~char~ values.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
}
#+END_SRC

*** Destructuring to Break Apart Values

We can also use patterns to destructure structs, enums, and tuples to use
different parts of these values.

**** Destructuring Structs

Here we have a ~Point~ struct with two fields, ~x~ and ~y~, that we can break
apart using a pattern with a ~let~ statement.

#+BEGIN_SRC rust :results output
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
#+END_SRC

The names of the variables in the pattern don’t have to match the field names of
the struct. However, it’s common to match the variable names to the field names
to make it easier to remember which variables came from which fields. Because of
this common usage, and because writing ~let Point { x: x, y: y } = p;~ contains
a lot of duplication, Rust has a shorthand for patterns that match struct
fields: you only need to list the name of the struct field, and the variables
created from the pattern will have the same names.

#+BEGIN_SRC rust :results output
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
#+END_SRC

The outcome is that the variables ~x~ and ~y~ contain the values from the ~p~
struct.

We can also destructure with literal values as part of the struct pattern rather
than creating variables for all the fields. Doing so allows us to test some of
the fields for particular values while creating variables to destructure the
other fields.

#+BEGIN_SRC rust :results output
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
#+END_SRC

**** Destructuring Enums

We use the ~Message~ enum from earlier and write a ~match~ with patterns that
will destructure each inner value:

#+BEGIN_SRC rust :results output
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) => {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {r}, green {g}, and blue {b}")
        }
    }
}
#+END_SRC

For enum variants without any data, like ~Message::Quit~, we can’t destructure
the value any further. We can only match on the literal ~Message::Quit~ value,
and no variables are in that pattern.

For struct-like enum variants, such as ~Message::Move~, we can use a pattern
similar to the pattern we specify to match structs.

For tuple-like enum variants, like ~Message::Write~ that holds a tuple with one
element and ~Message::ChangeColor~ that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples.

**** Destructuring Nested Structs and Enums

Matching can work on nested items too. Now the color in ~ChangeColor~ support
RGB and HSV colors:

#+BEGIN_SRC rust :results output
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("Change color to hue {h}, saturation {s}, value {v}")
        }
        _ => (),
    }
}
#+END_SRC

We can specify these complex conditions in one ~match~ expression, even though
two enums are involved.

**** Destructuring Structs and Tuples

We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:

#+BEGIN_SRC rust :results output
fn main() {
    struct Point {
        x: i32,
        y: i32,
    }

    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
    println!("{feet}");
    println!("{inches}");
    println!("{x}");
    println!("{y}");
}
#+END_SRC

*** Ignoring Values in a Pattern

There are a few ways to ignore entire values or parts of values in a pattern:
using the ~_~ pattern, using the ~_~ pattern within another pattern, using a
name that starts with an underscore, or using ~..~ to ignore remaining parts of
a value.

**** Ignoring an Entire Value with ~_~

We’ve used the underscore as a wildcard pattern that will match any value but
/not bind to the value/. This is especially useful as the last arm in a match
expression, but we can also use it in any pattern, including function
parameters.

#+BEGIN_SRC rust :results output
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}
#+END_SRC

**** Ignoring Parts of a Value with a Nested ~_~

We can also use ~_~ inside another pattern to ignore just part of a value.

#+BEGIN_SRC rust :results output
fn main() {
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
}
#+END_SRC

We can also use underscores in multiple places within one pattern to ignore
particular values:

#+BEGIN_SRC rust :results output
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
}
#+END_SRC

**** Ignoring an Unused Variable by Starting Its Name with ~_~

If you create a variable but don’t use it anywhere, Rust will usually issue a
warning because an unused variable could be a bug. You can tell Rust not to warn
you about the unused variable by starting the name of the variable with an
underscore.

#+BEGIN_SRC rust :results output
fn main() {
    let _x = 5;
    let y = 10;
}
#+END_SRC

Note that there is a subtle difference between using only ~_~ and using a name
that starts with an underscore. The syntax ~_x~ still binds the value to the
variable, whereas ~_~ doesn’t bind at all. This won't compile:

#+BEGIN_SRC rust :results output
fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_s) = s { // <-- Value "partially" moved here
        println!("found a string");
    }

    println!("{s:?}"); // <-- s not valid here
}
#+END_SRC

But this example compiles just fine:

#+BEGIN_SRC rust :results output
fn main() {
    let s = Some(String::from("Hello!"));

    if let Some(_) = s { // <-- Value not moved here
        println!("found a string");
    }

    println!("{s:?}");
}
#+END_SRC

**** Ignoring Remaining Parts of a Value with ~..~

With values that have many parts, we can use the ~..~ syntax to use specific
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. E.g.:

#+BEGIN_SRC rust :results output
fn main() {
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 1, z: 2 };

    match origin {
        Point { x, .. } => println!("x is {x}"),
    }

    match origin {
        Point { y, .. } => println!("y is {y}"), // The arguments doesn't have to be in order
                                                 // so y can also be easily extracted
    }

    let Point{x:_, y:_, z} = origin; // Without ..
    println!("{z}")
}
#+END_SRC

The syntax ~..~ will expand to as many values as it needs to be:

#+BEGIN_SRC rust :results output
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }
}
#+END_SRC

*** Extra Conditionals with Match Guards

A /match guard/ is an additional ~if~ condition, specified after the pattern in
a ~match~ arm, that must also match for that arm to be chosen. Match guards are
useful for expressing more complex ideas than a pattern alone allows. E.g.

#+BEGIN_SRC rust :results output
fn main() {
    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 => println!("The number {x} is even"),
        Some(x) => println!("The number {x} is odd"),
        None => (),
    }
}
#+END_SRC

There is no way to express the ~if x % 2 == 0~ condition within a pattern, so
the match guard gives us the ability to express this logic. The downside of this
additional expressiveness is that the compiler doesn’t try to check for
exhaustiveness when match guard expressions are involved. So even though the
expression below handles all cases Rust can't see that and we will have to
rewrite it.

#+BEGIN_SRC rust :results output
fn main() {
    let num = Some(4);

    let my = match num {
        Some(x) if x % 2 == 0 => 1,
        Some(x) if x % 2 == 1 => 2,
        //Some(_) => 2,
        None => 3,
    };
    println!("{my}")
}
#+END_SRC

We can also now match against other variable in our ~match~ statement:

#+BEGIN_SRC rust :results output
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {n}"),
        _ => println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}
#+END_SRC

When using with the /or/ operator ~|~ it will apply to all patterns. E.g.

#+BEGIN_SRC
4 | 5 | 6 if y => ...
#+END_SRC

is interpreted like

#+BEGIN_SRC
(4 | 5 | 6) if y => ...
// Not
4 | 5 | (6 if y) => ...
#+END_SRC

*** ~@~ Bindings

The at operator ~@~ lets us create a variable that holds a value at the same
time as we’re testing that value for a pattern match. We want to test that a
~Message::Hello~ ~id~ field is within the range ~3..=7~. We also want to bind
the value to the variable ~id_variable~ so we can use it in the code associated
with the arm. We could name this variable ~id~, the same as the field, but for
this example we’ll use a different name.

#+BEGIN_SRC rust :results output
fn main() {
    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range") // <-- id var can't be used in this context
        }
        Message::Hello { id } => println!("Found some other id: {id}"),
    }
}
#+END_SRC

By specifying ~id_variable @~ before the range ~3..=7~, we’re capturing whatever
value matched the range while also testing that the value matched the range
pattern.

In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the ~id~ field. The ~id~ field’s value could have been 10, 11, or 12, but the
code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the ~id~ field, because we haven’t saved the
~id~ value in a variable.

* Debug

https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits

* Crates and dependencies

When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the registry, which is a copy of data from
[[https://crates.io/]]. crates.io is where people in the Rust ecosystem post their
open source Rust projects for others to use.

* Documentation

Another neat feature of Cargo is that you can run the command below, which will
build documentation provided by all of your dependencies locally and open it in
your browser.

#+BEGIN_SRC bash :noeval
cargo doc --open
#+END_SRC

* Style guide

https://doc.rust-lang.org/1.0.0/style/style/naming/README.html

* Clippy

https://doc.rust-lang.org/clippy/

* Misc

Can a immutable var become mutable? Write an example where a function returns
a ~String~ and assign it to both mutable and immutable variables.

** Test: Is an array slice and a vector slice the same?

#+BEGIN_SRC rust :results output
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}

fn main() {
    let a = [1, 2, 3, 4, 5];
    let v = vec![1, 2, 3, 4, 5];
    print_type_of(&a);
    print_type_of(&v);
    let a_slice = &a[1..3];
    let v_slice = &v[1..3];
    print_type_of(&a_slice);
    print_type_of(&v_slice);
}
#+END_SRC

#+BEGIN_SRC rust :results output
fn print_array(a: &[i32; 3]) {
    for e in a {
        println!("Array element: {e}");
    }
}

fn print_vector(v: &Vec<i32>) {
    for e in v {
        println!("Vector element: {e}");
    }
}

fn print_slice(s: &[i32]) {
    for e in s {
        println!("Slice element: {e}");
    }
}

fn main() {
    let a = [1, 2, 3];
    let v = vec![1, 2, 3];
    print_array(&a);
    //print_array(&v);
    print_vector(&v);
    //print_vector(&a);
    print_slice(&a);
    print_slice(&v);
}
#+END_SRC

Conclusion: Yes, it looks like the slices are treated the same.

** Test: Iterating over arrays and vectors

#+BEGIN_SRC rust :results output
fn main() {
    let v = vec![1, 2, 3];
    //for e in &v { // This will work
    for e in v {
        println!("Slice element: {e}");
    }
    for e in v {
        println!("Slice element: {e}");
    }
}
#+END_SRC

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3];
    for e in a {
        println!("Slice element: {e}");
    }
    for e in a {
        println!("Slice element: {e}");
    }
}
#+END_SRC

Why does the lower example work even though we don't use borrowing? Something
with the ~Copy~ trait?

* Questions

- Can I create an ~impl~ block for an object not defined by me?
- How does lifetimes work with methods? Comparing self with other and return a field from one of them?
- What is the static lifetime?
- Global variables?
- Casting
  - ~as~ https://dev.to/iamdipankarpaul/understanding-type-casting-in-rust-34il https://www.programiz.com/rust/type-casting
  - ~into~ and ~tryInto~
- ~Refcell<Rc<_>>~ vs ~Rc<Refcell<_>>~
- Variables on global scope
- arrays slices to funcs
- automatic referencing when calling a function? is that possible?

* Things to investigate

What is ~pub(crate)~:
https://doc.rust-lang.org/reference/visibility-and-privacy.html

~pub async fn name~
~args: &[&dyn ToSql]~
~TryFrom<Something, Error>~
~argument: &[Object]~

#+BEGIN_SRC rust :noeval
let cause = err.unwrap_err();
warn!(%cause, "failed");
#+END_SRC

~let Ok(asadasd) = Something else {}~
chain ~pub~ modules. What if one in the middle is removed

~rustfm~
~From~ trait
Use ~?~ to convert error to option?
Return error codes
