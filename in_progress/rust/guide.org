* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#links][Links]]
  - [[#tutorials][Tutorials]]
  - [[#cargo][Cargo]]
  - [[#api][API]]
- [[#other-things-to-look-at][Other things to look at]]
- [[#getting-started][Getting started]]
  - [[#installation][Installation]]
  - [[#hello-world][Hello, World]]
  - [[#hello-cargo][Hello, Cargo]]
- [[#guessing-game][Guessing game]]
- [[#common-programming-concepts][Common Programming Concepts]]
  - [[#variable-and-mutability][Variable and Mutability]]
  - [[#data-types][Data Types]]
  - [[#functions][Functions]]
  - [[#comments][Comments]]
  - [[#control-flow][Control Flow]]
- [[#crates-and-dependencies][Crates and dependencies]]
- [[#documentation][Documentation]]
- [[#style-guide][Style guide]]
- [[#clippy][Clippy]]
- [[#misc][Misc]]
#+END_QUOTE

* Links
** Tutorials

- https://lborb.github.io/
- https://doc.rust-lang.org/book/
- https://github.com/rust-lang/rustlings/
- https://doc.rust-lang.org/stable/rust-by-example/

** Cargo

- https://doc.rust-lang.org/cargo/
- https://crates.io/

** API

- https://doc.rust-lang.org/std/index.html

* Other things to look at

- ~rustfmt~ command
- The prelude: https://doc.rust-lang.org/std/prelude/index.html

* Getting started
** Installation

https://doc.rust-lang.org/book/ch01-01-installation.html

#+BEGIN_SRC bash :noeval
curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh
cargo install rust-script # Run rust files as scripts. Needed for emacs babel
                          # Make sure the script is on your path afterwards!
rust-script --version
#+END_SRC

*** Update

Once Rust is installed via rustup, when a new version of Rust is released,
updating to the latest version is easy. From your shell, run the following
update script:

#+BEGIN_SRC bash :noeval
rustup update
#+END_SRC

*** Get documentation

The installation of Rust also includes a local copy of the documentation, so you
can read it offline. Run rustup doc to open the local documentation in your
browser.

#+BEGIN_SRC bash :noeval
rustup doc
#+END_SRC

This didn't work on my machine since [[https://stackoverflow.com/questions/55961953/access-denied-when-i-run-rustup-doc][firefox was installed with snap]] but I could
get it to work with:

#+BEGIN_SRC bash :noeval
google-chrome ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/index.html
#+END_SRC

** Hello, World

Files in rust are on the format ~program_name.rs~. Words should be separated with ~_~.

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
}
#+END_SRC

*** Compile it

Add the code from the file above in a file called ~hello_world.rs~, compile it
with ~rustc~ and execute the produced file, ~~hello_world~:

#+BEGIN_SRC bash :noeva
rustc hello_world.rs
./hello_world
#+END_SRC

*** Things to note

1. The main ~function~ is special: it is always the first code that runs in
   every executable Rust program. The first line declares a function named main
   that has no parameters and returns nothing. If there were parameters, they
   would go inside the parentheses, ~()~.
2. ~println!~ calls a Rust macro. If it called a function instead, it would be
   entered as ~println~ (without the ~!~). TODO: Link to macro section
3. Rust style is to indent with four spaces, not a tab. Run
   ~rustfmt hello_world.rs~ to format code according to the standard.

** Hello, Cargo

Cargo handles a lot of tasks for you, such as building your code, downloading
the libraries your code depends on, and building those libraries.

All code in this section is available in the [[file:001_hello_cargo][001_hello_cargo]] directory.

*** Creating a project

In a directory where you want to create a project, run:

#+BEGIN_SRC bash :noeval
cargo new hello_cargo
cd hello_cargo
#+END_SRC

This created the following file structure:

#+BEGIN_SRC
.
`-- hello_cargo
    |-- Cargo.toml
    `-- src
        `-- main.rsl
#+END_SRC

The ~Cargo.toml~ file looks like this:

#+BEGIN_SRC toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#+END_SRC

The ~[package]~ heading, is a section heading that indicates that the following
statements are configuring a package.

The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use.

The ~[dependencies]~ heading, is the start of a section for you to list any of
your project’s dependencies (known as /crates/ in Rust).

Cargo expects your source files to live inside the ~src~ directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code.

*** Building and Running a Cargo Project

To build the project, run the following command while standing in the
~hello_cargo~ directory:

#+BEGIN_SRC bash :noeval
cargo build
#+END_SRC

A file is then created in ~target/debug/hello_cargo~. Run it by running the
following command:

#+BEGIN_SRC bash :noeval
./target/debug/hello_cargo
#+END_SRC

The default build is a ~debug~ build and that's why the binary ends up in that
directory.

You may notice that ~cargo build~ also creates a ~Cargo.lock~ in the top level
directory. This file keeps track of the exact versions of dependencies in your
project. Cargo understands [[https://semver.org/][Semantic Versioning]]. If you specify the version
~0.8.3~ this is actually a shorthand for ~^0.8.3~, meaning any version that is
at least ~0.8.3~ but below ~0.9.0~. Between builds the ~Cargo.lock~ file will
guarantee that the same version is used until you explicitly upgrade the
version. You should never need to update this file manually. If you want to make
cargo to reevaluate the version (finding a suitable version at least ~0.8.3~ but
below ~0.9.0~) you can run:

#+BEGIN_SRC bash :noeval
cargo update
#+END_SRC

You can both compile and run the project in one step by running:

#+BEGIN_SRC bash :noeval
cargo run
#+END_SRC

Cargo will automatically figure out what needs to be recompiled and what doesn't.

If you only want to make sure that the project compiles but not actually compile
the project you can run:

#+BEGIN_SRC bash :noeval
cargo check
#+END_SRC

This is much faster than actually compiling the code during development.

*** Building for release

You maybe noticed that the compile binary ended up in ~target/debug~. This is
a development build. They are faster to compile but are not optimized. In order
to optimize the build (which will also increase the build time) you should run
the following command:

#+BEGIN_SRC bash :noeval
cargo build --release
# --release can be used with run as well
cargo run --release
#+END_SRC

This result will end up in ~target/release~ instead of ~target/debug~ now.

* Guessing game

Code and comments for the guessing game is located in [[file:002_guessing_game][002_guessing_game]].

* Common Programming Concepts
** Variable and Mutability

By default variables are immutable. The code below won't compile since you are
trying to reassign the value of an immutable variable.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

But mutability can be very useful. Variables are immutable only by default and
you can make them mutable by adding ~mut~ in front of the variable name. In
addition to allowing this value to change, ~mut~ conveys intent to future
readers of the code by indicating that other parts of the code will be changing
this variable’s value.

#+BEGIN_SRC rust :results output
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+END_SRC

*** Constants

Rust also supports constants using the ~const~ keyword. An immutable variable
and a constant are not exactly the same in Rust.

- You aren’t allowed to use ~mut~ with constants, they're always immutable.
- You declare constants using the ~const~ keyword instead of the ~let~ keyword
- The type of the value /must/ be annotated
- Constants can be declared in any scope, including the global scope
- Constants may be set only to a constant expression, not the result of a value
  that could only be computed at runtime

Rust’s naming convention for constants is to use all uppercase with underscores
between words.

#+BEGIN_SRC rust :results output
fn main() {
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
    println!("{}", THREE_HOURS_IN_SECONDS)
}
#+END_SRC

*** Shadowing

You can declare a new variable with the same name as a previous variable.
Rustaceans say that the first variable is /shadowed/ by the second, which means
that the second variable’s value is what the program sees when the variable is
used.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;

    // This is allowed even though the previous 'x' isn't mutable since this
    // actually creates a new variable 'x' that shadows the previous one
    let x = x + 1;

    {
        // Also this 'x' will shadow the previous 'x'
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x); // 12
    }

    // The inner shadowing end and 'x' returns to bering 6
    println!("The value of x is: {}", x);
}
#+END_SRC

A shadowing variable can also use a different type. E.g. maybe we want to store
a string with spaces (e.g. for indentation) as an integer instead, the following
code would be allowed:

#+BEGIN_SRC rust :results output
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

Using a mutable variable to achieve the same wouldn't work as that would change
the type of the variable:

#+BEGIN_SRC rust :results output
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
    println!("{}", spaces)
}
#+END_SRC

** Data Types

Rust is a statically typed language, meaning that all values in Rust is of a
certain data type and that they must be known at compile time. The compiler can
usually infer what type we want to use based on the value and how we use it. In
cases when many types are possible, we must add a type annotation, like this:

#+BEGIN_SRC rust :noeval
let guess: u32 = "42".parse().expect("Not a number!");
#+END_SRC

*** Scalar Types

A scalar type represents a single value. Rust has four primary scalar types:
- integers
- floating-point numbers
- booleans
- characters

**** Integer Types

Integer types in Rust:

| Length  | Signed  | Unsigned |
|---------+---------+----------|
| 8-bit   | ~i8~    | ~u8~     |
| 16-bit  | ~i16~   | ~u16~    |
| 32-bit  | ~i32~   | ~u32~    |
| 64-bit  | ~i64~   | ~u64~    |
| 128-bit | ~i128~  | ~u128~   |
| arch    | ~isize~ | ~usize~  |

the ~isize~ and ~usize~ types depend on the kind of computer your program is
running on: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on
a 32-bit architecture.

You can write integer literals in any of the forms shown in the table below.
Note that number literals that can be multiple numeric types allow a type suffix,
such as ~57u8~, to designate the type. Number literals can also use ~_~ as a
visual separator to make the number easier to read, such as ~1_000~, which will
have the same value as if you had specified ~1000~.

| Number literals  | Example       |
|------------------+---------------|
| Decimal          | ~98_222~      |
| Hex              | ~0xff~        |
| Octal            | ~0o77~        |
| Binary           | ~0b1111_0000~ |
| Byte (~u8~ only) | ~b'A'~        |

Integer types default to ~i32~. The primary situation in which you’d use ~isize~
or ~usize~ is when indexing some sort of collection.

***** Overflow

Compiling in debug mode will cause the program to /panic/ at runtime if
overflow occurs. When compiling with the ~--release~ flag, no such checks are
included and Rust will perform /two's complement wrapping/. Relying on integer
overflow’s wrapping behavior is considered an error.

To explicitly handle the possibility of overflow, you can use these families of
methods that the standard library provides on primitive numeric types:

- Wrap in all modes with the ~wrapping_*~ methods, such as ~wrapping_add~
- Return the ~None~ value if there is overflow with the ~checked_*~ methods
- Return the value and a boolean indicating whether there was overflow with the
  ~overflowing_*~ methods
- Saturate at the value’s minimum or maximum values with ~saturating_*~ methods

**** Floating-Point Types

Rust’s floating-point types are ~f32~ and ~f64~, which are 32 bits and 64 bits
in size, respectively. The default type is ~f64~ because on modern CPUs it’s
roughly the same speed as ~f32~ but is capable of more precision.

#+BEGIN_SRC rust :results output
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32

    println!("x: {}", x);
    println!("y: {}", y)
}
#+END_SRC

**** Numeric Operations

#+BEGIN_SRC rust :results output
fn main() {
    // addition
    let sum = 5 + 10;
    println!("sum: {}", sum);

    // subtraction
    let difference = 95.5 - 4.3;
    println!("difference: {}", difference);

    // multiplication
    let product = 4 * 30;
    println!("product: {}", product);

    // division
    let quotient = 56.7 / 32.2;
    // The following will fail since you can't divide a float with an int
    //let quotient = 56.7 / 32;
    // The following will work though
    //let quotient = 56.7 / 32f64;
    let floored = 2 / 3; // Results in 0. Integer division rounds down to the nearest integer
    println!("quotient: {}", quotient);
    println!("floored: {}", floored);

    // remainder
    let remainder = 43 % 5;
    println!("remainder: {}", remainder);
}
#+END_SRC

**** The Boolean Type

Boolean type in Rust has two possible values: ~true~ and ~false~. Booleans are
one byte in size. The boolean type in Rust is specified using ~bool~. For
example:

#+BEGIN_SRC rust :results output
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation

    println!("t: {}", t);
    println!("f: {}", f)
}
#+END_SRC

**** The Character Type

Rust’s ~char~ type is the language’s most primitive alphabetic type. ~char~
literals are specified with single quotes, as opposed to string literals, which
use double quotes.

#+BEGIN_SRC rust :results output
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';

    println!("c: {}", c);
    println!("z: {}", z);
    println!("heart_eyed_cat: {}", heart_eyed_cat);
}
#+END_SRC

Rust’s ~char~ type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII.

*** Compbound types

Compound types can group multiple values into one type. Rust has two primitive
compound types: tuples and arrays.

**** The Tuple Type

Tuples have a fixed length: once declared, they cannot grow or shrink in size.
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. Type annotation is
optional:

#+BEGIN_SRC rust :noeval
fn main() {
    let annotated_tup: (i32, f64, u8) = (500, 6.4, 1);
    let unannotated_tup = (500, 6.4, 1);
}
#+END_SRC

To get the individual values out of a tuple, we can use pattern matching to
destructure a tuple value, like this:

#+BEGIN_SRC rust :results output
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+END_SRC

In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (~.~) followed by the index of the value we
want to access. For example:

#+BEGIN_SRC rust :results output
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("five_hundred:   {}", five_hundred);
    println!("six_point_four: {}", six_point_four);
    println!("one:            {}", one);
}
#+END_SRC

The tuple without any values, ~()~, is a special type that has only one value,
also written ~()~. The type is called the /unit type/ and the value is called
the /unit value/. Expressions implicitly return the unit value if they don’t
return any other value.

***** Mutable tuples

A tuple can be made mutable by adding the ~mut~ keyword. If you remove the ~mut~
keyword below, the compilation will fail

#+BEGIN_SRC rust :results output
fn main() {
    let mut x: (i32, f64, u8) = (500, 6.4, 1);
    x.0 = 400;
    let not_five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("not_five_hundred: {}", not_five_hundred);
    println!("six_point_four:   {}", six_point_four);
    println!("one:              {}", one);
}
#+END_SRC

**** The Array Type

Unlike a tuple, every element of an array must have the same type. Arrays in
Rust are different from arrays in some other languages because arrays in Rust
have a fixed length, like tuples. The length is defined at compile time. The
length of an array is part of its type.

In Rust, the values going into an array are written as a comma-separated list
inside square brackets:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
}
#+END_SRC

You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:

#+BEGIN_SRC rust :noeval
let a: [i32; 5] = [1, 2, 3, 4, 5];
#+END_SRC

Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [3; 5];
    let b = [3i64; 5]; // To define the type of the elements (in this case i64)
}
#+END_SRC

***** Accessing elements

#+BEGIN_SRC rust :results output
fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

If Rust knows at compile time that you are trying to access elements outside the
valid range, the compile will fail and you will get an error message. But checks
are done during run time as well so if you try to access an element outside the
valid range, the program will panic instead of allowing the program to access
the memory. Run the program in [[file:003_invalid_index][003_invalid_index]] for an example.

***** Mutable lists

Lists are immutable by default. You can make it mutable with the ~mut~ keyword

#+BEGIN_SRC rust :results output
fn main() {
    let mut a = [1, 2, 3, 4, 5];
    a[0] = 20;
    let first = a[0];
    let second = a[1];

    println!("first:  {}", first);
    println!("second: {}", second);
}
#+END_SRC

** Functions

Rust code uses snake case as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:

#+BEGIN_SRC rust :results output
fn main() {
    println!("Hello, world!");
    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+END_SRC

Function definitions in Rust start with ~fn~ and have a set of parentheses after
the function name. The curly brackets tell the compiler where the function body
begins and ends. Note that we defined ~another_function~ after the ~main~
function in the source code; we could have defined it before as well. Rust
doesn’t care where you define your functions, only that they’re defined
somewhere.

*** Function parameters

#+BEGIN_SRC rust :results output
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
#+END_SRC

In function signatures, you /must/ declare the type of each parameter. This is a
deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean.

Function with multiple paramaters:

#+BEGIN_SRC rust :results output
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+END_SRC

*** Function Bodies Contain Statements and Expressions

/Statements/ are instructions that perform some action and do not return a
value. /Expressions/ evaluate to a resulting value. Let’s look at some examples.

Creating a variable and assigning a value to it with the ~let~ keyword is a
statement. ~let y = 6;~ is a statement.

Statements do not return values. Therefore, you can’t assign a let statement to
another variable. E.g:

#+BEGIN_SRC rust :noeval
let x = (let y = 6); // Not valid code!
#+END_SRC

Expressions can be part of statements: the ~6~ in the statement ~let y = 6;~ is
an expression that evaluates to the value ~6~. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, ~{}~, is an expression, for example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = 5;
    let y = {
        let x = x + 3;
        x + 1
    };
    println!("The value of y is: {}", y);
}
#+END_SRC

The expression

#+BEGIN_SRC rust :noeval
let y = {
    let x = x + 3;
    x + 1
};
#+END_SRC

is a block that, in this case, evaluates to ~9~. That value gets bound to ~y~ as
part of the ~let~ statement. Note the ~x + 1~ line without a semicolon at the
end. Expressions do not include ending semicolons. If you add a semicolon to the
end of an expression, you turn it into a statement, which will then not return a
value. Keep this in mind as you explore function return values and expressions
next.

*** Functions with Return Values

Functions can return values to the code that calls them. We declare their type
after an arrow (~->~). In Rust, the return value of the function is synonymous
with the value of the final expression in the block of the body of a function.
You can return early from a function by using the ~return~ keyword and
specifying a value, but most functions return the last expression implicitly.

#+BEGIN_SRC rust :results output
fn five() -> i32 {
    5 // Note that there's no semi colon here
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}
#+END_SRC

Another example:

#+BEGIN_SRC rust :results output
fn main() {
    let x = plus_one(5);
    println!("The value of x is: {}", x);
    let y = plus_two(5);
    println!("The value of y is: {}", y);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}

fn plus_two(x: i32) -> i32 {
    // You are allowed to use 'return' to return early
    return x + 2 // Seems like the semi colon is optional here
}
#+END_SRC

** Comments

[[https://doc.rust-lang.org/reference/comments.html][Comments reference]]

Like in Java:

- Single line comments with ~//~
- Multi line comments starting with ~/*~ and ending with ~*/~

** Control Flow
*** ~if~ expressions

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+END_SRC

Blocks of code associated with the conditions in if expressions are sometimes
called /arms/. The ~else~ expression is optional.

It’s also worth noting that the condition in this code must be a ~bool~. If the
condition isn’t a ~bool~, we’ll get an error.

**** Handling Multiple Conditions with ~else if~

Simple example:

#+BEGIN_SRC rust :results output
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+END_SRC

**** Using ~if~ in a ~let~ Statement

Because ~if~ is an expression, we can use it on the right side of a ~let~
statement:

#+BEGIN_SRC rust :results output
fn main() {
    let condition = true;
    // Notice the lack of semi colons inside the blocks. They are expressions!
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+END_SRC

Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the whole
~if~ expression depends on which block of code executes. This means the values
that have the potential to be results from each arm of the ~if~ must be the same
type. In the code above, the results of both the ~if~ arm and the ~else~ arm
were ~i32~ integers. If the types are mismatched we’ll get an error.

*** Repetition with Loops

Rust has three kinds of loops:

- ~loop~
- ~while~
- ~for~

**** The ~loop~ loop

The ~loop~ keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop. You can place the ~break~
keyword within the loop to tell the program when to stop executing the loop.

We can also use the ~continue~ keyword. The ~continue~ keyword within a loop
tells the program to skip over any remaining code in this iteration of the loop
and go to the next iteration.

If you have loops within loops, ~break~ and ~continue~ apply to the innermost
loop at that point. You can optionally specify a /loop label/ on a loop and then
use the label with ~break~ or ~continue~ to have those keywords applied to the
labeled loop instead of the innermost loop. Here’s an example with two nested
loops:

#+BEGIN_SRC rust :results output
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+END_SRC

The outer loop has the label ~'counting_up~ (you need to start the label with a
~'~), and it will count up from 0 to 2. The inner loop without a label counts
down from 10 to 9. The first ~break~ that doesn’t specify a label will exit the
inner loop only. The ~break 'counting_up;~ statement will exit the outer loop.

***** Returning values from loops

One of the uses of a ~loop~ is to retry an operation you know might fail, such
as checking whether a thread has completed its job. However, you might need to
pass the result of that operation to the rest of your code. To do this, you can
add the value you want returned after the ~break~ expression you use to stop the
loop; that value will be returned out of the loop so you can use it, as shown
here:

#+BEGIN_SRC rust :results output
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("The result is {}", result);
}
#+END_SRC

**** The ~while~ loop

A ~while~ loop works as one would expect. ~break~ and ~continue~ are also allowed.

#+BEGIN_SRC rust :results output
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+END_SRC

**** The ~for~ loop

The ~for~ loop can be used when looping over the elements of a collection. You
could do it with a ~while~ loop as well but it's more error prone (the index may
go out of bounds which will cause the program to panic if you enter the wrong
value) and less efficient (Rust adds a check that the index is within the bound
of the array on every iteration).

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+END_SRC

With the ~for~ loop:

#+BEGIN_SRC rust :results output
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
#+END_SRC

Even in situations in which you want to run some code a certain number of times,
as in the countdown example that used a ~while~ loop above, you can use a ~for~
loop. The way to do that would be to use a ~Range~, provided by the standard
library, which generates all numbers in sequence starting from one number and
ending before another number. ~rev~ reverses the range.

#+BEGIN_SRC rust :results output
fn main() {
    for number in (1..4).rev() {
    // Or
    //for number in (1..=3).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
#+END_SRC

* Crates and dependencies

When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the registry, which is a copy of data from
[[https://crates.io/]]. crates.io is where people in the Rust ecosystem post their
open source Rust projects for others to use.

* Documentation

Another neat feature of Cargo is that you can run the command below, which will
build documentation provided by all of your dependencies locally and open it in
your browser.

#+BEGIN_SRC bash :noeval
cargo doc --open
#+END_SRC

* Style guide

https://doc.rust-lang.org/1.0.0/style/style/naming/README.html

* Clippy

https://doc.rust-lang.org/clippy/

* Misc

#+BEGIN_SRC rust :noeval
let apples = 5; // immutable
let mut bananas = 5; // mutable
#+END_SRC
