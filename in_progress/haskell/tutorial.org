* Table of Contents :TOC:QUOTE:
#+BEGIN_QUOTE
- [[#work-around-to-execute-haskell-programs-in-org-mode][Work around to execute haskell programs in org mode]]
- [[#basics][Basics]]
  - [[#basic-arithmetic][Basic arithmetic]]
  - [[#basic-logic-operators][Basic logic operators]]
  - [[#calling-functions][Calling functions]]
  - [[#defining-functions][Defining functions]]
  - [[#the-if-statement][The ~if~ statement]]
  - [[#lists][Lists]]
  - [[#tuples][Tuples]]
- [[#types][Types]]
  - [[#type-keywords][Type keywords]]
  - [[#type-variables][Type variables]]
  - [[#type-classes][Type classes]]
- [[#syntax-in-functions][Syntax in functions]]
  - [[#pattern-matching][Pattern matching]]
  - [[#guards][Guards]]
  - [[#the-where-keyword][The ~where~ keyword]]
  - [[#the-let-keyword][The ~let~ keyword]]
  - [[#case-expressions][Case expressions]]
- [[#links][Links]]
#+END_QUOTE

* Work around to execute haskell programs in org mode

Executable code but syntax highlighting is set to python

#+BEGIN_SRC  python :python runghc :results output
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

Correct syntax highlighting but not executable

#+BEGIN_SRC  haskell
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

To toggle between these two modes you can run the ~toggleedit~ script. Note that
the two code blocks above have an extra space before the language name so that
they will not be affected by the script. The code block below will be affected
though

#+BEGIN_SRC haskell
main = do
  putStrLn "------------------------------------------------"
  putStrLn "VALID HASKELL PROGRAM"
  putStrLn "------------------------------------------------"
#+END_SRC

* Basics
** Basic arithmetic

#+BEGIN_SRC haskell
main = do
  -- Addition
  print (2 + 2)
  -- Subtraction
  print (5 - 2)
  -- Multiplication
  print (5 * 5)
  -- Division (not integer division)
  print (5 / 2)
  -- Integer division
  print (div 5 2)
  -- Modulo
  print (mod 2 (-3))
  print (rem 2 (-3))
  -- Change precedence with parentheses
  print (2 + 2 * 2)
  print ((2 + 2) * 2)
#+END_SRC

When working with negative number, always enclose them in parentheses. The
example below won't work

#+BEGIN_SRC haskell
main = do
  print (5 * -3)
#+END_SRC

While the following will

#+BEGIN_SRC haskell
main = do
  print (5 * (-3))
#+END_SRC

** Basic logic operators

#+BEGIN_SRC haskell
main = do
  -- And
  print (True && True)
  print (True && False)
  -- Or
  print (True || False)
  print (False || False)
  -- Not
  print (not (True && False))
  print (not True)
#+END_SRC

Testing equality

#+BEGIN_SRC haskell
main = do
  -- Equality
  print (9 == 9)
  print (8 == 9)
  print ("hello" == "hello")
  -- Inequality
  print (9 /= 9)
  print (8 /= 9)
#+END_SRC

~==~ and ~/=~ will only work if the two elements can be compared. The following
will now work

#+BEGIN_SRC haskell
main = do
  print (4 /= "hello")
#+END_SRC

But sometimes objects of different types can be compared. E.g. integers and
floats. In the following example the integer will be converted to a float

#+BEGIN_SRC haskell
main = do
  print (4.0 == 4)
#+END_SRC

Comparing number

#+BEGIN_SRC haskell
main = do
  print (4 < 5)
  print (5 < 4)
  print (4 > 5)
  print (5 > 4)
  print (4 <= 5)
  print (5 <= 5)
  print (4 >= 5)
  print (5 >= 5)
#+END_SRC

** Calling functions

In haskell no parantheses should be used when providing the arguments to a
function. You just separate all arguments with a space. In the following
examples we still use parantheses for the ~print~ function. Otherwise ~succ 8~
would be treated a two arguments to the ~print~ function instead of a function
call itself

#+BEGIN_SRC haskell
main = do
  print (succ 8)
#+END_SRC

Multiple arguments

#+BEGIN_SRC haskell
main = do
  print (min 8 15)
  print (max 6.4 2)
#+END_SRC

A function call has the highest precedence so you don't need to put parantheses
around it

#+BEGIN_SRC haskell
main = do
  print (succ 9 + max 5 4 + 1)
  print ((succ 9) + (max 5 4) + 1)
  print (succ 8 * 2)
  print (succ (8 * 2))
#+END_SRC

You can make a function /infix/ by putting backticks around the function name

#+BEGIN_SRC haskell
main = do
  print (div 11 3)
  print (11 `div` 3)
#+END_SRC

If a function is comprised only of special characters, it's considered an infix
function by default. If we want to pass it to another function or call it as a
prefix function, we have to surround it in parentheses.

#+BEGIN_SRC haskell
main = do
  print ((==) 11 3)
  print ((==) 3 3)
#+END_SRC

** Defining functions

The following code defines a function that will double the input value

#+BEGIN_SRC haskell
doubleMe x = x + x

main = do
  print (doubleMe 5)
#+END_SRC

The order the functions are defined doesn't matter

#+BEGIN_SRC haskell
main = do
  print (doubleMe 5)

doubleMe x = x + x
#+END_SRC

Note that the ~doubleMe~ function doesn't specify a type so any type where the
~+~ operator can be applied can be used

#+BEGIN_SRC haskell
doubleMe x = x + x

main = do
  print (doubleMe 5)
  print (doubleMe 8.3)
#+END_SRC

Let us define 2 functions that double 2 input values and sums them together

#+BEGIN_SRC haskell
doubleMe x = x + x

doubleUs x y = 2 * x  + 2 * y
doubleUs2 x y = doubleMe x  + doubleMe y

main = do
  print (doubleUs 3 4)
  print (doubleUs2 3 4)
#+END_SRC

And let us define a function with no arguments

#+BEGIN_SRC haskell
numberOne = 1

main = do
  print (numberOne)
#+END_SRC

*** Naming

A function can't start with a capital letter and ~'~ is a valid character to
use. It is often used to denote a strict version of a function (one that isn't
lazy) or a slightly modified version of a function or a variable

** The ~if~ statement

Unlike other languages the ~else~ part is mandatory in Haskell. The ~if~
statement is an expression in Haskell as it has a return value. Below we are
writing the ~if~ statement on multiple lines but we can write it all on the same
line if we wanted to

#+BEGIN_SRC haskell
doubleOddNumber x = if x `mod` 2 == 0
                      then x
                      else x * 2

main = do
  print (doubleOddNumber 6)
  print (doubleOddNumber 5)
  print (doubleOddNumber (-4))
  print (doubleOddNumber (-7))
#+END_SRC

Since the ~if~ statement have a return value we can easily add 1 to the result

#+BEGIN_SRC haskell
doubleOddNumberAndAddOne x = (if x `mod` 2 == 0
                                then x
                                else x * 2) + 1

main = do
  print (doubleOddNumberAndAddOne 6)
  print (doubleOddNumberAndAddOne 5)
  print (doubleOddNumberAndAddOne (-4))
  print (doubleOddNumberAndAddOne (-7))
#+END_SRC

** Lists

In Haskell lists stores data of the same type so we can't have a list which both
store integers and characters. The ~let~ keyword is used in Haskell to define a
name

#+BEGIN_SRC haskell
main = do
  let myNumberList = [1,2,4,8,16,32]
  print myNumberList
  let myCharList = ['C','h','a','r','s']
  print myCharList
  let myStringList = ["My","String", "List"]
  print myStringList
#+END_SRC

As you see from the output of ~myCharList~ above, a string is a list of chars

#+BEGIN_SRC haskell
main = do
  print ("Chars" == ['C','h','a','r','s'])
#+END_SRC

Since strings are list we can use list functions on them

*** Concatenate lists

Concatenation is done with the ~++~ operator. Note that it can also be used on
strings which are nothing but a list of characters

#+BEGIN_SRC haskell
main = do
  print ([1,2,3,4] ++ [5,6,7,8])
  print ("Hello" ++ " " ++ "World")
  print (['H','a','s'] ++ ['k','e','l','l'])
#+END_SRC

Note that when you concatenate two lists, Haskell will internally walk through
all elements on the left hand side of the ~++~. This may affect performance for
big left hand side lists. Note that putting something at the beginning of a list
using the cons operator (~:~) is instantaneous

#+BEGIN_SRC haskell
main = do
  print (1:[2,3,4])
  print ('H':"ello World")
#+END_SRC

Note that ~++~ accepts two lists as arguments while ~:~ accepts an element and a
list. ~[1,2,3]~ is actually just syntactic sugar for ~1:2:3:[]~ (~[]~ is the
empty list).

*** Get an element in a list

To get an element at a specific index in the list we use the ~!!~ operator. The
index starts at 0.

#+BEGIN_SRC haskell
main = do
  let myIntegerList = [1,2,4,8,16,32]
  print (myIntegerList !! 1)
  print (myIntegerList !! 4)
#+END_SRC

*** Lists of lists

A list can contain of other lists. As before each element in a list needs to be
of the same type which means that all lists in a list of lists needs to contain
the same type of element, e.g. integers. The lists can be of different lengths.

#+BEGIN_SRC haskell
main = do
  let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
  print b
  print (b ++ [[3,2,1]])
  print ([3,2,1]:b)
  print (b !! 1)
#+END_SRC

*** Comparing lists

Lists can be compared with ~<~, ~<=~, ~>~ and ~>=~ if the elements the list
contains can be compared with these operators. The elements in the lists are
compared in order and if the elements on a index is equal the next pairs will
be compared

#+BEGIN_SRC haskell
main = do
  print ([3,2,1] > [2,1,0])
  print ([3,2,1] > [2,10,100])
  print ([3,4,2] > [3,4]) -- [3,4,2] is considered bigger as it has an extra element
  print ([3,4] > [3,4,2])
  print ([3,4,2] > [2,4])
  print ([3,4,2] == [3,4,2])
#+END_SRC

*** Other functions

~head~ returns the first element in a list

#+BEGIN_SRC haskell
main = do
  print (head [3,2,1])
#+END_SRC

~tail~ returns everything but the head

#+BEGIN_SRC haskell
main = do
  print (tail [4,3,2,1,0])
#+END_SRC

~last~ returns the last element in a list

#+BEGIN_SRC haskell
main = do
  print (last [4,3,2,1,0])
#+END_SRC

~init~ returns everything but the last element

#+BEGIN_SRC haskell
main = do
  print (init [4,3,2,1,0])
#+END_SRC

~length~ returns the length of a list

#+BEGIN_SRC haskell
main = do
  print (length [4,3,2,1,0])
#+END_SRC

~null~ checks if a list is empty. Returns ~True~ if empty. To be used instead of
checking for equality with ~[]~

#+BEGIN_SRC haskell
main = do
  print (null [4,3,2,1,0])
  print (null [])
#+END_SRC

~reverse~ reverses a list

#+BEGIN_SRC haskell
main = do
  print (reverse [4,3,2,1,0])
#+END_SRC

~take~ returns the first ~x~ elements from a list. Can be used on infinite
sequences

#+BEGIN_SRC haskell
main = do
  print (take 3 [4,3,2,1,0])
  print (take 8 [4,3,2,1,0])
  print (take 0 [4,3,2,1,0])
#+END_SRC

~drop~ is the opposite of ~take~. We return everything but the first ~x~
elements

#+BEGIN_SRC haskell
main = do
  print (drop 3 [4,3,2,1,0])
  print (drop 8 [4,3,2,1,0])
  print (drop 0 [4,3,2,1,0])
#+END_SRC

~maximum~ and ~minimum~ returns the largest or smallest element if the elements
can be compared

#+BEGIN_SRC haskell
main = do
  print (maximum [4,3,20,-4,1,0])
  print (minimum [4,3,20,-4,1,0])
#+END_SRC

~sum~ and ~product~ returns the sum or product of a list of numbers

#+BEGIN_SRC haskell
main = do
  print (sum [1,2,3,4])
  print (product [1,2,3,4])
#+END_SRC

~elem~ checks if an element is present in a list

#+BEGIN_SRC haskell
main = do
  print (2 `elem` [1,2,3,4])
  print (5 `elem` [1,2,3,4])
#+END_SRC

*** Texas ranges

If you want to create a list with all numbers ranging from 1 to 50 you can
create the list and provide each number individually. Or you can just write
~[1..50]~. You can do something similar with characters

#+BEGIN_SRC haskell
main = do
  print ([1..50])
  print (['a'..'z'])
  print (['A'..'Z'])
  print (['A'..'z'])
#+END_SRC

You can also define a step. The difference between the first and second element
in the range will be the step size

#+BEGIN_SRC haskell
main = do
  print ([1,4..50])
  print ([10,20..100])
#+END_SRC

You can also have a negative step size

#+BEGIN_SRC haskell
main = do
  print ([20,19..4])
  print ([100,90..0])
#+END_SRC

Because the way floats are handled in the computer it's bad idea to use floats
with ranges

#+BEGIN_SRC haskell
main = do
  print ([0.1, 0.3 .. 1])
#+END_SRC

You don't have to specify an upper limit. This will create an infinite lists but
since Haskell is lazy it will only generate as much as is needed

#+BEGIN_SRC haskell
main = do
  print (take 24 [13,26..])
#+END_SRC

To repeat a list an infinite amount of times you can use the ~cycle~ function

#+BEGIN_SRC haskell
main = do
  print (take 24 (cycle [1,2,3,4]))
  print (take 24 (cycle "Batman"))
#+END_SRC

To repeat an element an infinite numbers of time you can use the ~repeat~
function

#+BEGIN_SRC haskell
main = do
  print (take 24 (repeat 'A'))
  -- Or just use replicate for the same results
  print (replicate 24 'A')
#+END_SRC

*** List comprehensions

With list comprehensions we can transform every value in a list by applying a
function to it. Below we will multiply every value in a list with itself

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10]])
#+END_SRC

We can also filter the result. Say that we are only interested in the power if
two greater than 50

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10], x*x > 50])
#+END_SRC

We can include multiple predicates for the filtering and the element will only
be included in the resulting list if all of them evaluates to true. Let's add
the predicate that the result should be smaller than 90

#+BEGIN_SRC haskell
main = do
  print ([x*x | x <- [1..10], x*x > 50, x*x < 90])
#+END_SRC

We can also draw values from multiple lists where all combinations from the
input lists will be created. Below we will create tuples for each result

#+BEGIN_SRC haskell
main = do
  print ([(x,y) | x <- [1..4], y <- [3..5]])
#+END_SRC

We can also use predicates when drawing values from multiple lists. Below we
will only output the pairs whos sum is even

#+BEGIN_SRC haskell
main = do
  print ([(x,y) | x <- [1..4], y <- [3..5], even (x + y)])
#+END_SRC

We can now define our own version of ~length~

#+BEGIN_SRC haskell
length' xs = sum [1 | _ <- xs]

main = do
  print (length' [1..10])
#+END_SRC

The ~_~ in the code block above means that we don't care about the value that
would be put in that variable if we gave it a name

We can also nest list comprehensions. The code block below let us remove all odd
values from the containing lists without flattening it

#+BEGIN_SRC haskell
main = do
  let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
  print ([[ x | x <- xs, even x ] | xs <- xxs])
#+END_SRC

** Tuples

Tuples are like lists of fixed length and may mix types. If you change the
length or containing types the type of the tuple will change. Tuples are wrapped
with parantheses.

The following code will run fine. You have a list of integer pairs:

#+BEGIN_SRC haskell
main = do
  print ([(1,2),(8,11),(4,5)])
#+END_SRC

But the following wont work as we have mixed integer pairs with an integer
triple:

#+BEGIN_SRC haskell
main = do
  print ([(1,2),(8,5,11),(4,5)])
#+END_SRC

If we would have replaced the lists of tuples with lists of lists both examples
above would have worked.

We have two functions that can be used to operate on pairs: ~fst~ and ~snd~
which are used to get the first and second value respectively

#+BEGIN_SRC haskell
main = do
  print (fst (1, "one"))
  print (snd (1, "one"))
#+END_SRC

Those functions only work on pairs. The following code won't work

#+BEGIN_SRC haskell
main = do
  print (fst (1, "one", "ett"))
  print (snd (1, "one", "ett"))
#+END_SRC

Haskell also has a function called ~zip~ which takes two lists and zips them
together by joining the matching elements together until the shortest list is
depleted. The result will be a list of tuples.

#+BEGIN_SRC haskell
main = do
  print (zip [1,2,3,4,5] [5,5,5,5,5])
  print (zip [1..] ["apple", "orange", "cherry", "mango"])
#+END_SRC

To reverse the effect you can call the ~unzip~ function

#+BEGIN_SRC haskell
main = do
  print (unzip [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")])
#+END_SRC

An example how tuples can be used is shown below. The function calculates all
right triangles with sides less than or equal to 10 and a perimeter exactly
equal to 24

#+BEGIN_SRC haskell
rightTriangles = [(a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]

main = do
  print (rightTriangles)
#+END_SRC

* Types

Haskell has a static type system but unlike Java Haskell has type inference. If
we write a number, we don't have to tell Haskell it's a number. It can infer
that on its own, so we don't have to explicitly write out the types of our
functions and expressions to get things done.

#+BEGIN_SRC haskell
import Data.Typeable

main = do
  print (typeOf 'a')
  print (typeOf True)
  print (typeOf "Hello")
  print (typeOf (True, 'a'))
  print (typeOf (4 == 5))
#+END_SRC

Functions also have types and we can choose to give them an explicit type
declaration. This is considered good practice except when writing short
functions.

#+BEGIN_SRC haskell
import Data.Typeable

removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

main = do
  print (typeOf removeNonUppercase)
#+END_SRC

The type above means that it accepts a strings as parameter and returns a
string. We can use the ~String~ keyword as well instead of ~[Char]~.

#+BEGIN_SRC haskell
import Data.Typeable

-- Try removing the type declaration and you will see that the compiler can infer the type anyway
removeNonUppercase :: String -> String
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

main = do
  print (typeOf removeNonUppercase)
#+END_SRC

If we have a method accepting three argumente you can write like this:

#+BEGIN_SRC haskell
import Data.Typeable

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

main = do
  print (typeOf addThree)
  --let addTwoTo4 = addThree 4
  --print (addTwoTo4 2 4)
#+END_SRC

** Type keywords

| Type      | Description                                                                                      |
|-----------+--------------------------------------------------------------------------------------------------|
| ~Int~     | Integer. ~Int~ is bounded. Check ~minBound :: Int~ and ~maxBound :: Int~ for boundaries          |
| ~Integer~ | Also integer but is not bounded and can represent very big numbers. Not as efficient as ~Int~    |
| ~Float~   | Single precision float                                                                           |
| ~Double~  | Double precision float                                                                           |
| ~Bool~    | Boolean and only has two values: ~True~ and ~False~                                              |
| ~Char~    | Character. Represented by a character in single quotes (e.g. ~'g'~). A list of chars is a string |
| ~(a,b,c)~ | Tuple. Note that there also is an empty tuple ~()~                                               |
| ~[a]~     | List                                                                                             |

** Type variables

Functions that have type variables are polymorphic functions, i.e. a function
may accept variables of different types and/or return variables of different
types. Type variables resembles generics in other languages. The ~head~ function
is an example of a function which have type variables

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  head :: [a] -> a
:t head
#+END_SRC

From the result of the above code block you can see that ~head~ accepts a list
of any type and results in an element of the type the list contained

A function can also contain multiple type variable, e.g. ~fst~ and ~snd~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  fst :: (a, b) -> a
:t fst
#+END_SRC

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  snd :: (a, b) -> b
:t snd
#+END_SRC

Just because ~a~ and ~b~ are different type variables doesn't mean that they
must be of different types. But all occurences of e.g. ~a~ in a type will be the
same type.

** Type classes

If a type is part of a type class it means that it supports the behaviour that
the type class describes. You can think of them as interfaces in Java. We can
look at the type signature of the ~==~ function

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  (==) :: Eq a => a -> a -> Bool
:t (==)
#+END_SRC

Everything before the ~=>~ is called a class contstraint. The type signature
above translates to ~==~ takes two values of the same type which must be a
member of the ~Eq~ class and returns a ~Bool~.

Some basic type classes:

*** The ~Eq~ type class

For equality testing. The members of this type class must implement ~==~ and
~/=~

*** The ~Ord~ type class

For types that have an ordering. The members of this type class must implement
~<~, ~>~, ~<=~, ~>=~. They must also be members of the ~Eq~ type class

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  (>) :: Ord a => a -> a -> Bool
:t (>)
#+END_SRC

*** The ~Show~ type class

Can be presented as strings. The most used function that deals with the ~Show~
typeclass is the function ~show~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  show :: Show a => a -> String
:t show
#+END_SRC

*** The ~Read~ type class

Can be created from a string using the ~read~ function.

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  read :: Read a => String -> a
:t read
#+END_SRC

Examples:

#+BEGIN_SRC haskell
main = do
  print (read "True" || False)
  print (read "8.2" + 3.8)
  print (read "5" - 2)
  print (read "[1,2,3,4]" ++ [3])
#+END_SRC

But what happens if we just run:

#+BEGIN_SRC haskell
main = do
  let readValue = read "4"
  print readValue
#+END_SRC

The compiler can't infer what kind of result we wanted from the ~read~ function
anylonger. If we used the variable as a ~Bool~ then the compiler would assume
that the variable is a ~Bool~ and if we use it as an ~Int~ the compiler would
assume that the variable is an ~Int~. See what happens when we add an ~Int~ to
the result

#+BEGIN_SRC haskell
main = do
  let readValue = read "4"
  print (readValue + 4)
#+END_SRC

To overcome this problem we can use *type annotations*. Type annotations are a
way of explicitly saying what the type of an expression should be. We do that by
adding ~::~~ at the end of the expression and then specifying a type

#+BEGIN_SRC haskell
main = do
  let readValue = read "4" :: Int
  print readValue
#+END_SRC

Can also be used on other classes

#+BEGIN_SRC haskell
main = do
  print (read "5" :: Int)
  print (read "5" :: Float)
  print ((read "5" :: Float) * 4)
  print (read "[1,2,3,4]" :: [Int])
  print (read "(3, 'a')" :: (Int, Char))
#+END_SRC

Most expressions are such that the compiler can infer what their type is by
itself. To see what the type is, Haskell would have to actually evaluate the
result of the ~read~ function but since Haskell is a statically typed language,
it has to know all the types before the code is compiled

*** The ~Enum~ type class

Are sequentially ordered types. They can be used in list ranges and have defined
successors and predecesors, which you can get with the ~succ~ and ~pred~
functions.

#+BEGIN_SRC haskell
main = do
  print (['a'..'e'])
  print (succ 'B')
  print (pred 'B')
#+END_SRC

*** The ~Bounded~ type class

Have an upper and lower bound and should provide the ~minBound~ and ~maxBound~
functions. By investigating the type signatures of these methods you can see
that they act like polymorphic constants.

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  minBound :: Bounded a => a
:t minBound
#+END_SRC

Examples:

#+BEGIN_SRC haskell
main = do
  print (minBound :: Int)
  print (maxBound :: Int)
  print (minBound :: Char)
  print (maxBound :: Char)
#+END_SRC

Tuples which only contains ~Bounded~ classes are also part of the ~Bounded~ type
class

*** The ~Num~ type class

Is a numeric type class. All members can act like numbers

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  20 :: Num a => a
:t 20
#+END_SRC

So ~20~ is part of ~Num~ and may act like any type that's a member of ~Num~.

#+BEGIN_SRC haskell
main = do
  print (20 :: Int)
  print (20 :: Integer)
  print (20 :: Float)
  print (20 :: Double)
#+END_SRC

If we inspect the type signature of ~*~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  (*) :: Num a => a -> a -> a
:t (*)
#+END_SRC

we see that the ~*~ function accepts two arguments of the same type which
explains why the following code won't work (~Int~ and ~Integer~ are not the same
class!)

#+BEGIN_SRC haskell
main = do
  print ((5 :: Int) * (6 :: Integer))
#+END_SRC

while the following will (~5~ is a ~Num~ and may be represented by an ~Integer~)

#+BEGIN_SRC haskell
main = do
  print (5 * (6 :: Integer))
#+END_SRC

To be a member of ~Num~ the type also needs to be a member of ~Eq~ and ~Show~

*** The ~Floating~ type class

Includes only floating point numbers. ~Float~ and ~Double~ are members of this
type class

*** The ~Integral~ type class

Includes only integral (whole) numbers. ~Int~ and ~Integer~ are members of this
type class.

A useful function to deal with numbers are ~fromIntegral~

#+BEGIN_SRC  haskell
-- The following code is run in ghci instead of ghc
-- The following code results in:  fromIntegral :: (Integral a, Num b) => a -> b
:t fromIntegral
#+END_SRC

This function accepts an ~Integral~ and returns a ~Num~. It's useful when you
have an ~Integral~ and want it to also work with floats point types. The
~length~ function returns an ~Int~ which makes it hard to add a ~Float~ to it
afterwards. Then it's nice to convert the ~Int~ to a ~Num~ first.

Also note that ~fromIntegral~ have several class constraints which is a valid
thing to do.

* Syntax in functions

** Pattern matching


** Guards


** The ~where~ keyword


** The ~let~ keyword


** Case expressions

* Links

- [[https://hackage.haskell.org/package/CheatSheet-1.11/src/CheatSheet.pdf]]
- [[http://learnyouahaskell.com/chapters]]
- [[https://www.haskell.org/hoogle/]]
- [[http://book.realworldhaskell.org/]]
